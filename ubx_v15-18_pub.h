/***********************************************************
 *
 * Copyright (C) u-blox AG
 * u-blox AG, Thalwil, Switzerland
 *
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice is
 * included in all copies of any software which is or includes a copy or
 * modification of this software and in all copies of the supporting
 * documentation for such software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY. IN PARTICULAR, NEITHER THE AUTHOR NOR U-BLOX MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF
 * THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 ***********************************************************
 *
 * Project:  Protocol Specification
 * Purpose:  Structure definitions for UBX messages
 * Audience: PUB
 *
 * Supported Protocol Versions: 15-18
 *
 * This file is automatically generated!
 * Manual edits may be overwritten!
 *
 ***********************************************************/
/*!
    \file
    \brief UBX message definitions

*/

#ifndef __PROTO_UBX_STRUCT_DEF_H_00B82B9A_255D01E8
#define __PROTO_UBX_STRUCT_DEF_H_00B82B9A_255D01E8

#ifndef UBX_STANDARD_TYPES_DEFINED
/*----------------*/
/* Standard types */
/*----------------*/
typedef signed int             I;   //!<  = I4
typedef unsigned int           U;   //!<  = U4
typedef unsigned long          BL;  //!<  = L4 (TRUE or FALSE only)
typedef signed char            I1;  //!<  signed 1 byte integer
typedef signed short           I2;  //!<  signed 2 byte integer
typedef signed int             I4;  //!<  signed 4 byte integer
typedef signed long long int   I8;  //!<  signed 8 byte integer
typedef unsigned char          U1;  //!<  unsigned 1 byte integer
typedef unsigned char          X1;  //!<  unsigned 1 byte integer, to be interpreted as bitmask
typedef unsigned short         U2;  //!<  unsigned 2 byte integer
typedef unsigned short         X2;  //!<  unsigned 2 byte integer, to be interpreted as bitmask
typedef unsigned int           U4;  //!<  unsigned 4 byte integer
typedef unsigned int           X4;  //!<  unsigned 4 byte integer, to be interpreted as bitmask
typedef unsigned long long int U8;  //!<  unsigned 8 byte integer
typedef float                  R4;  //!<  4 byte floating point
typedef double                 R8;  //!<  8 byte floating point
typedef char                   CH;  //!<  ASCII character
typedef unsigned char          L1;  //!<  1 byte logical (TRUE or FALSE only)
typedef unsigned short         L2;  //!<  2 byte logical (TRUE or FALSE only)
typedef unsigned int           L4;  //!<  4 byte logical (TRUE or FALSE only)
typedef unsigned int            L;  //!<  4 byte logical (TRUE or FALSE only)
typedef unsigned char         BCH;  //!<  binary data

#define UBX_STANDARD_TYPES_DEFINED
#endif // ifndef UBX_STANDARD_TYPES_DEFINED

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

//! UBX Protocol Header
typedef struct UBX_HEAD_s
{
    U2 prefix;                  //!< Prefix, always #UBX_PREFIX
    U1 classId;                 //!< UBX Class Id
    U1 msgId;                   //!< UBX Message Id
    U2 size;                    //!< Payload Size
} UBX_HEAD_t, *UBX_HEAD_pt;

#define UBX_SYNC_CHAR_1 0xB5u    //!< First synchronization character of UBX Protocol
#define UBX_SYNC_CHAR_2 0x62u    //!< Second synchronization character of UBX Protocol
#define UBX_PREFIX      (UBX_SYNC_CHAR_2<<8|UBX_SYNC_CHAR_1) //!< UBX Protocol Prefix
#define UBX_PREFIX_SIZE 2u       //!< UBX Protocol Prefix Size in bytes
#define UBX_CHKSUM_SIZE 2u       //!< UBX Protocol Checksum Size in bytes

#define UBX_HEAD_SIZE sizeof(UBX_HEAD_t)                      //!< UBX Protocol Header Size
#define UBX_FRAME_SIZE (UBX_HEAD_SIZE+UBX_CHKSUM_SIZE) //!< Total size of the UBX Frame



//================================================================
//! ACK_ACK_DATA0: Output
/*!
Message Acknowledged
Output upon processing of an input message


This message's id is #UBXID_ACK_ACK
*/
//================================================================

typedef struct UBX_ACK_ACK_DATA0_s
{
    U1  clsID;                    //!< Class ID of the Acknowledged Message
    U1  msgID;                    //!< Message ID of the Acknowledged Message

} UBX_ACK_ACK_DATA0_t, *UBX_ACK_ACK_DATA0_pt;


#define UBXID_ACK_ACK 0x0501 //!< message id for ACK-ACK


//================================================================
//! ACK_NAK_DATA0: Output
/*!
Message Not-Acknowledged
Output upon processing of an input message


This message's id is #UBXID_ACK_NAK
*/
//================================================================

typedef struct UBX_ACK_NAK_DATA0_s
{
    U1  clsID;                    //!< Class ID of the Not-Acknowledged Message
    U1  msgID;                    //!< Message ID of the Not-Acknowledged Message

} UBX_ACK_NAK_DATA0_t, *UBX_ACK_NAK_DATA0_pt;


#define UBXID_ACK_NAK 0x0500 //!< message id for ACK-NAK


//================================================================
//! AID_ALM_POLL0: Poll Request
/*!
Poll GPS Aiding Almanac Data
Poll GPS Aiding Data (Almanac) for all 32 SVs by sending this message to the receiver without any payload. The receiver will return 32 messages of type AID-ALM as defined below.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_ALM
*/
//================================================================

typedef struct UBX_AID_ALM_POLL0_s
{

} UBX_AID_ALM_POLL0_t, *UBX_AID_ALM_POLL0_pt;


#define UBXID_AID_ALM 0x0B30 //!< message id for AID-ALM


//================================================================
//! AID_ALM_POLLID: Poll Request
/*!
Poll GPS Aiding Almanac Data for a SV
Poll GPS Aiding Data (Almanac) for an SV by sending this message to the receiver. The receiver will return one message of type AID-ALM as defined below.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_ALM
*/
//================================================================

typedef struct UBX_AID_ALM_POLLID_s
{
    U1  svid;                     //!< SV ID for which the receiver shall return its Almanac Data (Valid Range: 1 .. 32 or 51, 56, 63).

} UBX_AID_ALM_POLLID_t, *UBX_AID_ALM_POLLID_pt;


//#define UBXID_AID_ALM 0x0B30  // already defined, see above


//================================================================
//! AID_ALM_DATA0: Input/Output
/*!
GPS Aiding Almanac Input/Output Message
* If the WEEK Value is 0, DWRD0 to DWRD7 are not sent as the Almanac is not available for the given SV. This may happen even if NAV-SVINFO and RXM-SVSI are indicating almanac availability as the internal data may not represent the content of an original broadcast almanac (or only parts thereof).
* DWORD0 to DWORD7 contain the 8 words following the Hand-Over Word ( HOW ) from the GPS navigation message, either pages 1 to 24 of sub-frame 5 or pages 2 to 10 of subframe 4. See IS-GPS-200 for a full description of the contents of the Almanac pages.
* In DWORD0 to DWORD7, the parity bits have been removed, and the 24 bits of data are located in Bits 0 to 23. Bits 24 to 31 shall be ignored.
* Example: Parameter e (Eccentricity) from Almanac Subframe 4/5, Word 3, Bits 69-84 within the subframe can be found in DWRD0, Bits 15-0 whereas Bit 0 is the LSB.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_ALM
*/
//================================================================

//! Repeated Sub-Structure of #UBX_AID_ALM_DATA0_t
typedef struct UBX_AID_ALM_DATA0_DWRD_s
{
    U4  dwrd[8];                  //!< Almanac Words

} UBX_AID_ALM_DATA0_DWRD_t, *UBX_AID_ALM_DATA0_DWRD_pt;



typedef struct UBX_AID_ALM_DATA0_s
{
    U4  svid;                     //!< SV ID for which this
    U4  week;                     //!< Issue Date of Almanac (GPS week number)
    //OPTIONAL: UBX_AID_ALM_DATA0_DWRD_t repeat0[0];

} UBX_AID_ALM_DATA0_t, *UBX_AID_ALM_DATA0_pt;


//#define UBXID_AID_ALM 0x0B30  // already defined, see above


//================================================================
//! AID_AOP_POLL0: Poll Request
/*!
Poll AssistNow Autonomous data, all satellites
Poll <i>AssistNow Autonomous</i> aiding data for all GPS satellites by sending this empty message. The receiver will return an AID-AOP message (see definition below) for each GPS satellite for which data is available.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_AOP
*/
//================================================================

typedef struct UBX_AID_AOP_POLL0_s
{

} UBX_AID_AOP_POLL0_t, *UBX_AID_AOP_POLL0_pt;


#define UBXID_AID_AOP 0x0B33 //!< message id for AID-AOP


//================================================================
//! AID_AOP_POLLID: Poll Request
/*!
Poll AssistNow Autonomous data, one GPS satellite
Poll the <i>AssistNow Autonomous</i> data for the specified GPS satellite. The receiver will return a AID-AOP message (see definition below) if data is available for the requested satellite.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_AOP
*/
//================================================================

typedef struct UBX_AID_AOP_POLLID_s
{
    U1  svid;                     //!< GPS SV ID for which the data is requested (valid range: 1..32).

} UBX_AID_AOP_POLLID_t, *UBX_AID_AOP_POLLID_pt;


//#define UBXID_AID_AOP 0x0B33  // already defined, see above


//================================================================
//! AID_AOP_DATA2: Input/Output
/*!
AssistNow Autonomous data
If enabled, this message is output at irregular intervals. It is output whenever <i>AssistNow Autonomous</i> has produced new data for a satellite. Depending on the availability of the optional data the receiver will output either version of the message. If this message is polled using one of the two poll requests described above the receiver will send this message if AssistNow Autonomous data is available or the corresponding poll request message if no AssistNow Autonomous data is available for each satellite (i.e. svid 1..32). At the user's choice the optional data may be chopped from the payload of a previously polled message when sending the message back to the receiver. Sending a valid AID-AOP message to the receiver will automatically enable the <i>AssistNow Autonomous</i> feature on the receiver. See the section <r href=\"AOP-DESC'>AssistNow Autonomous</r> in the receiver description for details on this feature.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_AOP
*/
//================================================================

typedef struct UBX_AID_AOP_DATA2_s
{
    U1  gnssId;                   //!< GNSS identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  svId;                     //!< Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  data[64];                 //!< assistance data

} UBX_AID_AOP_DATA2_t, *UBX_AID_AOP_DATA2_pt;


//#define UBXID_AID_AOP 0x0B33  // already defined, see above


//================================================================
//! AID_EPH_POLL0: Poll Request
/*!
Poll GPS Aiding Ephemeris Data
Poll GPS Aiding Data (Ephemeris) for all 32 SVs by sending this message to the receiver without any payload. The receiver will return 32 messages of type AID-EPH as defined below.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_EPH
*/
//================================================================

typedef struct UBX_AID_EPH_POLL0_s
{

} UBX_AID_EPH_POLL0_t, *UBX_AID_EPH_POLL0_pt;


#define UBXID_AID_EPH 0x0B31 //!< message id for AID-EPH


//================================================================
//! AID_EPH_POLLID: Poll Request
/*!
Poll GPS Aiding Ephemeris Data for a SV
Poll GPS Constellation Data (Ephemeris) for an SV by sending this message to the receiver. The receiver will return one message of type AID-EPH as defined below.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_EPH
*/
//================================================================

typedef struct UBX_AID_EPH_POLLID_s
{
    U1  svid;                     //!< SV ID for which the receiver shall return its Ephemeris Data (Valid Range: 1 .. 32).

} UBX_AID_EPH_POLLID_t, *UBX_AID_EPH_POLLID_pt;


//#define UBXID_AID_EPH 0x0B31  // already defined, see above


//================================================================
//! AID_EPH_DATA0: Input/Output
/*!
GPS Aiding Ephemeris Input/Output Message
* SF1D0 to SF3D7 is only sent if ephemeris is available for this SV. If not, the payload may be reduced to 8 Bytes, or all bytes are set to zero, indicating that this SV Number does not have valid ephemeris for the moment. This may happen even if NAV-SVINFO and RXM-SVSI are indicating ephemeris availability as the internal data may not represent the content of an original broadcast ephemeris (or only parts thereof).
* SF1D0 to SF3D7 contain the 24 words following the Hand-Over Word ( HOW ) from the GPS navigation message, subframes 1 to 3. The Truncated TOW Count is not valid and cannot be used. See IS-GPS-200 for a full description of the contents of the Subframes.
* In SF1D0 to SF3D7, the parity bits have been removed, and the 24 bits of data are located in Bits 0 to 23. Bits 24 to 31 shall be ignored.
* When polled, the data contained in this message does not represent the full original ephemeris broadcast. Some fields that are irrelevant to u-blox receivers may be missing. The week number in Subframe 1 has already been modified to match the Time Of Ephemeris (TOE).

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_EPH
*/
//================================================================

//! Repeated Sub-Structure of #UBX_AID_EPH_DATA0_t
typedef struct UBX_AID_EPH_DATA0_SF1D_s
{
    U4  sf1d[8];                  //!< Subframe 1 Words 3..10 (SF1D0..SF1D7)
    U4  sf2d[8];                  //!< Subframe 2 Words 3..10 (SF2D0..SF2D7)
    U4  sf3d[8];                  //!< Subframe 3 Words 3..10 (SF3D0..SF3D7)

} UBX_AID_EPH_DATA0_SF1D_t, *UBX_AID_EPH_DATA0_SF1D_pt;



typedef struct UBX_AID_EPH_DATA0_s
{
    U4  svid;                     //!< SV ID for which this ephemeris data is (Valid Range: 1 .. 32).
    U4  how;                      //!< Hand-Over Word of first Subframe. This is required if data is sent to the receiver.
    //OPTIONAL: UBX_AID_EPH_DATA0_SF1D_t repeat0[0];

} UBX_AID_EPH_DATA0_t, *UBX_AID_EPH_DATA0_pt;


//#define UBXID_AID_EPH 0x0B31  // already defined, see above


//================================================================
//! AID_HUI_POLL0: Poll Request
/*!
Poll GPS Health, UTC, ionosphere parameters
-

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_HUI
*/
//================================================================

typedef struct UBX_AID_HUI_POLL0_s
{

} UBX_AID_HUI_POLL0_t, *UBX_AID_HUI_POLL0_pt;


#define UBXID_AID_HUI 0x0B02 //!< message id for AID-HUI


//================================================================
//! AID_HUI_DATA1: Input/Output
/*!
GPS Health, UTC and ionosphere parameters
This message contains a health bit mask, UTC time and Klobuchar parameters. For more information on these parameters, see the ICD-GPS-200 documentation.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_HUI
*/
//================================================================

typedef struct UBX_AID_HUI_DATA1_s
{
    X4  health;                   //!< Bitmask, every bit represenst a GPS SV (1-32). If the bit is set the SV is healthy.
    R8  utcA0;                    //!< UTC - parameter A0
    R8  utcA1;                    //!< UTC - parameter A1
    I4  utcTOW;                   //!< UTC - reference time of week
    I2  utcWNT;                   //!< UTC - reference week number
    I2  utcLS;                    //!< UTC - time difference due to leap seconds before event
    I2  utcWNF;                   //!< UTC - week number when next leap second event occurs
    I2  utcDN;                    //!< UTC - day of week when next leap second event occurs
    I2  utcLSF;                   //!< UTC - time difference due to leap seconds after event
    I2  utcSpare;                 //!< UTC - Spare to ensure structure is a multiple of 4 bytes
    R4  klobA0;                   //!< Klobuchar - alpha 0
    R4  klobA1;                   //!< Klobuchar - alpha 1
    R4  klobA2;                   //!< Klobuchar - alpha 2
    R4  klobA3;                   //!< Klobuchar - alpha 3
    R4  klobB0;                   //!< Klobuchar - beta 0
    R4  klobB1;                   //!< Klobuchar - beta 1
    R4  klobB2;                   //!< Klobuchar - beta 2
    R4  klobB3;                   //!< Klobuchar - beta 3
    X4  flags;                    //!< flags

} UBX_AID_HUI_DATA1_t, *UBX_AID_HUI_DATA1_pt;


//! \name Bit Definitions for #UBX_AID_HUI_DATA1_s::flags
//@{
#define UBX_AID_HUI_DATA1_FLAGS_HEALTHVALID_MASK 0x1  //!< Mask for field healthValid in bitmask flags
#define UBX_AID_HUI_DATA1_FLAGS_HEALTHVALID_GET(val)  (U)(((val)&UBX_AID_HUI_DATA1_FLAGS_HEALTHVALID_MASK)>>0)  //!< Get healthValid from bitmask flags
#define UBX_AID_HUI_DATA1_FLAGS_UTCVALID_MASK 0x2  //!< Mask for field utcValid in bitmask flags
#define UBX_AID_HUI_DATA1_FLAGS_UTCVALID_GET(val)  (U)(((val)&UBX_AID_HUI_DATA1_FLAGS_UTCVALID_MASK)>>1)  //!< Get utcValid from bitmask flags
#define UBX_AID_HUI_DATA1_FLAGS_KLOBVALID_MASK 0x4  //!< Mask for field klobValid in bitmask flags
#define UBX_AID_HUI_DATA1_FLAGS_KLOBVALID_GET(val)  (U)(((val)&UBX_AID_HUI_DATA1_FLAGS_KLOBVALID_MASK)>>2)  //!< Get klobValid from bitmask flags

//@}

//#define UBXID_AID_HUI 0x0B02  // already defined, see above


//================================================================
//! AID_INI_POLL0: Poll Request
/*!
Poll GPS Initial Aiding Data
-

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_INI
*/
//================================================================

typedef struct UBX_AID_INI_POLL0_s
{

} UBX_AID_INI_POLL0_t, *UBX_AID_INI_POLL0_pt;


#define UBXID_AID_INI 0x0B01 //!< message id for AID-INI


//================================================================
//! AID_INI_U6: Input/Output
/*!
Aiding position, time, frequency, clock drift
This message contains position, time and clock drift information. The position can be input in either the ECEF X/Y/Z coordinate system or as lat/lon/height. The time can either be input as inexact value via the standard communication interface, suffering from latency depending on the baud rate, or using hardware time synchronization where an accurate time pulse is input on the external interrupts. It is also possible to supply hardware frequency aiding by connecting a continuous signal to an external interrupt.

   \note: All UBX-AID messages are deprecated; use UBX-MGA messages instead

This message's id is #UBXID_AID_INI
*/
//================================================================

typedef struct UBX_AID_INI_U6_s
{
    I4  ecefXOrLat;               //!< WGS84 ECEF X coordinate or latitude, depending on flags below
    I4  ecefYOrLon;               //!< WGS84 ECEF Y coordinate or longitude, depending on flags below
    I4  ecefZOrAlt;               //!< WGS84 ECEF Z coordinate or altitude, depending on flags below
    U4  posAcc;                   //!< Position accuracy (stddev)
    X2  tmCfg;                    //!< Time mark configuration
    U2  wnoOrDate;                //!< Actual week number or yearSince2000/Month (YYMM), depending on flags below
    U4  towOrTime;                //!< Actual time of week or DayOfMonth/Hour/Minute/Second (DDHHMMSS), depending on flags below
    I4  towNs;                    //!< Fractional part of time of week
    U4  tAccMs;                   //!< Milliseconds part of time accuracy
    U4  tAccNs;                   //!< Nanoseconds part of time accuracy
    I4  clkDOrFreq;               //!< Clock drift or frequency, depending on flags below
    U4  clkDAccOrFreqAcc;         //!< Accuracy of clock drift or frequency, depending on flags below
    X4  flags;                    //!< Bitmask with the following flags

} UBX_AID_INI_U6_t, *UBX_AID_INI_U6_pt;


//! \name Bit Definitions for #UBX_AID_INI_U6_s::tmCfg
//@{
#define UBX_AID_INI_U6_TMCFG_FEDGE_MASK 0x02  //!< Mask for field fEdge in bitmask tmCfg
#define UBX_AID_INI_U6_TMCFG_FEDGE_GET(val)  (U)(((val)&UBX_AID_INI_U6_TMCFG_FEDGE_MASK)>>1)  //!< Get fEdge from bitmask tmCfg
#define UBX_AID_INI_U6_TMCFG_TM1_MASK 0x10  //!< Mask for field tm1 in bitmask tmCfg
#define UBX_AID_INI_U6_TMCFG_TM1_GET(val)  (U)(((val)&UBX_AID_INI_U6_TMCFG_TM1_MASK)>>4)  //!< Get tm1 from bitmask tmCfg
#define UBX_AID_INI_U6_TMCFG_F1_MASK 0x40  //!< Mask for field f1 in bitmask tmCfg
#define UBX_AID_INI_U6_TMCFG_F1_GET(val)  (U)(((val)&UBX_AID_INI_U6_TMCFG_F1_MASK)>>6)  //!< Get f1 from bitmask tmCfg

//@}
//! \name Bit Definitions for #UBX_AID_INI_U6_s::flags
//@{
#define UBX_AID_INI_U6_FLAGS_POS_MASK 0x01  //!< Mask for field pos in bitmask flags
#define UBX_AID_INI_U6_FLAGS_POS_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_POS_MASK)>>0)  //!< Get pos from bitmask flags
#define UBX_AID_INI_U6_FLAGS_TIME_MASK 0x02  //!< Mask for field time in bitmask flags
#define UBX_AID_INI_U6_FLAGS_TIME_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_TIME_MASK)>>1)  //!< Get time from bitmask flags
#define UBX_AID_INI_U6_FLAGS_CLOCKD_MASK 0x04  //!< Mask for field clockD in bitmask flags
#define UBX_AID_INI_U6_FLAGS_CLOCKD_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_CLOCKD_MASK)>>2)  //!< Get clockD from bitmask flags
#define UBX_AID_INI_U6_FLAGS_TP_MASK 0x08  //!< Mask for field tp in bitmask flags
#define UBX_AID_INI_U6_FLAGS_TP_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_TP_MASK)>>3)  //!< Get tp from bitmask flags
#define UBX_AID_INI_U6_FLAGS_CLOCKF_MASK 0x10  //!< Mask for field clockF in bitmask flags
#define UBX_AID_INI_U6_FLAGS_CLOCKF_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_CLOCKF_MASK)>>4)  //!< Get clockF from bitmask flags
#define UBX_AID_INI_U6_FLAGS_LLA_MASK 0x20  //!< Mask for field lla in bitmask flags
#define UBX_AID_INI_U6_FLAGS_LLA_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_LLA_MASK)>>5)  //!< Get lla from bitmask flags
#define UBX_AID_INI_U6_FLAGS_ALTINV_MASK 0x40  //!< Mask for field altInv in bitmask flags
#define UBX_AID_INI_U6_FLAGS_ALTINV_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_ALTINV_MASK)>>6)  //!< Get altInv from bitmask flags
#define UBX_AID_INI_U6_FLAGS_PREVTM_MASK 0x80  //!< Mask for field prevTm in bitmask flags
#define UBX_AID_INI_U6_FLAGS_PREVTM_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_PREVTM_MASK)>>7)  //!< Get prevTm from bitmask flags
#define UBX_AID_INI_U6_FLAGS_UTC_MASK 0x400  //!< Mask for field utc in bitmask flags
#define UBX_AID_INI_U6_FLAGS_UTC_GET(val)  (U)(((val)&UBX_AID_INI_U6_FLAGS_UTC_MASK)>>10)  //!< Get utc from bitmask flags

//@}

//#define UBXID_AID_INI 0x0B01  // already defined, see above


//================================================================
//! CFG_ANT_DATA0: Get/Set
/*!
Antenna Control Settings
-


This message's id is #UBXID_CFG_ANT
*/
//================================================================

typedef struct UBX_CFG_ANT_DATA0_s
{
    X2  flags;                    //!< Antenna Flag Mask
    X2  pins;                     //!< Antenna Pin Configuration

} UBX_CFG_ANT_DATA0_t, *UBX_CFG_ANT_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_ANT_DATA0_s::flags
//@{
#define UBX_CFG_ANT_DATA0_FLAGS_SVCS_MASK 0x0001  //!< Mask for field svcs in bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_SVCS_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_FLAGS_SVCS_MASK)>>0)  //!< Get svcs from bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_SCD_MASK 0x0002  //!< Mask for field scd in bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_SCD_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_FLAGS_SCD_MASK)>>1)  //!< Get scd from bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_OCD_MASK 0x0004  //!< Mask for field ocd in bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_OCD_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_FLAGS_OCD_MASK)>>2)  //!< Get ocd from bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_PDWNONSCD_MASK 0x0008  //!< Mask for field pdwnOnSCD in bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_PDWNONSCD_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_FLAGS_PDWNONSCD_MASK)>>3)  //!< Get pdwnOnSCD from bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_RECOVERY_MASK 0x0010  //!< Mask for field recovery in bitmask flags
#define UBX_CFG_ANT_DATA0_FLAGS_RECOVERY_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_FLAGS_RECOVERY_MASK)>>4)  //!< Get recovery from bitmask flags

//@}
//! \name Bit Definitions for #UBX_CFG_ANT_DATA0_s::pins
//@{
#define UBX_CFG_ANT_DATA0_PINS_PINSWITCH_MASK 0x001F  //!< Mask for field pinSwitch in bitmask pins
#define UBX_CFG_ANT_DATA0_PINS_PINSWITCH_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_PINS_PINSWITCH_MASK)>>0)  //!< Get pinSwitch from bitmask pins
#define UBX_CFG_ANT_DATA0_PINS_PINSCD_MASK 0x03E0  //!< Mask for field pinSCD in bitmask pins
#define UBX_CFG_ANT_DATA0_PINS_PINSCD_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_PINS_PINSCD_MASK)>>5)  //!< Get pinSCD from bitmask pins
#define UBX_CFG_ANT_DATA0_PINS_PINOCD_MASK 0x7C00  //!< Mask for field pinOCD in bitmask pins
#define UBX_CFG_ANT_DATA0_PINS_PINOCD_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_PINS_PINOCD_MASK)>>10)  //!< Get pinOCD from bitmask pins
#define UBX_CFG_ANT_DATA0_PINS_RECONFIG_MASK 0x8000  //!< Mask for field reconfig in bitmask pins
#define UBX_CFG_ANT_DATA0_PINS_RECONFIG_GET(val)  (U)(((val)&UBX_CFG_ANT_DATA0_PINS_RECONFIG_MASK)>>15)  //!< Get reconfig from bitmask pins

//@}

#define UBXID_CFG_ANT 0x0613 //!< message id for CFG-ANT


//================================================================
//! CFG_CFG_U5: Command
/*!
Clear, Save and Load configurations
See <r href=\"CFG-CFG-DESC'>Receiver Configuration</r> for a detailed description on how Receiver Configuration should be used. The three masks are made up of individual bits, each bit indicating the sub-section of all configurations on which the corresponding action shall be carried out. The reserved bits in the masks must be set to '0'. For detailed information refer to the <r href=\"orgConfigSect'>Organization of the Configuration Sections</r>. Note that commands can be combined. The sequence of execution is Clear, Save, Load


This message's id is #UBXID_CFG_CFG
*/
//================================================================

//! Repeated Sub-Structure of #UBX_CFG_CFG_U5_t
typedef struct UBX_CFG_CFG_U5_DEVICEMASK_s
{
    X1  deviceMask;               //!< Mask which selects the memory devices for this command.

} UBX_CFG_CFG_U5_DEVICEMASK_t, *UBX_CFG_CFG_U5_DEVICEMASK_pt;

//! \name Bit Definitions for #UBX_CFG_CFG_U5_DEVICEMASK_s::deviceMask
//@{
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVBBR_MASK 0x01  //!< Mask for field devBBR in bitmask deviceMask
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVBBR_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVBBR_MASK)>>0)  //!< Get devBBR from bitmask deviceMask
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVFLASH_MASK 0x02  //!< Mask for field devFlash in bitmask deviceMask
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVFLASH_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVFLASH_MASK)>>1)  //!< Get devFlash from bitmask deviceMask
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVEEPROM_MASK 0x04  //!< Mask for field devEEPROM in bitmask deviceMask
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVEEPROM_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVEEPROM_MASK)>>2)  //!< Get devEEPROM from bitmask deviceMask
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVSPIFLASH_MASK 0x10  //!< Mask for field devSpiFlash in bitmask deviceMask
#define UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVSPIFLASH_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_DEVICEMASK_DEVICEMASK_DEVSPIFLASH_MASK)>>4)  //!< Get devSpiFlash from bitmask deviceMask

//@}


typedef struct UBX_CFG_CFG_U5_s
{
    X4  clearMask;                //!< Mask with configuration sub-sections to clear (i.e. load default configurations to permanent configurations in non-volatile memory)
    X4  saveMask;                 //!< Mask with configuration sub-sections to save (i.e. save current configurations to non-volatile memory), see ID description of clearMask
    X4  loadMask;                 //!< Mask with configuration sub-sections to load (i.e. load permanent configurations from non-volatile memory to current configurations), see ID description of clearMask
    //OPTIONAL: UBX_CFG_CFG_U5_DEVICEMASK_t repeat0[0];

} UBX_CFG_CFG_U5_t, *UBX_CFG_CFG_U5_pt;


//! \name Bit Definitions for #UBX_CFG_CFG_U5_s::clearMask
//@{
#define UBX_CFG_CFG_U5_CLEARMASK_IOPORT_MASK 0x0001  //!< Mask for field ioPort in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_IOPORT_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_IOPORT_MASK)>>0)  //!< Get ioPort from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_MSGCONF_MASK 0x0002  //!< Mask for field msgConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_MSGCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_MSGCONF_MASK)>>1)  //!< Get msgConf from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_INFMSG_MASK 0x0004  //!< Mask for field infMsg in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_INFMSG_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_INFMSG_MASK)>>2)  //!< Get infMsg from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_NAVCONF_MASK 0x0008  //!< Mask for field navConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_NAVCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_NAVCONF_MASK)>>3)  //!< Get navConf from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_RXMCONF_MASK 0x0010  //!< Mask for field rxmConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_RXMCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_RXMCONF_MASK)>>4)  //!< Get rxmConf from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_SENCONF_MASK 0x0100  //!< Mask for field senConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_SENCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_SENCONF_MASK)>>8)  //!< Get senConf from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_RINVCONF_MASK 0x0200  //!< Mask for field rinvConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_RINVCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_RINVCONF_MASK)>>9)  //!< Get rinvConf from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_ANTCONF_MASK 0x0400  //!< Mask for field antConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_ANTCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_ANTCONF_MASK)>>10)  //!< Get antConf from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_LOGCONF_MASK 0x0800  //!< Mask for field logConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_LOGCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_LOGCONF_MASK)>>11)  //!< Get logConf from bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_FTSCONF_MASK 0x1000  //!< Mask for field ftsConf in bitmask clearMask
#define UBX_CFG_CFG_U5_CLEARMASK_FTSCONF_GET(val)  (U)(((val)&UBX_CFG_CFG_U5_CLEARMASK_FTSCONF_MASK)>>12)  //!< Get ftsConf from bitmask clearMask

//@}

#define UBXID_CFG_CFG 0x0609 //!< message id for CFG-CFG


//================================================================
//! CFG_DAT_SETCUSTOM: Set
/*!
Set User-defined Datum.
For more information see the <r href=\"CFG-NAV5-DESC-DATUM'>description of Geodetic Systems and Frames</r>.


This message's id is #UBXID_CFG_DAT
*/
//================================================================

typedef struct UBX_CFG_DAT_SETCUSTOM_s
{
    R8  majA;                     //!< Semi-major Axis ( accepted range = 6,300,000.0 to 6,500,000.0 meters ).
    R8  flat;                     //!< 1.0 / Flattening ( accepted range is 0.0 to 500.0 ).
    R4  dX;                       //!< X Axis shift at the origin ( accepted range is +/- 5000.0 meters ).
    R4  dY;                       //!< Y Axis shift at the origin ( accepted range is +/- 5000.0 meters ).
    R4  dZ;                       //!< Z Axis shift at the origin ( accepted range is +/- 5000.0 meters ).
    R4  rotX;                     //!< Rotation about the X Axis ( accepted range is +/- 20.0 milli-arc seconds ).
    R4  rotY;                     //!< Rotation about the Y Axis ( accepted range is +/- 20.0 milli-arc seconds ).
    R4  rotZ;                     //!< Rotation about the Z Axis ( accepted range is +/- 20.0 milli-arc seconds ).
    R4  scale;                    //!< Scale change ( accepted range is 0.0 to 50.0 parts per million ).

} UBX_CFG_DAT_SETCUSTOM_t, *UBX_CFG_DAT_SETCUSTOM_pt;


#define UBXID_CFG_DAT 0x0606 //!< message id for CFG-DAT


//================================================================
//! CFG_DAT_GETCURRENT: Get
/*!
The currently defined Datum
Returns the parameters of the currently defined datum. If no user-defined datum has been set, this will default to WGS84.


This message's id is #UBXID_CFG_DAT
*/
//================================================================

typedef struct UBX_CFG_DAT_GETCURRENT_s
{
    U2  datumNum;                 //!< Datum Number: 0 = WGS84, -1 = user-defined
    CH  datumName[6];             //!< ASCII String: WGS84 or USER
    R8  majA;                     //!< Semi-major Axis ( accepted range = 6,300,000.0 to 6,500,000.0 meters ).
    R8  flat;                     //!< 1.0 / Flattening ( accepted range is 0.0 to 500.0 ).
    R4  dX;                       //!< X Axis shift at the origin ( accepted range is +/- 5000.0 meters ).
    R4  dY;                       //!< Y Axis shift at the origin ( accepted range is +/- 5000.0 meters ).
    R4  dZ;                       //!< Z Axis shift at the origin ( accepted range is +/- 5000.0 meters ).
    R4  rotX;                     //!< Rotation about the X Axis ( accepted range is +/- 20.0 milli-arc seconds ).
    R4  rotY;                     //!< Rotation about the Y Axis ( accepted range is +/- 20.0 milli-arc seconds ).
    R4  rotZ;                     //!< Rotation about the Z Axis ( accepted range is +/- 20.0 milli-arc seconds ).
    R4  scale;                    //!< Scale change ( accepted range is 0.0 to 50.0 parts per million ).

} UBX_CFG_DAT_GETCURRENT_t, *UBX_CFG_DAT_GETCURRENT_pt;


//#define UBXID_CFG_DAT 0x0606  // already defined, see above


//================================================================
//! CFG_DOSC_DATA0: Get/Set
/*!
Disciplined oscillator configuration
This message allows the characteristics of the internal or external oscillator to be described to the receiver.
The gainVco and gainUncertainty parameters are normally set using the <r href=\"FTS-calib'>calibration process</r> initiated using <rc href=\"UBX-TIM-VCOCAL'>UBX-TIM-VCOCAL</rc>.
The behavior of the system can be badly affected by setting the wrong values, so customers are advised to only change these parameters with care.


This message's id is #UBXID_CFG_DOSC
*/
//================================================================

//! Optional Sub-Structure of #UBX_CFG_DOSC_DATA0_t
typedef struct UBX_CFG_DOSC_DATA0_OSCID_s
{
    U1  oscId;                    //!< Id of oscillator.
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  flags;                    //!< flags
    U4  freq;                     //!< Nominal frequency of source
    I4  phaseOffset;              //!< Intended phase offset of the oscillator relative to the leading edge of the time pulse
    U4  withTemp;                 //!< Oscillator stability limit over operating temperature range (must be > 0)
    U4  withAge;                  //!< Oscillator stability with age (must be > 0)
    U2  timeToTemp;               //!< The minimum time that it could take for a temperature variation to move the oscillator frequency by 'withTemp' (must be > 0)
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  gainVco;                  //!< Oscillator control gain/slope; change of frequency per unit change in raw control change
    U1  gainUncertainty;          //!< Relative uncertainty (1 standard deviation) of oscillator control gain/slope
    U1  reserved4[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_DOSC_DATA0_OSCID_t, *UBX_CFG_DOSC_DATA0_OSCID_pt;

//! \name Bit Definitions for #UBX_CFG_DOSC_DATA0_OSCID_s::flags
//@{
#define UBX_CFG_DOSC_DATA0_OSCID_FLAGS_ISCALIBRATED_MASK 0x0001  //!< Mask for field isCalibrated in bitmask flags
#define UBX_CFG_DOSC_DATA0_OSCID_FLAGS_ISCALIBRATED_GET(val)  (U)(((val)&UBX_CFG_DOSC_DATA0_OSCID_FLAGS_ISCALIBRATED_MASK)>>0)  //!< Get isCalibrated from bitmask flags
#define UBX_CFG_DOSC_DATA0_OSCID_FLAGS_CONTROLIF_MASK 0x001E  //!< Mask for field controlIf in bitmask flags
#define UBX_CFG_DOSC_DATA0_OSCID_FLAGS_CONTROLIF_GET(val)  (U)(((val)&UBX_CFG_DOSC_DATA0_OSCID_FLAGS_CONTROLIF_MASK)>>1)  //!< Get controlIf from bitmask flags

//@}


typedef struct UBX_CFG_DOSC_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  numOsc;                   //!< Number of oscillators to configure (affects length of this message)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_CFG_DOSC_DATA0_OSCID_t repeat0[numOsc];

} UBX_CFG_DOSC_DATA0_t, *UBX_CFG_DOSC_DATA0_pt;


#define UBXID_CFG_DOSC 0x0661 //!< message id for CFG-DOSC


//================================================================
//! CFG_DYNSEED_DATA0: Set
/*!
Programming the dynamic seed for the host interface signature
The message can be used to program the dynamic seed for the host interface signature. If successfully configured, the message will answer with ACK, otherwise with NAK. Before the first programming, it is assumed that the dynamic seed is all '0'.


This message's id is #UBXID_CFG_DYNSEED
*/
//================================================================

typedef struct UBX_CFG_DYNSEED_DATA0_s
{
    U1  version;                  //!< Message version (0x01 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  seedHi;                   //!< high word of dynamic seed
    U4  seedLo;                   //!< low word of dynamic seed

} UBX_CFG_DYNSEED_DATA0_t, *UBX_CFG_DYNSEED_DATA0_pt;


#define UBXID_CFG_DYNSEED 0x0685 //!< message id for CFG-DYNSEED


//================================================================
//! CFG_ESRC_DATA0: Get/Set
/*!
External synchronization source configuration
External time or frequency source configuration. The stability of time and frequency sources is described using different fields, see sourceType field documentation.


This message's id is #UBXID_CFG_ESRC
*/
//================================================================

//! Optional Sub-Structure of #UBX_CFG_ESRC_DATA0_t
typedef struct UBX_CFG_ESRC_DATA0_EXTINT_s
{
    U1  extInt;                   //!< EXTINT index of this source (0 for EXTINT0 and 1 for EXTINT1)
    U1  sourceType;               //!< Source type:
    X2  flags;                    //!< Flags
    U4  freq;                     //!< Nominal frequency of source
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  withTemp;                 //!< Oscillator stability limit over operating temperature range (must be > 0)
    U4  withAge;                  //!< Oscillator stability with age (must be > 0)
    U2  timeToTemp;               //!< The minimum time that it could take for a temperature variation to move the oscillator frequency by 'withTemp' (must be > 0)
    U2  maxDevLifeTime;           //!< Maximum frequency deviation during lifetime (must be > 0)
    I4  offset;                   //!< Phase offset of signal
    U4  offsetUncertainty;        //!< Uncertainty of phase offset (one standard deviation)
    U4  jitter;                   //!< Phase jitter (must be > 0)

} UBX_CFG_ESRC_DATA0_EXTINT_t, *UBX_CFG_ESRC_DATA0_EXTINT_pt;

//! \name Bit Definitions for #UBX_CFG_ESRC_DATA0_EXTINT_s::flags
//@{
#define UBX_CFG_ESRC_DATA0_EXTINT_FLAGS_POLARITY_MASK 0x01  //!< Mask for field polarity in bitmask flags
#define UBX_CFG_ESRC_DATA0_EXTINT_FLAGS_POLARITY_GET(val)  (U)(((val)&UBX_CFG_ESRC_DATA0_EXTINT_FLAGS_POLARITY_MASK)>>0)  //!< Get polarity from bitmask flags
#define UBX_CFG_ESRC_DATA0_EXTINT_FLAGS_GNSSUTC_MASK 0x02  //!< Mask for field gnssUtc in bitmask flags
#define UBX_CFG_ESRC_DATA0_EXTINT_FLAGS_GNSSUTC_GET(val)  (U)(((val)&UBX_CFG_ESRC_DATA0_EXTINT_FLAGS_GNSSUTC_MASK)>>1)  //!< Get gnssUtc from bitmask flags

//@}


typedef struct UBX_CFG_ESRC_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  numSources;               //!< Number of sources (affects length of this message)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_CFG_ESRC_DATA0_EXTINT_t repeat0[numSources];

} UBX_CFG_ESRC_DATA0_t, *UBX_CFG_ESRC_DATA0_pt;


#define UBXID_CFG_ESRC 0x0660 //!< message id for CFG-ESRC


//================================================================
//! CFG_FIXSEED_DATA0: Set
/*!
Programming the fixed seed for host interface signature
The message can be used to program the fixed seed for the host interface signature. Moreover it will configure the set of messages that will be signed (min. 1, max. 10). If the class ID of the message is 0 the configuration is ignored for that message. If successfully configured, the message will answer with ACK, otherwise with NAK.


This message's id is #UBXID_CFG_FIXSEED
*/
//================================================================

//! Optional Sub-Structure of #UBX_CFG_FIXSEED_DATA0_t
typedef struct UBX_CFG_FIXSEED_DATA0_CLASSID_s
{
    U1  classId;                  //!< Class ID on the message
    U1  msgId;                    //!< Message ID on the message

} UBX_CFG_FIXSEED_DATA0_CLASSID_t, *UBX_CFG_FIXSEED_DATA0_CLASSID_pt;



typedef struct UBX_CFG_FIXSEED_DATA0_s
{
    U1  version;                  //!< Message version (0x02 for this version)
    U1  length;                   //!< Number of registered messages (min. 1, max. 10)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  seedHi;                   //!< high word of fixed seed
    U4  seedLo;                   //!< low word of fixed seed
    //REPEAT: UBX_CFG_FIXSEED_DATA0_CLASSID_t repeat0[length];

} UBX_CFG_FIXSEED_DATA0_t, *UBX_CFG_FIXSEED_DATA0_pt;


#define UBXID_CFG_FIXSEED 0x0684 //!< message id for CFG-FIXSEED


//================================================================
//! CFG_GEOFENCE_DATA0: Get/Set
/*!
Geofencing configuration
Gets or sets the geofencing configuration
See the <r href=\"GEOFENCE-DESC'>Geofencing description</r> for feature details.
If the receiver is sent a valid new configuration, it will respond with a <rc href=\"UBX-ACK-ACK'>UBX-ACK-ACK</rc> message and immediately change to the new configuration. Otherwise the receiver will reject the request, by issuing a <rc href=\"UBX-ACK-NAK'>UBX-ACK-NAK</rc> and continuing operation with the previous configuration.
Note that the acknowledge message does not indicate whether the PIO configuration has been successfully applied (pin assigned), it only indicates the successful configuration of the feature. The configured PIO must be previously unoccupied for successful assignment.


This message's id is #UBXID_CFG_GEOFENCE
*/
//================================================================

//! Optional Sub-Structure of #UBX_CFG_GEOFENCE_DATA0_t
typedef struct UBX_CFG_GEOFENCE_DATA0_LAT_s
{
    I4  lat;                      //!< Latitude of the geofence circle center
    I4  lon;                      //!< Longitude of the geofence circle center
    U4  radius;                   //!< Radius of the geofence circle

} UBX_CFG_GEOFENCE_DATA0_LAT_t, *UBX_CFG_GEOFENCE_DATA0_LAT_pt;



typedef struct UBX_CFG_GEOFENCE_DATA0_s
{
    U1  version;                  //!< Message version (=0x00 for this version)
    U1  numFences;                //!< Number of geofences contained in this message. Note that the receiver can only store a limited number of geofences (currently 4).
    U1  confLvl;                  //!< Required confidence level for state evaluation. This value times the position's standard deviation (sigma) defines the confidence band. 0=no confidence required, 1=68%, 2=95%, 3=99.7% etc.
    U1  reserved1[1];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  pioEnabled;               //!< 1 = Enable PIO combined fence state output, 0 = disable
    U1  pinPolarity;              //!< PIO pin polarity. 0 = Low means inside, 1 = Low means outside. Unknown state is always high.
    U1  pin;                      //!< PIO pin number
    U1  reserved2[1];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_CFG_GEOFENCE_DATA0_LAT_t repeat0[numFences];

} UBX_CFG_GEOFENCE_DATA0_t, *UBX_CFG_GEOFENCE_DATA0_pt;


#define UBXID_CFG_GEOFENCE 0x0669 //!< message id for CFG-GEOFENCE


//================================================================
//! CFG_GNSS_DATA0: Get/Set
/*!
GNSS system configuration
Gets or sets the GNSS system channel sharing configuration.
If the receiver is sent a valid new configuration, it will respond with a <rc href=\"UBX-ACK-ACK'>UBX-ACK-ACK</rc> message and immediately change to the new configuration. Otherwise the receiver will reject the request, by issuing a <rc href=\"UBX-ACK-NAK'>UBX-ACK-NAK</rc> and continuing operation with the previous configuration.
It is necessary for at least one <r href=\"DESC-MAJOR-GNSS'>major GNSS</r> to be enabled, after applying the new configuration to the current one. It is also required that at least 4 tracking channels are available to each enabled major GNSS, i.e. <c>maxTrkCh</c> must have a minimum value of 4 for each enabled major GNSS. The number of tracking channels in use must not exceed the number of tracking channels available in hardware, and the sum of all reserved tracking channels needs to be less than or equal to the number of tracking channels in use.
Polling this message returns the configuration of all supported GNSS, whether enabled or not; it may also include GNSS unsupported by the particular product, but in such cases the enable flag will always be unset.
See section <r href=\"CFG-GNSS-DESC'>GNSS Configuration</r> for a discussion of the use of this message and section <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r> for a description of the GNSS IDs available.
Configuration specific to the GNSS system can be done via other messages (e.g. <rc href=\"UBX-CFG-SBAS'>UBX-CFG-SBAS</rc>).


This message's id is #UBXID_CFG_GNSS
*/
//================================================================

//! Optional Sub-Structure of #UBX_CFG_GNSS_DATA0_t
typedef struct UBX_CFG_GNSS_DATA0_GNSSID_s
{
    U1  gnssId;                   //!< System identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  resTrkCh;                 //!< Number of reserved (minimum) tracking channels for this system
    U1  maxTrkCh;                 //!< Maximum number of tracking channels used for this system. Must be > 0, >= resTrkChn, <= numTrkChUse and <= maximum number of tracking channels supported for this system.
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X4  flags;                    //!< bitfield of flags. At least one signal must be configured in every enabled system.

} UBX_CFG_GNSS_DATA0_GNSSID_t, *UBX_CFG_GNSS_DATA0_GNSSID_pt;

//! \name Bit Definitions for #UBX_CFG_GNSS_DATA0_GNSSID_s::flags
//@{
#define UBX_CFG_GNSS_DATA0_GNSSID_FLAGS_ENABLE_MASK 0x00000001  //!< Mask for field enable in bitmask flags
#define UBX_CFG_GNSS_DATA0_GNSSID_FLAGS_ENABLE_GET(val)  (U)(((val)&UBX_CFG_GNSS_DATA0_GNSSID_FLAGS_ENABLE_MASK)>>0)  //!< Get enable from bitmask flags
#define UBX_CFG_GNSS_DATA0_GNSSID_FLAGS_SIGCFGMASK_MASK 0x00FF0000  //!< Mask for field sigCfgMask in bitmask flags
#define UBX_CFG_GNSS_DATA0_GNSSID_FLAGS_SIGCFGMASK_GET(val)  (U)(((val)&UBX_CFG_GNSS_DATA0_GNSSID_FLAGS_SIGCFGMASK_MASK)>>16)  //!< Get sigCfgMask from bitmask flags

//@}


typedef struct UBX_CFG_GNSS_DATA0_s
{
    U1  msgVer;                   //!< Message version (=0 for this version)
    U1  numTrkChHw;               //!< Number of tracking channels available in hardware (read only)
    U1  numTrkChUse;              //!< Number of tracking channels to use. Must be > 0, <= numTrkChHw. If 0xFF, then number of tracking channels to use will be set to numTrkChHw.
    U1  numConfigBlocks;          //!< Number of configuration blocks following
    //REPEAT: UBX_CFG_GNSS_DATA0_GNSSID_t repeat0[numConfigBlocks];

} UBX_CFG_GNSS_DATA0_t, *UBX_CFG_GNSS_DATA0_pt;


#define UBXID_CFG_GNSS 0x063E //!< message id for CFG-GNSS


//================================================================
//! CFG_HNR_DATA0: Get/Set
/*!
High Navigation Rate Settings
The u-blox receivers support high rates of navigation update up to 20 Hz. The navigation solution output (<rc href=\"UBX-NAV-HNR'>NAV-HNR</rc>) will not be aligned to the top of a second.
* The update rate has a direct influence on the power consumption. The more fixes that are required, the more CPU power and communication resources are required.
* For most applications a 1 Hz update rate would be sufficient.


This message's id is #UBXID_CFG_HNR
*/
//================================================================

typedef struct UBX_CFG_HNR_DATA0_s
{
    U1  highNavRate;              //!< Rate of navigation solution output
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_HNR_DATA0_t, *UBX_CFG_HNR_DATA0_pt;


#define UBXID_CFG_HNR 0x065C //!< message id for CFG-HNR


//================================================================
//! CFG_INF_POLLID: Poll Request
/*!
Poll configuration for one protocol
-


This message's id is #UBXID_CFG_INF
*/
//================================================================

typedef struct UBX_CFG_INF_POLLID_s
{
    U1  protocolID;               //!< Protocol Identifier, identifying the output protocol for this Poll Request. The following are valid Protocol Identifiers:

} UBX_CFG_INF_POLLID_t, *UBX_CFG_INF_POLLID_pt;


#define UBXID_CFG_INF 0x0602 //!< message id for CFG-INF


//================================================================
//! CFG_INF_DATA1: Get/Set
/*!
Information message configuration
The value of infMsgMask[x] below are that each bit represents one of the INF class messages (Bit 0 for ERROR, Bit 1 for WARNING and so on.). For a complete list, see the <rc href=\"UBX-INF'>Message Class INF</rc>. Several configurations can be concatenated to one input message. In this case the payload length can be a multiple of the normal length. Output messages from the module contain only one configuration unit. Note that I/O Ports 1 and 2 correspond to serial ports 1 and 2. I/O port 0 is DDC. I/O port 3 is USB. I/O port 4 is SPI. I/O port 5 is reserved for future use.


This message's id is #UBXID_CFG_INF
*/
//================================================================

//! Optional Sub-Structure of #UBX_CFG_INF_DATA1_t
typedef struct UBX_CFG_INF_DATA1_PROTOCOLID_s
{
    U1  protocolID;               //!< Protocol Identifier, identifying for which protocol the configuration is set/get. The following are valid Protocol Identifiers:
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X1  infMsgMask[6];            //!< A bit mask, saying which information messages are enabled on each I/O port

} UBX_CFG_INF_DATA1_PROTOCOLID_t, *UBX_CFG_INF_DATA1_PROTOCOLID_pt;

//! \name Bit Definitions for #UBX_CFG_INF_DATA1_PROTOCOLID_s::infMsgMask
//@{
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_ERROR_MASK 0x01  //!< Mask for field ERROR in bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_ERROR_GET(val)  (U)(((val)&UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_ERROR_MASK)>>0)  //!< Get ERROR from bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_WARNING_MASK 0x02  //!< Mask for field WARNING in bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_WARNING_GET(val)  (U)(((val)&UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_WARNING_MASK)>>1)  //!< Get WARNING from bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_NOTICE_MASK 0x04  //!< Mask for field NOTICE in bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_NOTICE_GET(val)  (U)(((val)&UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_NOTICE_MASK)>>2)  //!< Get NOTICE from bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_TEST_MASK 0x08  //!< Mask for field TEST in bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_TEST_GET(val)  (U)(((val)&UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_TEST_MASK)>>3)  //!< Get TEST from bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_DEBUG_MASK 0x10  //!< Mask for field DEBUG in bitmask infMsgMask
#define UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_DEBUG_GET(val)  (U)(((val)&UBX_CFG_INF_DATA1_PROTOCOLID_INFMSGMASK_DEBUG_MASK)>>4)  //!< Get DEBUG from bitmask infMsgMask

//@}


typedef struct UBX_CFG_INF_DATA1_s
{
    //REPEAT: UBX_CFG_INF_DATA1_PROTOCOLID_t repeat0[N];

} UBX_CFG_INF_DATA1_t, *UBX_CFG_INF_DATA1_pt;


//#define UBXID_CFG_INF 0x0602  // already defined, see above


//================================================================
//! CFG_ITFM_DATA0: Get/Set
/*!
Jamming/Interference Monitor configuration
Configuration of Jamming/Interference monitor.


This message's id is #UBXID_CFG_ITFM
*/
//================================================================

typedef struct UBX_CFG_ITFM_DATA0_s
{
    X4  config;                   //!< interference config word.
    X4  config2;                  //!< extra settings for jamming/interference monitor

} UBX_CFG_ITFM_DATA0_t, *UBX_CFG_ITFM_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_ITFM_DATA0_s::config
//@{
#define UBX_CFG_ITFM_DATA0_CONFIG_BBTHRESHOLD_MASK 0x0000000F  //!< Mask for field bbThreshold in bitmask config
#define UBX_CFG_ITFM_DATA0_CONFIG_BBTHRESHOLD_GET(val)  (U)(((val)&UBX_CFG_ITFM_DATA0_CONFIG_BBTHRESHOLD_MASK)>>0)  //!< Get bbThreshold from bitmask config
#define UBX_CFG_ITFM_DATA0_CONFIG_CWTHRESHOLD_MASK 0x000001F0  //!< Mask for field cwThreshold in bitmask config
#define UBX_CFG_ITFM_DATA0_CONFIG_CWTHRESHOLD_GET(val)  (U)(((val)&UBX_CFG_ITFM_DATA0_CONFIG_CWTHRESHOLD_MASK)>>4)  //!< Get cwThreshold from bitmask config
#define UBX_CFG_ITFM_DATA0_CONFIG_ALGORITHMBITS_MASK 0x7FFFFE00  //!< Mask for field algorithmBits in bitmask config
#define UBX_CFG_ITFM_DATA0_CONFIG_ALGORITHMBITS_GET(val)  (U)(((val)&UBX_CFG_ITFM_DATA0_CONFIG_ALGORITHMBITS_MASK)>>9)  //!< Get algorithmBits from bitmask config
#define UBX_CFG_ITFM_DATA0_CONFIG_ENABLE_MASK 0x80000000  //!< Mask for field enable in bitmask config
#define UBX_CFG_ITFM_DATA0_CONFIG_ENABLE_GET(val)  (U)(((val)&UBX_CFG_ITFM_DATA0_CONFIG_ENABLE_MASK)>>31)  //!< Get enable from bitmask config

//@}
//! \name Bit Definitions for #UBX_CFG_ITFM_DATA0_s::config2
//@{
#define UBX_CFG_ITFM_DATA0_CONFIG2_GENERALBITS_MASK 0x00000FFF  //!< Mask for field generalBits in bitmask config2
#define UBX_CFG_ITFM_DATA0_CONFIG2_GENERALBITS_GET(val)  (U)(((val)&UBX_CFG_ITFM_DATA0_CONFIG2_GENERALBITS_MASK)>>0)  //!< Get generalBits from bitmask config2
#define UBX_CFG_ITFM_DATA0_CONFIG2_ANTSETTING_MASK 0x00003000  //!< Mask for field antSetting in bitmask config2
#define UBX_CFG_ITFM_DATA0_CONFIG2_ANTSETTING_GET(val)  (U)(((val)&UBX_CFG_ITFM_DATA0_CONFIG2_ANTSETTING_MASK)>>12)  //!< Get antSetting from bitmask config2
#define UBX_CFG_ITFM_DATA0_CONFIG2_ENABLE2_MASK 0x00004000  //!< Mask for field enable2 in bitmask config2
#define UBX_CFG_ITFM_DATA0_CONFIG2_ENABLE2_GET(val)  (U)(((val)&UBX_CFG_ITFM_DATA0_CONFIG2_ENABLE2_MASK)>>14)  //!< Get enable2 from bitmask config2

//@}

#define UBXID_CFG_ITFM 0x0639 //!< message id for CFG-ITFM


//================================================================
//! CFG_LOGFILTER_DATA0: Get/Set
/*!
Data Logger Configuration
This message can be used to configure the data logger, i.e. to enable/disable the log recording and to get/set the position entry filter settings.
Position entries can be filtered based on time difference, position difference or current speed thresholds. Position and speed filtering also have a minimum time interval. A position is logged if any of the thresholds are exceeded. If a threshold is set to zero it is ignored. The maximum rate of position logging is 1Hz.
The filter settings will be configured to the provided values only if the 'applyAllFilterSettings' flag is set. This allows the recording to be enabled/disabled independently of configuring the filter settings.
It is supported to configure the data logger in the absence of a logging file. By doing so, once the logging file is created, the data logger configuration will take effect immediately and logging recording and filtering will activate according to the configuration.


This message's id is #UBXID_CFG_LOGFILTER
*/
//================================================================

typedef struct UBX_CFG_LOGFILTER_DATA0_s
{
    U1  version;                  //!< The version of this message. Set to 1
    X1  flags;                    //!< Flags
    U2  minInterval;              //!< Minimum time interval between logged positions (0 = not set). <b>This is only applied in combination with the speed and/or position thresholds</b>
    U2  timeThreshold;            //!< If the time difference is greater than the threshold then the position is logged (0 = not set).
    U2  speedThreshold;           //!< If the current speed is greater than the threshold then the position is logged (0 = not set). minInterval also applies
    U4  positionThreshold;        //!< If the 3D position difference is greater than the threshold then the position is logged (0 = not set). minInterval also applies

} UBX_CFG_LOGFILTER_DATA0_t, *UBX_CFG_LOGFILTER_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_LOGFILTER_DATA0_s::flags
//@{
#define UBX_CFG_LOGFILTER_DATA0_FLAGS_RECORDENABLED_MASK 0x01  //!< Mask for field recordEnabled in bitmask flags
#define UBX_CFG_LOGFILTER_DATA0_FLAGS_RECORDENABLED_GET(val)  (U)(((val)&UBX_CFG_LOGFILTER_DATA0_FLAGS_RECORDENABLED_MASK)>>0)  //!< Get recordEnabled from bitmask flags
#define UBX_CFG_LOGFILTER_DATA0_FLAGS_PSMONCEPERWAKUPENABLED_MASK 0x02  //!< Mask for field psmOncePerWakupEnabled in bitmask flags
#define UBX_CFG_LOGFILTER_DATA0_FLAGS_PSMONCEPERWAKUPENABLED_GET(val)  (U)(((val)&UBX_CFG_LOGFILTER_DATA0_FLAGS_PSMONCEPERWAKUPENABLED_MASK)>>1)  //!< Get psmOncePerWakupEnabled from bitmask flags
#define UBX_CFG_LOGFILTER_DATA0_FLAGS_APPLYALLFILTERSETTINGS_MASK 0x04  //!< Mask for field applyAllFilterSettings in bitmask flags
#define UBX_CFG_LOGFILTER_DATA0_FLAGS_APPLYALLFILTERSETTINGS_GET(val)  (U)(((val)&UBX_CFG_LOGFILTER_DATA0_FLAGS_APPLYALLFILTERSETTINGS_MASK)>>2)  //!< Get applyAllFilterSettings from bitmask flags

//@}

#define UBXID_CFG_LOGFILTER 0x0647 //!< message id for CFG-LOGFILTER


//================================================================
//! CFG_MSG_POLLID: Poll Request
/*!
Poll a message configuration
-


This message's id is #UBXID_CFG_MSG
*/
//================================================================

typedef struct UBX_CFG_MSG_POLLID_s
{
    U1  msgClass;                 //!< Message Class
    U1  msgID;                    //!< Message Identifier

} UBX_CFG_MSG_POLLID_t, *UBX_CFG_MSG_POLLID_pt;


#define UBXID_CFG_MSG 0x0601 //!< message id for CFG-MSG


//================================================================
//! CFG_MSG_SETU5: Get/Set
/*!
Set Message Rate(s)
Set/Get message rate configuration (s) to/from the receiver. See also section <r href=\"CFG-MSG-DESC'>How to change between protocols</r>.
* Send rate is relative to the event a message is registered on. For example, if the rate of a navigation message is set to 2, the message is sent every second navigation solution. For configuring NMEA messages, the section <r href=\"NMEA_ids'>NMEA Messages Overview</r> describes Class and Identifier numbers used.


This message's id is #UBXID_CFG_MSG
*/
//================================================================

typedef struct UBX_CFG_MSG_SETU5_s
{
    U1  msgClass;                 //!< Message Class
    U1  msgID;                    //!< Message Identifier
    U1  rate[6];                  //!< Send rate on I/O Port (6 Ports)

} UBX_CFG_MSG_SETU5_t, *UBX_CFG_MSG_SETU5_pt;


//#define UBXID_CFG_MSG 0x0601  // already defined, see above


//================================================================
//! CFG_MSG_SETCURRENT: Get/Set
/*!
Set Message Rate
Set message rate configuration for the current port. See also section <r href=\"CFG-MSG-DESC'>How to change between protocols</r>.


This message's id is #UBXID_CFG_MSG
*/
//================================================================

typedef struct UBX_CFG_MSG_SETCURRENT_s
{
    U1  msgClass;                 //!< Message Class
    U1  msgID;                    //!< Message Identifier
    U1  rate;                     //!< Send rate on current Port

} UBX_CFG_MSG_SETCURRENT_t, *UBX_CFG_MSG_SETCURRENT_pt;


//#define UBXID_CFG_MSG 0x0601  // already defined, see above


//================================================================
//! CFG_NAV5_DATA0: Get/Set
/*!
Navigation Engine Settings
See the <r href=\"CFG-NAV5-DESC'>Navigation Configuration Settings Description</r> for a detailed description of how these settings affect receiver operation.


This message's id is #UBXID_CFG_NAV5
*/
//================================================================

typedef struct UBX_CFG_NAV5_DATA0_s
{
    X2  mask;                     //!< Parameters Bitmask. Only the masked parameters will be applied.
    U1  dynModel;                 //!< Dynamic platform model:
    U1  fixMode;                  //!< Position Fixing Mode:
    I4  fixedAlt;                 //!< Fixed altitude (mean sea level) for 2D fix mode.
    U4  fixedAltVar;              //!< Fixed altitude variance for 2D mode.
    I1  minElev;                  //!< Minimum Elevation for a GNSS satellite to be used in NAV
    U1  drLimit;                  //!< Reserved
    U2  pDop;                     //!< Position DOP Mask to use
    U2  tDop;                     //!< Time DOP Mask to use
    U2  pAcc;                     //!< Position Accuracy Mask
    U2  tAcc;                     //!< Time Accuracy Mask
    U1  staticHoldThresh;         //!< Static hold threshold
    U1  dgpsTimeOut;              //!< DGPS timeout.
    U1  cnoThreshNumSVs;          //!< Number of satellites required to have C/N0 above cnoThresh for a fix to be attempted
    U1  cnoThresh;                //!< C/N0 threshold for deciding whether to attempt a fix
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  staticHoldMaxDist;        //!< Static hold distance threshold (before quitting static hold)
    U1  utcStandard;              //!< UTC standard to be used:
    U1  reserved2[5];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_NAV5_DATA0_t, *UBX_CFG_NAV5_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_NAV5_DATA0_s::mask
//@{
#define UBX_CFG_NAV5_DATA0_MASK_DYN_MASK 0x0001  //!< Mask for field dyn in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_DYN_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_DYN_MASK)>>0)  //!< Get dyn from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_MINEL_MASK 0x0002  //!< Mask for field minEl in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_MINEL_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_MINEL_MASK)>>1)  //!< Get minEl from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_POSFIXMODE_MASK 0x0004  //!< Mask for field posFixMode in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_POSFIXMODE_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_POSFIXMODE_MASK)>>2)  //!< Get posFixMode from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_DRLIM_MASK 0x0008  //!< Mask for field drLim in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_DRLIM_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_DRLIM_MASK)>>3)  //!< Get drLim from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_POSMASK_MASK 0x0010  //!< Mask for field posMask in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_POSMASK_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_POSMASK_MASK)>>4)  //!< Get posMask from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_TIMEMASK_MASK 0x0020  //!< Mask for field timeMask in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_TIMEMASK_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_TIMEMASK_MASK)>>5)  //!< Get timeMask from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_STATICHOLDMASK_MASK 0x0040  //!< Mask for field staticHoldMask in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_STATICHOLDMASK_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_STATICHOLDMASK_MASK)>>6)  //!< Get staticHoldMask from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_DGPSMASK_MASK 0x0080  //!< Mask for field dgpsMask in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_DGPSMASK_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_DGPSMASK_MASK)>>7)  //!< Get dgpsMask from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_CNOTHRESHOLD_MASK 0x0100  //!< Mask for field cnoThreshold in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_CNOTHRESHOLD_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_CNOTHRESHOLD_MASK)>>8)  //!< Get cnoThreshold from bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_UTC_MASK 0x0400  //!< Mask for field utc in bitmask mask
#define UBX_CFG_NAV5_DATA0_MASK_UTC_GET(val)  (U)(((val)&UBX_CFG_NAV5_DATA0_MASK_UTC_MASK)>>10)  //!< Get utc from bitmask mask

//@}

#define UBXID_CFG_NAV5 0x0624 //!< message id for CFG-NAV5


//================================================================
//! CFG_NAVX5_DATA0: Get/Set
/*!
Navigation Engine Expert Settings
-


This message's id is #UBXID_CFG_NAVX5
*/
//================================================================

typedef struct UBX_CFG_NAVX5_DATA0_s
{
    U2  version;                  //!< Message version (0 for this version)
    X2  mask1;                    //!< First parameters bitmask. Only the flagged parameters will be applied, unused bits must be set to 0.
    X4  mask2;                    //!< Second parameters bitmask. Only the flagged parameters will be applied, unused bits must be set to 0.
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  minSVs;                   //!< Minimum number of satellites for navigation
    U1  maxSVs;                   //!< Maximum number of satellites for navigation
    U1  minCNO;                   //!< Minimum satellite signal level for navigation
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  iniFix3D;                 //!< 1 = initial fix must be 3D
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  ackAiding;                //!< 1 = issue acknowledgements for assistance message input
    U2  wknRollover;              //!< GPS week rollover number; GPS week numbers will be set correctly from this week up to 1024 weeks after this week. Setting this to 0 reverts to firmware default.
    U1  reserved4[6];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  usePPP;                   //!< 1 = use Precise Point Positioning (only available with the PPP product variant)
    U1  aopCfg;                   //!< <i>AssistNow Autonomous</i> configuration
    U1  reserved5[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  aopOrbMaxErr;             //!< Maximum acceptable (modeled) <i>AssistNow Autonomous</i> orbit error (valid range = 5..1000, or 0 = reset to firmware default)
    U1  reserved6[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  reserved7[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  useAdr;                   //!< <i>Only supported on certain products</i>

} UBX_CFG_NAVX5_DATA0_t, *UBX_CFG_NAVX5_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_NAVX5_DATA0_s::mask1
//@{
#define UBX_CFG_NAVX5_DATA0_MASK1_MINMAX_MASK 0x0004  //!< Mask for field minMax in bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_MINMAX_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK1_MINMAX_MASK)>>2)  //!< Get minMax from bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_MINCNO_MASK 0x0008  //!< Mask for field minCno in bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_MINCNO_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK1_MINCNO_MASK)>>3)  //!< Get minCno from bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_INITIAL3DFIX_MASK 0x0040  //!< Mask for field initial3dfix in bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_INITIAL3DFIX_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK1_INITIAL3DFIX_MASK)>>6)  //!< Get initial3dfix from bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_WKNROLL_MASK 0x0200  //!< Mask for field wknRoll in bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_WKNROLL_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK1_WKNROLL_MASK)>>9)  //!< Get wknRoll from bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_ACKAID_MASK 0x0400  //!< Mask for field ackAid in bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_ACKAID_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK1_ACKAID_MASK)>>10)  //!< Get ackAid from bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_PPP_MASK 0x2000  //!< Mask for field ppp in bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_PPP_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK1_PPP_MASK)>>13)  //!< Get ppp from bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_AOP_MASK 0x4000  //!< Mask for field aop in bitmask mask1
#define UBX_CFG_NAVX5_DATA0_MASK1_AOP_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK1_AOP_MASK)>>14)  //!< Get aop from bitmask mask1

//@}
//! \name Bit Definitions for #UBX_CFG_NAVX5_DATA0_s::mask2
//@{
#define UBX_CFG_NAVX5_DATA0_MASK2_ADR_MASK 0x00000040  //!< Mask for field adr in bitmask mask2
#define UBX_CFG_NAVX5_DATA0_MASK2_ADR_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_MASK2_ADR_MASK)>>6)  //!< Get adr from bitmask mask2

//@}
//! \name Bit Definitions for #UBX_CFG_NAVX5_DATA0_s::aopCfg
//@{
#define UBX_CFG_NAVX5_DATA0_AOPCFG_USEAOP_MASK 0x01  //!< Mask for field useAOP in bitmask aopCfg
#define UBX_CFG_NAVX5_DATA0_AOPCFG_USEAOP_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA0_AOPCFG_USEAOP_MASK)>>0)  //!< Get useAOP from bitmask aopCfg

//@}

#define UBXID_CFG_NAVX5 0x0623 //!< message id for CFG-NAVX5


//================================================================
//! CFG_NAVX5_DATA2: Get/Set
/*!
Navigation Engine Expert Settings
-


This message's id is #UBXID_CFG_NAVX5
*/
//================================================================

typedef struct UBX_CFG_NAVX5_DATA2_s
{
    U2  version;                  //!< Message version (2 for this version)
    X2  mask1;                    //!< First parameters bitmask. Only the flagged parameters will be applied, unused bits must be set to 0.
    X4  mask2;                    //!< Second parameters bitmask. Only the flagged parameters will be applied, unused bits must be set to 0.
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  minSVs;                   //!< Minimum number of satellites for navigation
    U1  maxSVs;                   //!< Maximum number of satellites for navigation
    U1  minCNO;                   //!< Minimum satellite signal level for navigation
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  iniFix3D;                 //!< 1 = initial fix must be 3D
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  ackAiding;                //!< 1 = issue acknowledgements for assistance message input
    U2  wknRollover;              //!< GPS week rollover number; GPS week numbers will be set correctly from this week up to 1024 weeks after this week. Setting this to 0 reverts to firmware default.
    U1  sigAttenCompMode;         //!< <i>Only supported on certain products</i>
    U1  reserved4;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  reserved5[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  reserved6[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  usePPP;                   //!< 1 = use Precise Point Positioning (only available with the PPP product variant)
    U1  aopCfg;                   //!< <i>AssistNow Autonomous</i> configuration
    U1  reserved7[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  aopOrbMaxErr;             //!< Maximum acceptable (modeled) <i>AssistNow Autonomous</i> orbit error (valid range = 5..1000, or 0 = reset to firmware default)
    U1  reserved8[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  reserved9[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  useAdr;                   //!< <i>Only supported on certain products</i>

} UBX_CFG_NAVX5_DATA2_t, *UBX_CFG_NAVX5_DATA2_pt;


//! \name Bit Definitions for #UBX_CFG_NAVX5_DATA2_s::mask1
//@{
#define UBX_CFG_NAVX5_DATA2_MASK1_MINMAX_MASK 0x0004  //!< Mask for field minMax in bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_MINMAX_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK1_MINMAX_MASK)>>2)  //!< Get minMax from bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_MINCNO_MASK 0x0008  //!< Mask for field minCno in bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_MINCNO_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK1_MINCNO_MASK)>>3)  //!< Get minCno from bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_INITIAL3DFIX_MASK 0x0040  //!< Mask for field initial3dfix in bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_INITIAL3DFIX_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK1_INITIAL3DFIX_MASK)>>6)  //!< Get initial3dfix from bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_WKNROLL_MASK 0x0200  //!< Mask for field wknRoll in bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_WKNROLL_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK1_WKNROLL_MASK)>>9)  //!< Get wknRoll from bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_ACKAID_MASK 0x0400  //!< Mask for field ackAid in bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_ACKAID_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK1_ACKAID_MASK)>>10)  //!< Get ackAid from bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_PPP_MASK 0x2000  //!< Mask for field ppp in bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_PPP_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK1_PPP_MASK)>>13)  //!< Get ppp from bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_AOP_MASK 0x4000  //!< Mask for field aop in bitmask mask1
#define UBX_CFG_NAVX5_DATA2_MASK1_AOP_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK1_AOP_MASK)>>14)  //!< Get aop from bitmask mask1

//@}
//! \name Bit Definitions for #UBX_CFG_NAVX5_DATA2_s::mask2
//@{
#define UBX_CFG_NAVX5_DATA2_MASK2_ADR_MASK 0x00000040  //!< Mask for field adr in bitmask mask2
#define UBX_CFG_NAVX5_DATA2_MASK2_ADR_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK2_ADR_MASK)>>6)  //!< Get adr from bitmask mask2
#define UBX_CFG_NAVX5_DATA2_MASK2_SIGATTENCOMP_MASK 0x00000080  //!< Mask for field sigAttenComp in bitmask mask2
#define UBX_CFG_NAVX5_DATA2_MASK2_SIGATTENCOMP_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_MASK2_SIGATTENCOMP_MASK)>>7)  //!< Get sigAttenComp from bitmask mask2

//@}
//! \name Bit Definitions for #UBX_CFG_NAVX5_DATA2_s::aopCfg
//@{
#define UBX_CFG_NAVX5_DATA2_AOPCFG_USEAOP_MASK 0x01  //!< Mask for field useAOP in bitmask aopCfg
#define UBX_CFG_NAVX5_DATA2_AOPCFG_USEAOP_GET(val)  (U)(((val)&UBX_CFG_NAVX5_DATA2_AOPCFG_USEAOP_MASK)>>0)  //!< Get useAOP from bitmask aopCfg

//@}

//#define UBXID_CFG_NAVX5 0x0623  // already defined, see above


//================================================================
//! CFG_NMEA_DATA0: Get/Set
/*!
NMEA protocol configuration (deprecated)
Set/Get the <r href=\"NMEA_overview'>NMEA protocol</r> configuration. See section <r href=\"CFG-NMEA-DESC'>NMEA Protocol Configuration</r> for a detailed description of the configuration effects on NMEA output.

   \note: This message version is provided for backwards compatibility only. Use the last version listed below instead (its fields are backwards compatible with this version, it just has extra fields defined).

This message's id is #UBXID_CFG_NMEA
*/
//================================================================

typedef struct UBX_CFG_NMEA_DATA0_s
{
    X1  filter;                   //!< filter flags
    U1  nmeaVersion;              //!< 0x23: NMEA version 2.3
    U1  numSV;                    //!< Maximum Number of SVs to report per TalkerId.
    X1  flags;                    //!< flags

} UBX_CFG_NMEA_DATA0_t, *UBX_CFG_NMEA_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_NMEA_DATA0_s::filter
//@{
#define UBX_CFG_NMEA_DATA0_FILTER_POSFILT_MASK 0x01  //!< Mask for field posFilt in bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_POSFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FILTER_POSFILT_MASK)>>0)  //!< Get posFilt from bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_MSKPOSFILT_MASK 0x02  //!< Mask for field mskPosFilt in bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_MSKPOSFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FILTER_MSKPOSFILT_MASK)>>1)  //!< Get mskPosFilt from bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_TIMEFILT_MASK 0x04  //!< Mask for field timeFilt in bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_TIMEFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FILTER_TIMEFILT_MASK)>>2)  //!< Get timeFilt from bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_DATEFILT_MASK 0x08  //!< Mask for field dateFilt in bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_DATEFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FILTER_DATEFILT_MASK)>>3)  //!< Get dateFilt from bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_GPSONLYFILTER_MASK 0x10  //!< Mask for field gpsOnlyFilter in bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_GPSONLYFILTER_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FILTER_GPSONLYFILTER_MASK)>>4)  //!< Get gpsOnlyFilter from bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_TRACKFILT_MASK 0x20  //!< Mask for field trackFilt in bitmask filter
#define UBX_CFG_NMEA_DATA0_FILTER_TRACKFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FILTER_TRACKFILT_MASK)>>5)  //!< Get trackFilt from bitmask filter

//@}
//! \name Bit Definitions for #UBX_CFG_NMEA_DATA0_s::flags
//@{
#define UBX_CFG_NMEA_DATA0_FLAGS_COMPAT_MASK 0x01  //!< Mask for field compat in bitmask flags
#define UBX_CFG_NMEA_DATA0_FLAGS_COMPAT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FLAGS_COMPAT_MASK)>>0)  //!< Get compat from bitmask flags
#define UBX_CFG_NMEA_DATA0_FLAGS_CONSIDER_MASK 0x02  //!< Mask for field consider in bitmask flags
#define UBX_CFG_NMEA_DATA0_FLAGS_CONSIDER_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA0_FLAGS_CONSIDER_MASK)>>1)  //!< Get consider from bitmask flags

//@}

#define UBXID_CFG_NMEA 0x0617 //!< message id for CFG-NMEA


//================================================================
//! CFG_NMEA_DATA1: Get/Set
/*!
NMEA protocol configuration V0 (deprecated)
Set/Get the <r href=\"NMEA_overview'>NMEA protocol</r> configuration. See section <r href=\"CFG-NMEA-DESC'>NMEA Protocol Configuration</r> for a detailed description of the configuration effects on NMEA output.

   \note: This message version is provided for backwards compatibility only. Use the last version listed below instead (its fields are backwards compatible with this version, it just has extra fields defined).

This message's id is #UBXID_CFG_NMEA
*/
//================================================================

typedef struct UBX_CFG_NMEA_DATA1_s
{
    X1  filter;                   //!< filter flags
    U1  nmeaVersion;              //!< 0x23: NMEA version 2.3
    U1  numSV;                    //!< Maximum Number of SVs to report per TalkerId.
    X1  flags;                    //!< flags
    X4  gnssToFilter;             //!< Filters out satellites based on their GNSS. If a bitfield is enabled, the corresponding satellites will be not output.
    U1  svNumbering;              //!< Configures the display of satellites that do not have an NMEA-defined value.
    U1  mainTalkerId;             //!< By default the main Talker ID (i.e. the Talker ID used for all messages other than GSV) is determined by the GNSS assignment of the receiver's channels (see <rc href=\"UBX-CFG-GNSS'>UBX-CFG-GNSS</rc>).
    U1  gsvTalkerId;              //!< By default the Talker ID for GSV messages is GNSS specific (as defined by NMEA).
    U1  version;                  //!< Message version (set to 0 for this version)

} UBX_CFG_NMEA_DATA1_t, *UBX_CFG_NMEA_DATA1_pt;


//! \name Bit Definitions for #UBX_CFG_NMEA_DATA1_s::filter
//@{
#define UBX_CFG_NMEA_DATA1_FILTER_POSFILT_MASK 0x01  //!< Mask for field posFilt in bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_POSFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FILTER_POSFILT_MASK)>>0)  //!< Get posFilt from bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_MSKPOSFILT_MASK 0x02  //!< Mask for field mskPosFilt in bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_MSKPOSFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FILTER_MSKPOSFILT_MASK)>>1)  //!< Get mskPosFilt from bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_TIMEFILT_MASK 0x04  //!< Mask for field timeFilt in bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_TIMEFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FILTER_TIMEFILT_MASK)>>2)  //!< Get timeFilt from bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_DATEFILT_MASK 0x08  //!< Mask for field dateFilt in bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_DATEFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FILTER_DATEFILT_MASK)>>3)  //!< Get dateFilt from bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_GPSONLYFILTER_MASK 0x10  //!< Mask for field gpsOnlyFilter in bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_GPSONLYFILTER_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FILTER_GPSONLYFILTER_MASK)>>4)  //!< Get gpsOnlyFilter from bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_TRACKFILT_MASK 0x20  //!< Mask for field trackFilt in bitmask filter
#define UBX_CFG_NMEA_DATA1_FILTER_TRACKFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FILTER_TRACKFILT_MASK)>>5)  //!< Get trackFilt from bitmask filter

//@}
//! \name Bit Definitions for #UBX_CFG_NMEA_DATA1_s::flags
//@{
#define UBX_CFG_NMEA_DATA1_FLAGS_COMPAT_MASK 0x01  //!< Mask for field compat in bitmask flags
#define UBX_CFG_NMEA_DATA1_FLAGS_COMPAT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FLAGS_COMPAT_MASK)>>0)  //!< Get compat from bitmask flags
#define UBX_CFG_NMEA_DATA1_FLAGS_CONSIDER_MASK 0x02  //!< Mask for field consider in bitmask flags
#define UBX_CFG_NMEA_DATA1_FLAGS_CONSIDER_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_FLAGS_CONSIDER_MASK)>>1)  //!< Get consider from bitmask flags

//@}
//! \name Bit Definitions for #UBX_CFG_NMEA_DATA1_s::gnssToFilter
//@{
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_GPS_MASK 0x01  //!< Mask for field gps in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_GPS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_GNSSTOFILTER_GPS_MASK)>>0)  //!< Get gps from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_SBAS_MASK 0x02  //!< Mask for field sbas in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_SBAS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_GNSSTOFILTER_SBAS_MASK)>>1)  //!< Get sbas from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_QZSS_MASK 0x10  //!< Mask for field qzss in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_QZSS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_GNSSTOFILTER_QZSS_MASK)>>4)  //!< Get qzss from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_GLONASS_MASK 0x20  //!< Mask for field glonass in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_GLONASS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_GNSSTOFILTER_GLONASS_MASK)>>5)  //!< Get glonass from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_BEIDOU_MASK 0x40  //!< Mask for field beidou in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA1_GNSSTOFILTER_BEIDOU_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA1_GNSSTOFILTER_BEIDOU_MASK)>>6)  //!< Get beidou from bitmask gnssToFilter

//@}

//#define UBXID_CFG_NMEA 0x0617  // already defined, see above


//================================================================
//! CFG_NMEA_DATA2: Get/Set
/*!
Extended NMEA protocol configuration V1
Set/Get the <r href=\"NMEA_overview'>NMEA protocol</r> configuration. See section <r href=\"CFG-NMEA-DESC'>NMEA Protocol Configuration</r> for a detailed description of the configuration effects on NMEA output.


This message's id is #UBXID_CFG_NMEA
*/
//================================================================

typedef struct UBX_CFG_NMEA_DATA2_s
{
    X1  filter;                   //!< filter flags
    U1  nmeaVersion;              //!< 0x41: NMEA version 4.1
    U1  numSV;                    //!< Maximum Number of SVs to report per TalkerId.
    X1  flags;                    //!< flags
    X4  gnssToFilter;             //!< Filters out satellites based on their GNSS. If a bitfield is enabled, the corresponding satellites will be not output.
    U1  svNumbering;              //!< Configures the display of satellites that do not have an NMEA-defined value.
    U1  mainTalkerId;             //!< By default the main Talker ID (i.e. the Talker ID used for all messages other than GSV) is determined by the GNSS assignment of the receiver's channels (see <rc href=\"UBX-CFG-GNSS'>UBX-CFG-GNSS</rc>).
    U1  gsvTalkerId;              //!< By default the Talker ID for GSV messages is GNSS specific (as defined by NMEA).
    U1  version;                  //!< Message version (set to 1 for this version)
    CH  bdsTalkerId[2];           //!< Sets the two characters that should be used for the BeiDou Talker ID
    U1  reserved1[6];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_NMEA_DATA2_t, *UBX_CFG_NMEA_DATA2_pt;


//! \name Bit Definitions for #UBX_CFG_NMEA_DATA2_s::filter
//@{
#define UBX_CFG_NMEA_DATA2_FILTER_POSFILT_MASK 0x01  //!< Mask for field posFilt in bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_POSFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FILTER_POSFILT_MASK)>>0)  //!< Get posFilt from bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_MSKPOSFILT_MASK 0x02  //!< Mask for field mskPosFilt in bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_MSKPOSFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FILTER_MSKPOSFILT_MASK)>>1)  //!< Get mskPosFilt from bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_TIMEFILT_MASK 0x04  //!< Mask for field timeFilt in bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_TIMEFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FILTER_TIMEFILT_MASK)>>2)  //!< Get timeFilt from bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_DATEFILT_MASK 0x08  //!< Mask for field dateFilt in bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_DATEFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FILTER_DATEFILT_MASK)>>3)  //!< Get dateFilt from bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_GPSONLYFILTER_MASK 0x10  //!< Mask for field gpsOnlyFilter in bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_GPSONLYFILTER_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FILTER_GPSONLYFILTER_MASK)>>4)  //!< Get gpsOnlyFilter from bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_TRACKFILT_MASK 0x20  //!< Mask for field trackFilt in bitmask filter
#define UBX_CFG_NMEA_DATA2_FILTER_TRACKFILT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FILTER_TRACKFILT_MASK)>>5)  //!< Get trackFilt from bitmask filter

//@}
//! \name Bit Definitions for #UBX_CFG_NMEA_DATA2_s::flags
//@{
#define UBX_CFG_NMEA_DATA2_FLAGS_COMPAT_MASK 0x01  //!< Mask for field compat in bitmask flags
#define UBX_CFG_NMEA_DATA2_FLAGS_COMPAT_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FLAGS_COMPAT_MASK)>>0)  //!< Get compat from bitmask flags
#define UBX_CFG_NMEA_DATA2_FLAGS_CONSIDER_MASK 0x02  //!< Mask for field consider in bitmask flags
#define UBX_CFG_NMEA_DATA2_FLAGS_CONSIDER_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FLAGS_CONSIDER_MASK)>>1)  //!< Get consider from bitmask flags
#define UBX_CFG_NMEA_DATA2_FLAGS_LIMIT82_MASK 0x04  //!< Mask for field limit82 in bitmask flags
#define UBX_CFG_NMEA_DATA2_FLAGS_LIMIT82_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_FLAGS_LIMIT82_MASK)>>2)  //!< Get limit82 from bitmask flags

//@}
//! \name Bit Definitions for #UBX_CFG_NMEA_DATA2_s::gnssToFilter
//@{
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_GPS_MASK 0x01  //!< Mask for field gps in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_GPS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_GNSSTOFILTER_GPS_MASK)>>0)  //!< Get gps from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_SBAS_MASK 0x02  //!< Mask for field sbas in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_SBAS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_GNSSTOFILTER_SBAS_MASK)>>1)  //!< Get sbas from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_QZSS_MASK 0x10  //!< Mask for field qzss in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_QZSS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_GNSSTOFILTER_QZSS_MASK)>>4)  //!< Get qzss from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_GLONASS_MASK 0x20  //!< Mask for field glonass in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_GLONASS_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_GNSSTOFILTER_GLONASS_MASK)>>5)  //!< Get glonass from bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_BEIDOU_MASK 0x40  //!< Mask for field beidou in bitmask gnssToFilter
#define UBX_CFG_NMEA_DATA2_GNSSTOFILTER_BEIDOU_GET(val)  (U)(((val)&UBX_CFG_NMEA_DATA2_GNSSTOFILTER_BEIDOU_MASK)>>6)  //!< Get beidou from bitmask gnssToFilter

//@}

//#define UBXID_CFG_NMEA 0x0617  // already defined, see above


//================================================================
//! CFG_ODO_DATA1: Get/Set
/*!
Odometer, Low-speed COG Engine Settings
-

   \note: This feature is not supported for the FTS product variant.

This message's id is #UBXID_CFG_ODO
*/
//================================================================

typedef struct UBX_CFG_ODO_DATA1_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  flags;                    //!< <i>Odometer/Low-speed COG filter</i> flags
    X1  odoCfg;                   //!< <i>Odometer filter</i> settings
    U1  reserved2[6];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  cogMaxSpeed;              //!< Speed below which course-over-ground (COG) is computed with the low-speed COG filter
    U1  cogMaxPosAcc;             //!< Maximum acceptable position accuracy for computing COG with the low-speed COG filter
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  velLpGain;                //!< Velocity low-pass filter level, range 0..255
    U1  cogLpGain;                //!< COG low-pass filter level (at speed < 8 m/s), range 0..255
    U1  reserved4[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_ODO_DATA1_t, *UBX_CFG_ODO_DATA1_pt;


//! \name Bit Definitions for #UBX_CFG_ODO_DATA1_s::flags
//@{
#define UBX_CFG_ODO_DATA1_FLAGS_USEODO_MASK 0x01  //!< Mask for field useODO in bitmask flags
#define UBX_CFG_ODO_DATA1_FLAGS_USEODO_GET(val)  (U)(((val)&UBX_CFG_ODO_DATA1_FLAGS_USEODO_MASK)>>0)  //!< Get useODO from bitmask flags
#define UBX_CFG_ODO_DATA1_FLAGS_USECOG_MASK 0x02  //!< Mask for field useCOG in bitmask flags
#define UBX_CFG_ODO_DATA1_FLAGS_USECOG_GET(val)  (U)(((val)&UBX_CFG_ODO_DATA1_FLAGS_USECOG_MASK)>>1)  //!< Get useCOG from bitmask flags
#define UBX_CFG_ODO_DATA1_FLAGS_OUTLPVEL_MASK 0x04  //!< Mask for field outLPVel in bitmask flags
#define UBX_CFG_ODO_DATA1_FLAGS_OUTLPVEL_GET(val)  (U)(((val)&UBX_CFG_ODO_DATA1_FLAGS_OUTLPVEL_MASK)>>2)  //!< Get outLPVel from bitmask flags
#define UBX_CFG_ODO_DATA1_FLAGS_OUTLPCOG_MASK 0x08  //!< Mask for field outLPCog in bitmask flags
#define UBX_CFG_ODO_DATA1_FLAGS_OUTLPCOG_GET(val)  (U)(((val)&UBX_CFG_ODO_DATA1_FLAGS_OUTLPCOG_MASK)>>3)  //!< Get outLPCog from bitmask flags

//@}
//! \name Bit Definitions for #UBX_CFG_ODO_DATA1_s::odoCfg
//@{
#define UBX_CFG_ODO_DATA1_ODOCFG_PROFILE_MASK 0x07  //!< Mask for field profile in bitmask odoCfg
#define UBX_CFG_ODO_DATA1_ODOCFG_PROFILE_GET(val)  (U)(((val)&UBX_CFG_ODO_DATA1_ODOCFG_PROFILE_MASK)>>0)  //!< Get profile from bitmask odoCfg

//@}

#define UBXID_CFG_ODO 0x061E //!< message id for CFG-ODO


//================================================================
//! CFG_PM2_DATA0: Get/Set
/*!
Extended Power Management configuration
-

   \note: This feature is not supported for either the ADR or FTS products.

This message's id is #UBXID_CFG_PM2
*/
//================================================================

typedef struct UBX_CFG_PM2_DATA0_s
{
    U1  version;                  //!< Message version (0x01 for this version)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  maxStartupStateDur;       //!< Maximum time to spend in <i>Acquisition</i> state. If 0: bound disabled (see <r href=\"PM-DESC-MAXSTARTUPSTATEDUR'>maxStartupStateDur</r>). (not supported in <r href='FIRMWARE-PROTOCOLVERSION'>protocol versions less than 17</r>)
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X4  flags;                    //!< PSM configuration flags
    U4  updatePeriod;             //!< Position update period. If set to 0, the receiver will never retry a fix and it will wait for external events
    U4  searchPeriod;             //!< Acquisition retry period if previously failed. If set to 0, the receiver will never retry a startup
    U4  gridOffset;               //!< Grid offset relative to GPS start of week
    U2  onTime;                   //!< Time to stay in <i>Tracking</i> state
    U2  minAcqTime;               //!< minimal search time
    U1  reserved3[20];            //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_PM2_DATA0_t, *UBX_CFG_PM2_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_PM2_DATA0_s::flags
//@{
#define UBX_CFG_PM2_DATA0_FLAGS_EXTINTSEL_MASK 0x00000010  //!< Mask for field extintSel in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_EXTINTSEL_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_EXTINTSEL_MASK)>>4)  //!< Get extintSel from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_EXTINTWAKE_MASK 0x00000020  //!< Mask for field extintWake in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_EXTINTWAKE_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_EXTINTWAKE_MASK)>>5)  //!< Get extintWake from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_EXTINTBACKUP_MASK 0x00000040  //!< Mask for field extintBackup in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_EXTINTBACKUP_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_EXTINTBACKUP_MASK)>>6)  //!< Get extintBackup from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_LIMITPEAKCURR_MASK 0x00000300  //!< Mask for field limitPeakCurr in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_LIMITPEAKCURR_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_LIMITPEAKCURR_MASK)>>8)  //!< Get limitPeakCurr from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_WAITTIMEFIX_MASK 0x00000400  //!< Mask for field waitTimeFix in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_WAITTIMEFIX_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_WAITTIMEFIX_MASK)>>10)  //!< Get waitTimeFix from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_UPDATERTC_MASK 0x00000800  //!< Mask for field updateRTC in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_UPDATERTC_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_UPDATERTC_MASK)>>11)  //!< Get updateRTC from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_UPDATEEPH_MASK 0x00001000  //!< Mask for field updateEPH in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_UPDATEEPH_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_UPDATEEPH_MASK)>>12)  //!< Get updateEPH from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_DONOTENTEROFF_MASK 0x00010000  //!< Mask for field doNotEnterOff in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_DONOTENTEROFF_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_DONOTENTEROFF_MASK)>>16)  //!< Get doNotEnterOff from bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_MODE_MASK 0x00060000  //!< Mask for field mode in bitmask flags
#define UBX_CFG_PM2_DATA0_FLAGS_MODE_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA0_FLAGS_MODE_MASK)>>17)  //!< Get mode from bitmask flags

//@}

#define UBXID_CFG_PM2 0x063B //!< message id for CFG-PM2


//================================================================
//! CFG_PM2_DATA1: Get/Set
/*!
Extended Power Management configuration
-

   \note: This feature is not supported for either the ADR or FTS products.

This message's id is #UBXID_CFG_PM2
*/
//================================================================

typedef struct UBX_CFG_PM2_DATA1_s
{
    U1  version;                  //!< Message version (0x02 for this version)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  maxStartupStateDur;       //!< Maximum time to spend in <i>Acquisition</i> state. If 0: bound disabled (see <r href=\"PM-DESC-MAXSTARTUPSTATEDUR'>maxStartupStateDur</r>). (not supported in <r href='FIRMWARE-PROTOCOLVERSION'>protocol versions less than 17</r>)
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X4  flags;                    //!< PSM configuration flags
    U4  updatePeriod;             //!< Position update period. If set to 0, the receiver will never retry a fix and it will wait for external events
    U4  searchPeriod;             //!< Acquisition retry period if previously failed. If set to 0, the receiver will never retry a startup
    U4  gridOffset;               //!< Grid offset relative to GPS start of week
    U2  onTime;                   //!< Time to stay in <i>Tracking</i> state
    U2  minAcqTime;               //!< minimal search time
    U1  reserved3[20];            //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  extintInactivityMs;       //!< inactivity time out on EXTINT pint if enabled

} UBX_CFG_PM2_DATA1_t, *UBX_CFG_PM2_DATA1_pt;


//! \name Bit Definitions for #UBX_CFG_PM2_DATA1_s::flags
//@{
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTSEL_MASK 0x00000010  //!< Mask for field extintSel in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTSEL_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_EXTINTSEL_MASK)>>4)  //!< Get extintSel from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTWAKE_MASK 0x00000020  //!< Mask for field extintWake in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTWAKE_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_EXTINTWAKE_MASK)>>5)  //!< Get extintWake from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTBACKUP_MASK 0x00000040  //!< Mask for field extintBackup in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTBACKUP_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_EXTINTBACKUP_MASK)>>6)  //!< Get extintBackup from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTINACTIVE_MASK 0x00000080  //!< Mask for field extintInactive in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_EXTINTINACTIVE_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_EXTINTINACTIVE_MASK)>>7)  //!< Get extintInactive from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_LIMITPEAKCURR_MASK 0x00000300  //!< Mask for field limitPeakCurr in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_LIMITPEAKCURR_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_LIMITPEAKCURR_MASK)>>8)  //!< Get limitPeakCurr from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_WAITTIMEFIX_MASK 0x00000400  //!< Mask for field waitTimeFix in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_WAITTIMEFIX_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_WAITTIMEFIX_MASK)>>10)  //!< Get waitTimeFix from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_UPDATERTC_MASK 0x00000800  //!< Mask for field updateRTC in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_UPDATERTC_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_UPDATERTC_MASK)>>11)  //!< Get updateRTC from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_UPDATEEPH_MASK 0x00001000  //!< Mask for field updateEPH in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_UPDATEEPH_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_UPDATEEPH_MASK)>>12)  //!< Get updateEPH from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_DONOTENTEROFF_MASK 0x00010000  //!< Mask for field doNotEnterOff in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_DONOTENTEROFF_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_DONOTENTEROFF_MASK)>>16)  //!< Get doNotEnterOff from bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_MODE_MASK 0x00060000  //!< Mask for field mode in bitmask flags
#define UBX_CFG_PM2_DATA1_FLAGS_MODE_GET(val)  (U)(((val)&UBX_CFG_PM2_DATA1_FLAGS_MODE_MASK)>>17)  //!< Get mode from bitmask flags

//@}

//#define UBXID_CFG_PM2 0x063B  // already defined, see above


//================================================================
//! CFG_PMS_DATA0: Get/Set
/*!
Power Mode Setup
-


This message's id is #UBXID_CFG_PMS
*/
//================================================================

typedef struct UBX_CFG_PMS_DATA0_s
{
    U1  version;                  //!< Message version (0x00 for this version)
    U1  powerSetupValue;          //!< Power setup value
    U2  period;                   //!< Position update period and search period.
    U2  onTime;                   //!< Duration of the ON phase, must be smaller than the period.
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_PMS_DATA0_t, *UBX_CFG_PMS_DATA0_pt;


#define UBXID_CFG_PMS 0x0686 //!< message id for CFG-PMS


//================================================================
//! CFG_PRT_POLLID: Poll Request
/*!
Polls the configuration for one I/O Port
Sending this message with a port ID as payload results in having the receiver return the configuration for the specified port.


This message's id is #UBXID_CFG_PRT
*/
//================================================================

typedef struct UBX_CFG_PRT_POLLID_s
{
    U1  PortID;                   //!< Port Identifier Number (see the other versions of CFG-PRT for valid values)

} UBX_CFG_PRT_POLLID_t, *UBX_CFG_PRT_POLLID_pt;


#define UBXID_CFG_PRT 0x0600 //!< message id for CFG-PRT


//================================================================
//! CFG_PRT_UART: Get/Set
/*!
Port Configuration for UART
Several configurations can be concatenated to one input message. In this case the payload length can be a multiple of the normal length (see the other versions of CFG-PRT). Output messages from the module contain only one configuration unit.
Note that this message can affect baud rate and other transmission parameters. Because there may be messages queued for transmission there may be uncertainty about which protocol applies to such messages. In addition a message currently in transmission may be corrupted by a protocol change. Host data reception paramaters may have to be changed to be able to receive future messages, including the acknowledge message resulting from the CFG-PRT message.


This message's id is #UBXID_CFG_PRT
*/
//================================================================

typedef struct UBX_CFG_PRT_UART_s
{
    U1  portID;                   //!< Port Identifier Number (see <r href=\"CFG-PRT-DESC'>Serial Communication Ports Description</r> for valid UART port IDs)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  txReady;                  //!< TX ready PIN configuration
    X4  mode;                     //!< A bit mask describing the UART mode
    U4  baudRate;                 //!< Baud rate in bits/second
    X2  inProtoMask;              //!< A mask describing which input protocols are active.
    X2  outProtoMask;             //!< A mask describing which output protocols are active.
    X2  flags;                    //!< Flags bit mask
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_PRT_UART_t, *UBX_CFG_PRT_UART_pt;


//! \name Bit Definitions for #UBX_CFG_PRT_UART_s::txReady
//@{
#define UBX_CFG_PRT_UART_TXREADY_EN_MASK 0x00000001  //!< Mask for field en in bitmask txReady
#define UBX_CFG_PRT_UART_TXREADY_EN_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_TXREADY_EN_MASK)>>0)  //!< Get en from bitmask txReady
#define UBX_CFG_PRT_UART_TXREADY_POL_MASK 0x00000002  //!< Mask for field pol in bitmask txReady
#define UBX_CFG_PRT_UART_TXREADY_POL_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_TXREADY_POL_MASK)>>1)  //!< Get pol from bitmask txReady
#define UBX_CFG_PRT_UART_TXREADY_PIN_MASK 0x0000007C  //!< Mask for field pin in bitmask txReady
#define UBX_CFG_PRT_UART_TXREADY_PIN_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_TXREADY_PIN_MASK)>>2)  //!< Get pin from bitmask txReady
#define UBX_CFG_PRT_UART_TXREADY_THRES_MASK 0x0000FF80  //!< Mask for field thres in bitmask txReady
#define UBX_CFG_PRT_UART_TXREADY_THRES_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_TXREADY_THRES_MASK)>>7)  //!< Get thres from bitmask txReady

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_UART_s::mode
//@{
#define UBX_CFG_PRT_UART_MODE_CHARLEN_MASK 0x000000C0  //!< Mask for field charLen in bitmask mode
#define UBX_CFG_PRT_UART_MODE_CHARLEN_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_MODE_CHARLEN_MASK)>>6)  //!< Get charLen from bitmask mode
#define UBX_CFG_PRT_UART_MODE_PARITY_MASK 0x00000E00  //!< Mask for field parity in bitmask mode
#define UBX_CFG_PRT_UART_MODE_PARITY_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_MODE_PARITY_MASK)>>9)  //!< Get parity from bitmask mode
#define UBX_CFG_PRT_UART_MODE_NSTOPBITS_MASK 0x00003000  //!< Mask for field nStopBits in bitmask mode
#define UBX_CFG_PRT_UART_MODE_NSTOPBITS_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_MODE_NSTOPBITS_MASK)>>12)  //!< Get nStopBits from bitmask mode

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_UART_s::inProtoMask
//@{
#define UBX_CFG_PRT_UART_INPROTOMASK_INUBX_MASK 0x0001  //!< Mask for field inUbx in bitmask inProtoMask
#define UBX_CFG_PRT_UART_INPROTOMASK_INUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_INPROTOMASK_INUBX_MASK)>>0)  //!< Get inUbx from bitmask inProtoMask
#define UBX_CFG_PRT_UART_INPROTOMASK_INNMEA_MASK 0x0002  //!< Mask for field inNmea in bitmask inProtoMask
#define UBX_CFG_PRT_UART_INPROTOMASK_INNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_INPROTOMASK_INNMEA_MASK)>>1)  //!< Get inNmea from bitmask inProtoMask
#define UBX_CFG_PRT_UART_INPROTOMASK_INRTCM_MASK 0x0004  //!< Mask for field inRtcm in bitmask inProtoMask
#define UBX_CFG_PRT_UART_INPROTOMASK_INRTCM_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_INPROTOMASK_INRTCM_MASK)>>2)  //!< Get inRtcm from bitmask inProtoMask
#define UBX_CFG_PRT_UART_INPROTOMASK_INRTCM3_MASK 0x0020  //!< Mask for field inRtcm3 in bitmask inProtoMask
#define UBX_CFG_PRT_UART_INPROTOMASK_INRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_INPROTOMASK_INRTCM3_MASK)>>5)  //!< Get inRtcm3 from bitmask inProtoMask

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_UART_s::outProtoMask
//@{
#define UBX_CFG_PRT_UART_OUTPROTOMASK_OUTUBX_MASK 0x0001  //!< Mask for field outUbx in bitmask outProtoMask
#define UBX_CFG_PRT_UART_OUTPROTOMASK_OUTUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_OUTPROTOMASK_OUTUBX_MASK)>>0)  //!< Get outUbx from bitmask outProtoMask
#define UBX_CFG_PRT_UART_OUTPROTOMASK_OUTNMEA_MASK 0x0002  //!< Mask for field outNmea in bitmask outProtoMask
#define UBX_CFG_PRT_UART_OUTPROTOMASK_OUTNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_OUTPROTOMASK_OUTNMEA_MASK)>>1)  //!< Get outNmea from bitmask outProtoMask
#define UBX_CFG_PRT_UART_OUTPROTOMASK_OUTRTCM3_MASK 0x0020  //!< Mask for field outRtcm3 in bitmask outProtoMask
#define UBX_CFG_PRT_UART_OUTPROTOMASK_OUTRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_OUTPROTOMASK_OUTRTCM3_MASK)>>5)  //!< Get outRtcm3 from bitmask outProtoMask

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_UART_s::flags
//@{
#define UBX_CFG_PRT_UART_FLAGS_EXTENDEDTXTIMEOUT_MASK 0x0002  //!< Mask for field extendedTxTimeout in bitmask flags
#define UBX_CFG_PRT_UART_FLAGS_EXTENDEDTXTIMEOUT_GET(val)  (U)(((val)&UBX_CFG_PRT_UART_FLAGS_EXTENDEDTXTIMEOUT_MASK)>>1)  //!< Get extendedTxTimeout from bitmask flags

//@}

//#define UBXID_CFG_PRT 0x0600  // already defined, see above


//================================================================
//! CFG_PRT_USB: Get/Set
/*!
Port Configuration for USB Port
Several configurations can be concatenated to one input message. In this case the payload length can be a multiple of the normal length (see the other versions of CFG-PRT). Output messages from the module contain only one configuration unit.


This message's id is #UBXID_CFG_PRT
*/
//================================================================

typedef struct UBX_CFG_PRT_USB_s
{
    U1  portID;                   //!< Port Identifier Number (= 3 for USB port)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  txReady;                  //!< TX ready PIN configuration
    U1  reserved2[8];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  inProtoMask;              //!< A mask describing which input protocols are active.
    X2  outProtoMask;             //!< A mask describing which output protocols are active.
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  reserved4[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_PRT_USB_t, *UBX_CFG_PRT_USB_pt;


//! \name Bit Definitions for #UBX_CFG_PRT_USB_s::txReady
//@{
#define UBX_CFG_PRT_USB_TXREADY_EN_MASK 0x00000001  //!< Mask for field en in bitmask txReady
#define UBX_CFG_PRT_USB_TXREADY_EN_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_TXREADY_EN_MASK)>>0)  //!< Get en from bitmask txReady
#define UBX_CFG_PRT_USB_TXREADY_POL_MASK 0x00000002  //!< Mask for field pol in bitmask txReady
#define UBX_CFG_PRT_USB_TXREADY_POL_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_TXREADY_POL_MASK)>>1)  //!< Get pol from bitmask txReady
#define UBX_CFG_PRT_USB_TXREADY_PIN_MASK 0x0000007C  //!< Mask for field pin in bitmask txReady
#define UBX_CFG_PRT_USB_TXREADY_PIN_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_TXREADY_PIN_MASK)>>2)  //!< Get pin from bitmask txReady
#define UBX_CFG_PRT_USB_TXREADY_THRES_MASK 0x0000FF80  //!< Mask for field thres in bitmask txReady
#define UBX_CFG_PRT_USB_TXREADY_THRES_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_TXREADY_THRES_MASK)>>7)  //!< Get thres from bitmask txReady

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_USB_s::inProtoMask
//@{
#define UBX_CFG_PRT_USB_INPROTOMASK_INUBX_MASK 0x0001  //!< Mask for field inUbx in bitmask inProtoMask
#define UBX_CFG_PRT_USB_INPROTOMASK_INUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_INPROTOMASK_INUBX_MASK)>>0)  //!< Get inUbx from bitmask inProtoMask
#define UBX_CFG_PRT_USB_INPROTOMASK_INNMEA_MASK 0x0002  //!< Mask for field inNmea in bitmask inProtoMask
#define UBX_CFG_PRT_USB_INPROTOMASK_INNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_INPROTOMASK_INNMEA_MASK)>>1)  //!< Get inNmea from bitmask inProtoMask
#define UBX_CFG_PRT_USB_INPROTOMASK_INRTCM_MASK 0x0004  //!< Mask for field inRtcm in bitmask inProtoMask
#define UBX_CFG_PRT_USB_INPROTOMASK_INRTCM_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_INPROTOMASK_INRTCM_MASK)>>2)  //!< Get inRtcm from bitmask inProtoMask
#define UBX_CFG_PRT_USB_INPROTOMASK_INRTCM3_MASK 0x0020  //!< Mask for field inRtcm3 in bitmask inProtoMask
#define UBX_CFG_PRT_USB_INPROTOMASK_INRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_INPROTOMASK_INRTCM3_MASK)>>5)  //!< Get inRtcm3 from bitmask inProtoMask

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_USB_s::outProtoMask
//@{
#define UBX_CFG_PRT_USB_OUTPROTOMASK_OUTUBX_MASK 0x0001  //!< Mask for field outUbx in bitmask outProtoMask
#define UBX_CFG_PRT_USB_OUTPROTOMASK_OUTUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_OUTPROTOMASK_OUTUBX_MASK)>>0)  //!< Get outUbx from bitmask outProtoMask
#define UBX_CFG_PRT_USB_OUTPROTOMASK_OUTNMEA_MASK 0x0002  //!< Mask for field outNmea in bitmask outProtoMask
#define UBX_CFG_PRT_USB_OUTPROTOMASK_OUTNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_OUTPROTOMASK_OUTNMEA_MASK)>>1)  //!< Get outNmea from bitmask outProtoMask
#define UBX_CFG_PRT_USB_OUTPROTOMASK_OUTRTCM3_MASK 0x0020  //!< Mask for field outRtcm3 in bitmask outProtoMask
#define UBX_CFG_PRT_USB_OUTPROTOMASK_OUTRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_USB_OUTPROTOMASK_OUTRTCM3_MASK)>>5)  //!< Get outRtcm3 from bitmask outProtoMask

//@}

//#define UBXID_CFG_PRT 0x0600  // already defined, see above


//================================================================
//! CFG_PRT_SPI: Get/Set
/*!
Port Configuration for SPI Port
Several configurations can be concatenated to one input message. In this case the payload length can be a multiple of the normal length (see the other versions of CFG-PRT). Output messages from the module contain only one configuration unit.


This message's id is #UBXID_CFG_PRT
*/
//================================================================

typedef struct UBX_CFG_PRT_SPI_s
{
    U1  portID;                   //!< Port Identifier Number (= 4 for SPI port)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  txReady;                  //!< TX ready PIN configuration
    X4  mode;                     //!< SPI Mode Flags
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  inProtoMask;              //!< A mask describing which input protocols are active.
    X2  outProtoMask;             //!< A mask describing which output protocols are active.
    X2  flags;                    //!< Flags bit mask
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_PRT_SPI_t, *UBX_CFG_PRT_SPI_pt;


//! \name Bit Definitions for #UBX_CFG_PRT_SPI_s::txReady
//@{
#define UBX_CFG_PRT_SPI_TXREADY_EN_MASK 0x00000001  //!< Mask for field en in bitmask txReady
#define UBX_CFG_PRT_SPI_TXREADY_EN_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_TXREADY_EN_MASK)>>0)  //!< Get en from bitmask txReady
#define UBX_CFG_PRT_SPI_TXREADY_POL_MASK 0x00000002  //!< Mask for field pol in bitmask txReady
#define UBX_CFG_PRT_SPI_TXREADY_POL_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_TXREADY_POL_MASK)>>1)  //!< Get pol from bitmask txReady
#define UBX_CFG_PRT_SPI_TXREADY_PIN_MASK 0x0000007C  //!< Mask for field pin in bitmask txReady
#define UBX_CFG_PRT_SPI_TXREADY_PIN_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_TXREADY_PIN_MASK)>>2)  //!< Get pin from bitmask txReady
#define UBX_CFG_PRT_SPI_TXREADY_THRES_MASK 0x0000FF80  //!< Mask for field thres in bitmask txReady
#define UBX_CFG_PRT_SPI_TXREADY_THRES_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_TXREADY_THRES_MASK)>>7)  //!< Get thres from bitmask txReady

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_SPI_s::mode
//@{
#define UBX_CFG_PRT_SPI_MODE_SPIMODE_MASK 0x00000006  //!< Mask for field spiMode in bitmask mode
#define UBX_CFG_PRT_SPI_MODE_SPIMODE_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_MODE_SPIMODE_MASK)>>1)  //!< Get spiMode from bitmask mode
#define UBX_CFG_PRT_SPI_MODE_FLOWCONTROL_MASK 0x00000040  //!< Mask for field flowControl in bitmask mode
#define UBX_CFG_PRT_SPI_MODE_FLOWCONTROL_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_MODE_FLOWCONTROL_MASK)>>6)  //!< Get flowControl from bitmask mode
#define UBX_CFG_PRT_SPI_MODE_FFCNT_MASK 0x00003F00  //!< Mask for field ffCnt in bitmask mode
#define UBX_CFG_PRT_SPI_MODE_FFCNT_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_MODE_FFCNT_MASK)>>8)  //!< Get ffCnt from bitmask mode

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_SPI_s::inProtoMask
//@{
#define UBX_CFG_PRT_SPI_INPROTOMASK_INUBX_MASK 0x0001  //!< Mask for field inUbx in bitmask inProtoMask
#define UBX_CFG_PRT_SPI_INPROTOMASK_INUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_INPROTOMASK_INUBX_MASK)>>0)  //!< Get inUbx from bitmask inProtoMask
#define UBX_CFG_PRT_SPI_INPROTOMASK_INNMEA_MASK 0x0002  //!< Mask for field inNmea in bitmask inProtoMask
#define UBX_CFG_PRT_SPI_INPROTOMASK_INNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_INPROTOMASK_INNMEA_MASK)>>1)  //!< Get inNmea from bitmask inProtoMask
#define UBX_CFG_PRT_SPI_INPROTOMASK_INRTCM_MASK 0x0004  //!< Mask for field inRtcm in bitmask inProtoMask
#define UBX_CFG_PRT_SPI_INPROTOMASK_INRTCM_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_INPROTOMASK_INRTCM_MASK)>>2)  //!< Get inRtcm from bitmask inProtoMask
#define UBX_CFG_PRT_SPI_INPROTOMASK_INRTCM3_MASK 0x0020  //!< Mask for field inRtcm3 in bitmask inProtoMask
#define UBX_CFG_PRT_SPI_INPROTOMASK_INRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_INPROTOMASK_INRTCM3_MASK)>>5)  //!< Get inRtcm3 from bitmask inProtoMask

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_SPI_s::outProtoMask
//@{
#define UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTUBX_MASK 0x0001  //!< Mask for field outUbx in bitmask outProtoMask
#define UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTUBX_MASK)>>0)  //!< Get outUbx from bitmask outProtoMask
#define UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTNMEA_MASK 0x0002  //!< Mask for field outNmea in bitmask outProtoMask
#define UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTNMEA_MASK)>>1)  //!< Get outNmea from bitmask outProtoMask
#define UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTRTCM3_MASK 0x0020  //!< Mask for field outRtcm3 in bitmask outProtoMask
#define UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_OUTPROTOMASK_OUTRTCM3_MASK)>>5)  //!< Get outRtcm3 from bitmask outProtoMask

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_SPI_s::flags
//@{
#define UBX_CFG_PRT_SPI_FLAGS_EXTENDEDTXTIMEOUT_MASK 0x0002  //!< Mask for field extendedTxTimeout in bitmask flags
#define UBX_CFG_PRT_SPI_FLAGS_EXTENDEDTXTIMEOUT_GET(val)  (U)(((val)&UBX_CFG_PRT_SPI_FLAGS_EXTENDEDTXTIMEOUT_MASK)>>1)  //!< Get extendedTxTimeout from bitmask flags

//@}

//#define UBXID_CFG_PRT 0x0600  // already defined, see above


//================================================================
//! CFG_PRT_DDC: Get/Set
/*!
Port Configuration for DDC Port
Several configurations can be concatenated to one input message. In this case the payload length can be a multiple of the normal length (see the other versions of CFG-PRT). Output messages from the module contain only one configuration unit.


This message's id is #UBXID_CFG_PRT
*/
//================================================================

typedef struct UBX_CFG_PRT_DDC_s
{
    U1  portID;                   //!< Port Identifier Number (= 0 for DDC port)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  txReady;                  //!< TX ready PIN configuration
    X4  mode;                     //!< DDC Mode Flags
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  inProtoMask;              //!< A mask describing which input protocols are active.
    X2  outProtoMask;             //!< A mask describing which output protocols are active.
    X2  flags;                    //!< Flags bit mask
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_PRT_DDC_t, *UBX_CFG_PRT_DDC_pt;


//! \name Bit Definitions for #UBX_CFG_PRT_DDC_s::txReady
//@{
#define UBX_CFG_PRT_DDC_TXREADY_EN_MASK 0x00000001  //!< Mask for field en in bitmask txReady
#define UBX_CFG_PRT_DDC_TXREADY_EN_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_TXREADY_EN_MASK)>>0)  //!< Get en from bitmask txReady
#define UBX_CFG_PRT_DDC_TXREADY_POL_MASK 0x00000002  //!< Mask for field pol in bitmask txReady
#define UBX_CFG_PRT_DDC_TXREADY_POL_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_TXREADY_POL_MASK)>>1)  //!< Get pol from bitmask txReady
#define UBX_CFG_PRT_DDC_TXREADY_PIN_MASK 0x0000007C  //!< Mask for field pin in bitmask txReady
#define UBX_CFG_PRT_DDC_TXREADY_PIN_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_TXREADY_PIN_MASK)>>2)  //!< Get pin from bitmask txReady
#define UBX_CFG_PRT_DDC_TXREADY_THRES_MASK 0x0000FF80  //!< Mask for field thres in bitmask txReady
#define UBX_CFG_PRT_DDC_TXREADY_THRES_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_TXREADY_THRES_MASK)>>7)  //!< Get thres from bitmask txReady

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_DDC_s::mode
//@{
#define UBX_CFG_PRT_DDC_MODE_SLAVEADDR_MASK 0x000000FE  //!< Mask for field slaveAddr in bitmask mode
#define UBX_CFG_PRT_DDC_MODE_SLAVEADDR_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_MODE_SLAVEADDR_MASK)>>1)  //!< Get slaveAddr from bitmask mode

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_DDC_s::inProtoMask
//@{
#define UBX_CFG_PRT_DDC_INPROTOMASK_INUBX_MASK 0x0001  //!< Mask for field inUbx in bitmask inProtoMask
#define UBX_CFG_PRT_DDC_INPROTOMASK_INUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_INPROTOMASK_INUBX_MASK)>>0)  //!< Get inUbx from bitmask inProtoMask
#define UBX_CFG_PRT_DDC_INPROTOMASK_INNMEA_MASK 0x0002  //!< Mask for field inNmea in bitmask inProtoMask
#define UBX_CFG_PRT_DDC_INPROTOMASK_INNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_INPROTOMASK_INNMEA_MASK)>>1)  //!< Get inNmea from bitmask inProtoMask
#define UBX_CFG_PRT_DDC_INPROTOMASK_INRTCM_MASK 0x0004  //!< Mask for field inRtcm in bitmask inProtoMask
#define UBX_CFG_PRT_DDC_INPROTOMASK_INRTCM_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_INPROTOMASK_INRTCM_MASK)>>2)  //!< Get inRtcm from bitmask inProtoMask
#define UBX_CFG_PRT_DDC_INPROTOMASK_INRTCM3_MASK 0x0020  //!< Mask for field inRtcm3 in bitmask inProtoMask
#define UBX_CFG_PRT_DDC_INPROTOMASK_INRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_INPROTOMASK_INRTCM3_MASK)>>5)  //!< Get inRtcm3 from bitmask inProtoMask

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_DDC_s::outProtoMask
//@{
#define UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTUBX_MASK 0x0001  //!< Mask for field outUbx in bitmask outProtoMask
#define UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTUBX_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTUBX_MASK)>>0)  //!< Get outUbx from bitmask outProtoMask
#define UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTNMEA_MASK 0x0002  //!< Mask for field outNmea in bitmask outProtoMask
#define UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTNMEA_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTNMEA_MASK)>>1)  //!< Get outNmea from bitmask outProtoMask
#define UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTRTCM3_MASK 0x0020  //!< Mask for field outRtcm3 in bitmask outProtoMask
#define UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTRTCM3_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_OUTPROTOMASK_OUTRTCM3_MASK)>>5)  //!< Get outRtcm3 from bitmask outProtoMask

//@}
//! \name Bit Definitions for #UBX_CFG_PRT_DDC_s::flags
//@{
#define UBX_CFG_PRT_DDC_FLAGS_EXTENDEDTXTIMEOUT_MASK 0x0002  //!< Mask for field extendedTxTimeout in bitmask flags
#define UBX_CFG_PRT_DDC_FLAGS_EXTENDEDTXTIMEOUT_GET(val)  (U)(((val)&UBX_CFG_PRT_DDC_FLAGS_EXTENDEDTXTIMEOUT_MASK)>>1)  //!< Get extendedTxTimeout from bitmask flags

//@}

//#define UBXID_CFG_PRT 0x0600  // already defined, see above


//================================================================
//! CFG_PWR_DATA1: Set
/*!
Put receiver in a defined power state.
-

   \note: This message is deprecated in protocol versions greater than 17. Use <rcb href=\"UBX-CFG-RST'>UBX-CFG-RST</rcb> for GNSS start/stop and <rcb href=\"UBX-RXM-PMREQ'>UBX-RXM-PMREQ</rcb> for software backup.

This message's id is #UBXID_CFG_PWR
*/
//================================================================

typedef struct UBX_CFG_PWR_DATA1_s
{
    U1  version;                  //!< Message version (1 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  state;                    //!< Enter system state

} UBX_CFG_PWR_DATA1_t, *UBX_CFG_PWR_DATA1_pt;


#define UBXID_CFG_PWR 0x0657 //!< message id for CFG-PWR


//================================================================
//! CFG_RATE_DATA0: Get/Set
/*!
Navigation/Measurement Rate Settings
This message allows the user to alter the rate at which navigation solutions (and the measurements that they depend on) are generated by the receiver. The calculation of the navigation solution will always be aligned to the top of a second zero (first second of the week) of the configured reference time system.
For protocol version 18 and later the navigation period is an integer multiple of the measurement period.
* Each measurement triggers the measurements generation and <rc href=\"UBX-RXM-RAWX'>raw data output</rc>.
* The navRate value defines that every nth measurement triggers a navigation epoch.
* The update rate has a direct influence on the power consumption. The more fixes that are required, the more CPU power and communication resources are required.
* For most applications a 1 Hz update rate would be sufficient.
* When using Power Save Mode, measurement and navigation rate can differ from the values configured here. See <r href=\"PM-DESC-MEASNAVRATE'>Measurement and navigation rate with Power Save Mode</r> for details.

   \note: This feature is not supported for the FTS product variant.

This message's id is #UBXID_CFG_RATE
*/
//================================================================

typedef struct UBX_CFG_RATE_DATA0_s
{
    U2  measRate;                 //!< The elapsed time between GNSS measurements, which defines the rate, e.g. 100ms => 10Hz, 1000ms => 1Hz, 10000ms => 0.1Hz
    U2  navRate;                  //!< The ratio between the number of measurements and the number of navigation solutions, e.g. 5 means five measurements for every navigation solution. Max. value is 127. (This parameter is ignored and the navRate is fixed to 1 in <r href='FIRMWARE-PROTOCOLVERSION'>protocol versions less than 18</r>)
    U2  timeRef;                  //!< The time system to which measurements are aligned:

} UBX_CFG_RATE_DATA0_t, *UBX_CFG_RATE_DATA0_pt;


#define UBXID_CFG_RATE 0x0608 //!< message id for CFG-RATE


//================================================================
//! CFG_RINV_DATA0: Get/Set
/*!
Contents of Remote Inventory
If <i>N</i> is greater than 30, the excess bytes are discarded. In future firmware versions, this limit may change.


This message's id is #UBXID_CFG_RINV
*/
//================================================================

//! Optional Sub-Structure of #UBX_CFG_RINV_DATA0_t
typedef struct UBX_CFG_RINV_DATA0_DATA_s
{
    U1  data;                     //!< Data to store/stored in Remote Inventory

} UBX_CFG_RINV_DATA0_DATA_t, *UBX_CFG_RINV_DATA0_DATA_pt;



typedef struct UBX_CFG_RINV_DATA0_s
{
    X1  flags;                    //!< Flags
    //REPEAT: UBX_CFG_RINV_DATA0_DATA_t repeat0[N];

} UBX_CFG_RINV_DATA0_t, *UBX_CFG_RINV_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_RINV_DATA0_s::flags
//@{
#define UBX_CFG_RINV_DATA0_FLAGS_DUMP_MASK 0x1  //!< Mask for field dump in bitmask flags
#define UBX_CFG_RINV_DATA0_FLAGS_DUMP_GET(val)  (U)(((val)&UBX_CFG_RINV_DATA0_FLAGS_DUMP_MASK)>>0)  //!< Get dump from bitmask flags
#define UBX_CFG_RINV_DATA0_FLAGS_BINARY_MASK 0x2  //!< Mask for field binary in bitmask flags
#define UBX_CFG_RINV_DATA0_FLAGS_BINARY_GET(val)  (U)(((val)&UBX_CFG_RINV_DATA0_FLAGS_BINARY_MASK)>>1)  //!< Get binary from bitmask flags

//@}

#define UBXID_CFG_RINV 0x0634 //!< message id for CFG-RINV


//================================================================
//! CFG_RST_DATA3: Command
/*!
Reset Receiver / Clear Backup Data Structures
Don't expect this message to be acknowledged by the receiver.
* Newer FW version won't acknowledge this message at all.
* Older FW version will acknowledge this message but the acknowledge may not be sent completely before the receiver is reset.


This message's id is #UBXID_CFG_RST
*/
//================================================================

typedef struct UBX_CFG_RST_DATA3_s
{
    X2  navBbrMask;               //!< BBR Sections to clear. The following Special Sets apply:
    U1  resetMode;                //!< Reset Type
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_CFG_RST_DATA3_t, *UBX_CFG_RST_DATA3_pt;


//! \name Bit Definitions for #UBX_CFG_RST_DATA3_s::navBbrMask
//@{
#define UBX_CFG_RST_DATA3_NAVBBRMASK_EPH_MASK 0x0001  //!< Mask for field eph in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_EPH_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_EPH_MASK)>>0)  //!< Get eph from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_ALM_MASK 0x0002  //!< Mask for field alm in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_ALM_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_ALM_MASK)>>1)  //!< Get alm from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_HEALTH_MASK 0x0004  //!< Mask for field health in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_HEALTH_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_HEALTH_MASK)>>2)  //!< Get health from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_KLOB_MASK 0x0008  //!< Mask for field klob in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_KLOB_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_KLOB_MASK)>>3)  //!< Get klob from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_POS_MASK 0x0010  //!< Mask for field pos in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_POS_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_POS_MASK)>>4)  //!< Get pos from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_CLKD_MASK 0x0020  //!< Mask for field clkd in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_CLKD_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_CLKD_MASK)>>5)  //!< Get clkd from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_OSC_MASK 0x0040  //!< Mask for field osc in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_OSC_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_OSC_MASK)>>6)  //!< Get osc from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_UTC_MASK 0x0080  //!< Mask for field utc in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_UTC_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_UTC_MASK)>>7)  //!< Get utc from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_RTC_MASK 0x0100  //!< Mask for field rtc in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_RTC_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_RTC_MASK)>>8)  //!< Get rtc from bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_AOP_MASK 0x8000  //!< Mask for field aop in bitmask navBbrMask
#define UBX_CFG_RST_DATA3_NAVBBRMASK_AOP_GET(val)  (U)(((val)&UBX_CFG_RST_DATA3_NAVBBRMASK_AOP_MASK)>>15)  //!< Get aop from bitmask navBbrMask

//@}

#define UBXID_CFG_RST 0x0604 //!< message id for CFG-RST


//================================================================
//! CFG_RXM_DATA1: Get/Set
/*!
RXM configuration
For a detailed description see section <r href=\"CFG-PM-DESC'>Power Management</r>.
Note that Power Save Mode cannot be selected when the receiver is configured to process GLONASS signals (using <rc href=\"UBX-CFG-GNSS'>CFG-GNSS</rc>).


This message's id is #UBXID_CFG_RXM
*/
//================================================================

typedef struct UBX_CFG_RXM_DATA1_s
{
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  lpMode;                   //!< Low Power Mode

} UBX_CFG_RXM_DATA1_t, *UBX_CFG_RXM_DATA1_pt;


#define UBXID_CFG_RXM 0x0611 //!< message id for CFG-RXM


//================================================================
//! CFG_RXM_DATA2: Get/Set
/*!
RXM configuration
For a detailed description see section <r href=\"CFG-PM-DESC'>Power Management</r>.


This message's id is #UBXID_CFG_RXM
*/
//================================================================

typedef struct UBX_CFG_RXM_DATA2_s
{
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  lpMode;                   //!< Low Power Mode

} UBX_CFG_RXM_DATA2_t, *UBX_CFG_RXM_DATA2_pt;


//#define UBXID_CFG_RXM 0x0611  // already defined, see above


//================================================================
//! CFG_SBAS_U5: Get/Set
/*!
SBAS Configuration
This message configures the SBAS receiver subsystem (i.e. WAAS, EGNOS, MSAS). See the <r href=\"CFG-SBAS-DESC'>SBAS Configuration Settings Description</r> for a detailed description of how these settings affect receiver operation.


This message's id is #UBXID_CFG_SBAS
*/
//================================================================

typedef struct UBX_CFG_SBAS_U5_s
{
    X1  mode;                     //!< SBAS Mode
    X1  usage;                    //!< SBAS Usage
    U1  maxSBAS;                  //!< Maximum Number of SBAS prioritized tracking channels (valid range: 0 - 3) to use (obsolete and superseeded by UBX-CFG-GNSS in <r href='FIRMWARE-PROTOCOLVERSION'>protocol versions 14+</r>).
    X1  scanmode2;                //!< Continuation of scanmode bitmask below
    X4  scanmode1;                //!< Which SBAS PRN numbers to search for (Bitmask)

} UBX_CFG_SBAS_U5_t, *UBX_CFG_SBAS_U5_pt;


//! \name Bit Definitions for #UBX_CFG_SBAS_U5_s::mode
//@{
#define UBX_CFG_SBAS_U5_MODE_ENABLED_MASK 0x01  //!< Mask for field enabled in bitmask mode
#define UBX_CFG_SBAS_U5_MODE_ENABLED_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_MODE_ENABLED_MASK)>>0)  //!< Get enabled from bitmask mode
#define UBX_CFG_SBAS_U5_MODE_TEST_MASK 0x02  //!< Mask for field test in bitmask mode
#define UBX_CFG_SBAS_U5_MODE_TEST_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_MODE_TEST_MASK)>>1)  //!< Get test from bitmask mode

//@}
//! \name Bit Definitions for #UBX_CFG_SBAS_U5_s::usage
//@{
#define UBX_CFG_SBAS_U5_USAGE_RANGE_MASK 0x01  //!< Mask for field range in bitmask usage
#define UBX_CFG_SBAS_U5_USAGE_RANGE_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_USAGE_RANGE_MASK)>>0)  //!< Get range from bitmask usage
#define UBX_CFG_SBAS_U5_USAGE_DIFFCORR_MASK 0x02  //!< Mask for field diffCorr in bitmask usage
#define UBX_CFG_SBAS_U5_USAGE_DIFFCORR_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_USAGE_DIFFCORR_MASK)>>1)  //!< Get diffCorr from bitmask usage
#define UBX_CFG_SBAS_U5_USAGE_INTEGRITY_MASK 0x04  //!< Mask for field integrity in bitmask usage
#define UBX_CFG_SBAS_U5_USAGE_INTEGRITY_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_USAGE_INTEGRITY_MASK)>>2)  //!< Get integrity from bitmask usage

//@}
//! \name Bit Definitions for #UBX_CFG_SBAS_U5_s::scanmode2
//@{
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN152_MASK 0x01  //!< Mask for field PRN152 in bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN152_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE2_PRN152_MASK)>>0)  //!< Get PRN152 from bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN153_MASK 0x02  //!< Mask for field PRN153 in bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN153_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE2_PRN153_MASK)>>1)  //!< Get PRN153 from bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN154_MASK 0x04  //!< Mask for field PRN154 in bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN154_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE2_PRN154_MASK)>>2)  //!< Get PRN154 from bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN155_MASK 0x08  //!< Mask for field PRN155 in bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN155_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE2_PRN155_MASK)>>3)  //!< Get PRN155 from bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN156_MASK 0x10  //!< Mask for field PRN156 in bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN156_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE2_PRN156_MASK)>>4)  //!< Get PRN156 from bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN157_MASK 0x20  //!< Mask for field PRN157 in bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN157_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE2_PRN157_MASK)>>5)  //!< Get PRN157 from bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN158_MASK 0x40  //!< Mask for field PRN158 in bitmask scanmode2
#define UBX_CFG_SBAS_U5_SCANMODE2_PRN158_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE2_PRN158_MASK)>>6)  //!< Get PRN158 from bitmask scanmode2

//@}
//! \name Bit Definitions for #UBX_CFG_SBAS_U5_s::scanmode1
//@{
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN120_MASK 0x00000001  //!< Mask for field PRN120 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN120_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN120_MASK)>>0)  //!< Get PRN120 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN121_MASK 0x00000002  //!< Mask for field PRN121 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN121_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN121_MASK)>>1)  //!< Get PRN121 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN122_MASK 0x00000004  //!< Mask for field PRN122 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN122_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN122_MASK)>>2)  //!< Get PRN122 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN123_MASK 0x00000008  //!< Mask for field PRN123 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN123_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN123_MASK)>>3)  //!< Get PRN123 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN124_MASK 0x00000010  //!< Mask for field PRN124 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN124_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN124_MASK)>>4)  //!< Get PRN124 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN125_MASK 0x00000020  //!< Mask for field PRN125 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN125_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN125_MASK)>>5)  //!< Get PRN125 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN126_MASK 0x00000040  //!< Mask for field PRN126 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN126_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN126_MASK)>>6)  //!< Get PRN126 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN127_MASK 0x00000080  //!< Mask for field PRN127 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN127_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN127_MASK)>>7)  //!< Get PRN127 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN128_MASK 0x00000100  //!< Mask for field PRN128 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN128_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN128_MASK)>>8)  //!< Get PRN128 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN129_MASK 0x00000200  //!< Mask for field PRN129 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN129_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN129_MASK)>>9)  //!< Get PRN129 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN130_MASK 0x00000400  //!< Mask for field PRN130 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN130_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN130_MASK)>>10)  //!< Get PRN130 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN131_MASK 0x00000800  //!< Mask for field PRN131 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN131_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN131_MASK)>>11)  //!< Get PRN131 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN132_MASK 0x00001000  //!< Mask for field PRN132 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN132_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN132_MASK)>>12)  //!< Get PRN132 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN133_MASK 0x00002000  //!< Mask for field PRN133 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN133_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN133_MASK)>>13)  //!< Get PRN133 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN134_MASK 0x00004000  //!< Mask for field PRN134 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN134_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN134_MASK)>>14)  //!< Get PRN134 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN135_MASK 0x00008000  //!< Mask for field PRN135 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN135_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN135_MASK)>>15)  //!< Get PRN135 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN136_MASK 0x00010000  //!< Mask for field PRN136 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN136_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN136_MASK)>>16)  //!< Get PRN136 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN137_MASK 0x00020000  //!< Mask for field PRN137 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN137_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN137_MASK)>>17)  //!< Get PRN137 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN138_MASK 0x00040000  //!< Mask for field PRN138 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN138_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN138_MASK)>>18)  //!< Get PRN138 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN139_MASK 0x00080000  //!< Mask for field PRN139 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN139_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN139_MASK)>>19)  //!< Get PRN139 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN140_MASK 0x00100000  //!< Mask for field PRN140 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN140_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN140_MASK)>>20)  //!< Get PRN140 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN141_MASK 0x00200000  //!< Mask for field PRN141 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN141_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN141_MASK)>>21)  //!< Get PRN141 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN142_MASK 0x00400000  //!< Mask for field PRN142 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN142_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN142_MASK)>>22)  //!< Get PRN142 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN143_MASK 0x00800000  //!< Mask for field PRN143 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN143_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN143_MASK)>>23)  //!< Get PRN143 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN144_MASK 0x01000000  //!< Mask for field PRN144 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN144_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN144_MASK)>>24)  //!< Get PRN144 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN145_MASK 0x02000000  //!< Mask for field PRN145 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN145_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN145_MASK)>>25)  //!< Get PRN145 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN146_MASK 0x04000000  //!< Mask for field PRN146 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN146_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN146_MASK)>>26)  //!< Get PRN146 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN147_MASK 0x08000000  //!< Mask for field PRN147 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN147_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN147_MASK)>>27)  //!< Get PRN147 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN148_MASK 0x10000000  //!< Mask for field PRN148 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN148_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN148_MASK)>>28)  //!< Get PRN148 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN149_MASK 0x20000000  //!< Mask for field PRN149 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN149_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN149_MASK)>>29)  //!< Get PRN149 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN150_MASK 0x40000000  //!< Mask for field PRN150 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN150_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN150_MASK)>>30)  //!< Get PRN150 from bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN151_MASK 0x80000000  //!< Mask for field PRN151 in bitmask scanmode1
#define UBX_CFG_SBAS_U5_SCANMODE1_PRN151_GET(val)  (U)(((val)&UBX_CFG_SBAS_U5_SCANMODE1_PRN151_MASK)>>31)  //!< Get PRN151 from bitmask scanmode1

//@}

#define UBXID_CFG_SBAS 0x0616 //!< message id for CFG-SBAS


//================================================================
//! CFG_SMGR_DATA0: Get/Set
/*!
Synchronization manager configuration
-


This message's id is #UBXID_CFG_SMGR
*/
//================================================================

typedef struct UBX_CFG_SMGR_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  minGNSSFix;               //!< Minimum number of GNSS fixes before we commit to use it as a source
    U2  maxFreqChangeRate;        //!< Maximum frequency change rate during disciplining. Must not exceed 30ppb/s
    U2  maxPhaseCorrRate;         //!< Maximum phase correction rate in coherent time pulse mode.
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  freqTolerance;            //!< Limit of possible deviation from nominal before <rc href=\"UBX-TIM-TOS-DATA0'>TIM-TOS</rc> indicates that frequency is out of tolerance
    U2  timeTolerance;            //!< Limit of possible deviation from nominal before <rc href=\"UBX-TIM-TOS-DATA0'>TIM-TOS</rc> indicates that time pulse is out of tolerance
    X2  messageCfg;               //!< Sync manager message configuration
    U2  maxSlewRate;              //!< Maximum slew rate, the maximum time correction that shall be applied between locked pulses in corrective time pulse mode.
    X4  flags;                    //!< Flags

} UBX_CFG_SMGR_DATA0_t, *UBX_CFG_SMGR_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_SMGR_DATA0_s::messageCfg
//@{
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASINTERNAL_MASK 0x0001  //!< Mask for field measInternal in bitmask messageCfg
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASINTERNAL_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASINTERNAL_MASK)>>0)  //!< Get measInternal from bitmask messageCfg
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASGNSS_MASK 0x0002  //!< Mask for field measGNSS in bitmask messageCfg
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASGNSS_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASGNSS_MASK)>>1)  //!< Get measGNSS from bitmask messageCfg
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASEXTINT0_MASK 0x0004  //!< Mask for field measEXTINT0 in bitmask messageCfg
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASEXTINT0_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASEXTINT0_MASK)>>2)  //!< Get measEXTINT0 from bitmask messageCfg
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASEXTINT1_MASK 0x0008  //!< Mask for field measEXTINT1 in bitmask messageCfg
#define UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASEXTINT1_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_MESSAGECFG_MEASEXTINT1_MASK)>>3)  //!< Get measEXTINT1 from bitmask messageCfg

//@}
//! \name Bit Definitions for #UBX_CFG_SMGR_DATA0_s::flags
//@{
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEINTERNAL_MASK 0x0001  //!< Mask for field disableInternal in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEINTERNAL_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_DISABLEINTERNAL_MASK)>>0)  //!< Get disableInternal from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEEXTERNAL_MASK 0x0002  //!< Mask for field disableExternal in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEEXTERNAL_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_DISABLEEXTERNAL_MASK)>>1)  //!< Get disableExternal from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_PREFERENCEMODE_MASK 0x0004  //!< Mask for field preferenceMode in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_PREFERENCEMODE_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_PREFERENCEMODE_MASK)>>2)  //!< Get preferenceMode from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEGNSS_MASK 0x0008  //!< Mask for field enableGNSS in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEGNSS_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_ENABLEGNSS_MASK)>>3)  //!< Get enableGNSS from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEEXTINT0_MASK 0x0010  //!< Mask for field enableEXTINT0 in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEEXTINT0_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_ENABLEEXTINT0_MASK)>>4)  //!< Get enableEXTINT0 from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEEXTINT1_MASK 0x0020  //!< Mask for field enableEXTINT1 in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEEXTINT1_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_ENABLEEXTINT1_MASK)>>5)  //!< Get enableEXTINT1 from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEHOSTMEASINT_MASK 0x0040  //!< Mask for field enableHostMeasInt in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEHOSTMEASINT_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_ENABLEHOSTMEASINT_MASK)>>6)  //!< Get enableHostMeasInt from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEHOSTMEASEXT_MASK 0x0080  //!< Mask for field enableHostMeasExt in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ENABLEHOSTMEASEXT_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_ENABLEHOSTMEASEXT_MASK)>>7)  //!< Get enableHostMeasExt from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_USEANYFIX_MASK 0x0400  //!< Mask for field useAnyFix in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_USEANYFIX_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_USEANYFIX_MASK)>>10)  //!< Get useAnyFix from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEMAXSLEWRATE_MASK 0x0800  //!< Mask for field disableMaxSlewRate in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEMAXSLEWRATE_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_DISABLEMAXSLEWRATE_MASK)>>11)  //!< Get disableMaxSlewRate from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ISSUEFREQWARNING_MASK 0x1000  //!< Mask for field issueFreqWarning in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ISSUEFREQWARNING_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_ISSUEFREQWARNING_MASK)>>12)  //!< Get issueFreqWarning from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ISSUETIMEWARNING_MASK 0x2000  //!< Mask for field issueTimeWarning in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_ISSUETIMEWARNING_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_ISSUETIMEWARNING_MASK)>>13)  //!< Get issueTimeWarning from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_TPCOHERENT_MASK 0xc000  //!< Mask for field TPCoherent in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_TPCOHERENT_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_TPCOHERENT_MASK)>>14)  //!< Get TPCoherent from bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEOFFSET_MASK 0x10000  //!< Mask for field disableOffset in bitmask flags
#define UBX_CFG_SMGR_DATA0_FLAGS_DISABLEOFFSET_GET(val)  (U)(((val)&UBX_CFG_SMGR_DATA0_FLAGS_DISABLEOFFSET_MASK)>>16)  //!< Get disableOffset from bitmask flags

//@}

#define UBXID_CFG_SMGR 0x0662 //!< message id for CFG-SMGR


//================================================================
//! CFG_TMODE2_DATA0: Get/Set
/*!
Time Mode Settings 2
See the <r href=\"CFG-TMODE-DESC'>Time Mode Description</r> for details. This message replaces the deprecated <rc href=\"UBX-CFG-TMODE'>UBX-CFG-TMODE</rc> message.

   \note: This message is available only for timing receivers

This message's id is #UBXID_CFG_TMODE2
*/
//================================================================

typedef struct UBX_CFG_TMODE2_DATA0_s
{
    U1  timeMode;                 //!< Time Transfer Mode:
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X2  flags;                    //!< Time mode flags
    I4  ecefXOrLat;               //!< WGS84 ECEF X coordinate or latitude, depending on flags above
    I4  ecefYOrLon;               //!< WGS84 ECEF Y coordinate or longitude, depending on flags above
    I4  ecefZOrAlt;               //!< WGS84 ECEF Z coordinate or altitude, depending on flags above
    U4  fixedPosAcc;              //!< Fixed position 3D accuracy
    U4  svinMinDur;               //!< Survey-in minimum duration
    U4  svinAccLimit;             //!< Survey-in position accuracy limit

} UBX_CFG_TMODE2_DATA0_t, *UBX_CFG_TMODE2_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_TMODE2_DATA0_s::flags
//@{
#define UBX_CFG_TMODE2_DATA0_FLAGS_LLA_MASK 0x01  //!< Mask for field lla in bitmask flags
#define UBX_CFG_TMODE2_DATA0_FLAGS_LLA_GET(val)  (U)(((val)&UBX_CFG_TMODE2_DATA0_FLAGS_LLA_MASK)>>0)  //!< Get lla from bitmask flags
#define UBX_CFG_TMODE2_DATA0_FLAGS_ALTINV_MASK 0x02  //!< Mask for field altInv in bitmask flags
#define UBX_CFG_TMODE2_DATA0_FLAGS_ALTINV_GET(val)  (U)(((val)&UBX_CFG_TMODE2_DATA0_FLAGS_ALTINV_MASK)>>1)  //!< Get altInv from bitmask flags

//@}

#define UBXID_CFG_TMODE2 0x063D //!< message id for CFG-TMODE2


//================================================================
//! CFG_TP5_POLL0: Poll Request
/*!
Poll Time Pulse Parameters for Time Pulse 0
Sending this (empty / no-payload) message to the receiver results in the receiver returning a message of type <rc href=\"UBX-CFG-TP5'>CFG-TP5</rc> with a payload as defined below for timepulse 0.


This message's id is #UBXID_CFG_TP5
*/
//================================================================

typedef struct UBX_CFG_TP5_POLL0_s
{

} UBX_CFG_TP5_POLL0_t, *UBX_CFG_TP5_POLL0_pt;


#define UBXID_CFG_TP5 0x0631 //!< message id for CFG-TP5


//================================================================
//! CFG_TP5_POLLIX: Poll Request
/*!
Poll Time Pulse Parameters
Sending this message to the receiver results in the receiver returning a message of type <rc href=\"UBX-CFG-TP5'>CFG-TP5</rc> with a payload as defined below for the specified time pulse.


This message's id is #UBXID_CFG_TP5
*/
//================================================================

typedef struct UBX_CFG_TP5_POLLIX_s
{
    U1  tpIdx;                    //!< Time pulse selection (0 = TIMEPULSE, 1 = TIMEPULSE2)

} UBX_CFG_TP5_POLLIX_t, *UBX_CFG_TP5_POLLIX_pt;


//#define UBXID_CFG_TP5 0x0631  // already defined, see above


//================================================================
//! CFG_TP5_DATA0: Get/Set
/*!
Time Pulse Parameters
This message is used to get/set time pulse parameters. For more information see section <r href=\"CFG-TP5-DESC'>Time pulse</r>.


This message's id is #UBXID_CFG_TP5
*/
//================================================================

typedef struct UBX_CFG_TP5_DATA0_s
{
    U1  tpIdx;                    //!< Time pulse selection (0 = TIMEPULSE, 1 = TIMEPULSE2)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I2  antCableDelay;            //!< Antenna cable delay
    I2  rfGroupDelay;             //!< RF group delay
    U4  freqPeriod;               //!< Frequency or period time, depending on setting of bit 'isFreq'
    U4  freqPeriodLock;           //!< Frequency or period time when locked to GPS time, only used if 'lockedOtherSet' is set
    U4  pulseLenRatio;            //!< Pulse length or duty cycle, depending on 'isLength'
    U4  pulseLenRatioLock;        //!< Pulse length or duty cycle when locked to GPS time, only used if 'lockedOtherSet' is set
    I4  userConfigDelay;          //!< User configurable time pulse delay
    X4  flags;                    //!< Configuration flags

} UBX_CFG_TP5_DATA0_t, *UBX_CFG_TP5_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_TP5_DATA0_s::flags
//@{
#define UBX_CFG_TP5_DATA0_FLAGS_ACTIVE_MASK 0x01  //!< Mask for field active in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_ACTIVE_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_ACTIVE_MASK)>>0)  //!< Get active from bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_LOCKGPSFREQ_MASK 0x02  //!< Mask for field lockGpsFreq in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_LOCKGPSFREQ_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_LOCKGPSFREQ_MASK)>>1)  //!< Get lockGpsFreq from bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_LOCKEDOTHERSET_MASK 0x04  //!< Mask for field lockedOtherSet in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_LOCKEDOTHERSET_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_LOCKEDOTHERSET_MASK)>>2)  //!< Get lockedOtherSet from bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_ISFREQ_MASK 0x08  //!< Mask for field isFreq in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_ISFREQ_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_ISFREQ_MASK)>>3)  //!< Get isFreq from bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_ISLENGTH_MASK 0x10  //!< Mask for field isLength in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_ISLENGTH_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_ISLENGTH_MASK)>>4)  //!< Get isLength from bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_ALIGNTOTOW_MASK 0x20  //!< Mask for field alignToTow in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_ALIGNTOTOW_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_ALIGNTOTOW_MASK)>>5)  //!< Get alignToTow from bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_POLARITY_MASK 0x40  //!< Mask for field polarity in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_POLARITY_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_POLARITY_MASK)>>6)  //!< Get polarity from bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_GRIDUTCGPS_MASK 0x80  //!< Mask for field gridUtcGps in bitmask flags
#define UBX_CFG_TP5_DATA0_FLAGS_GRIDUTCGPS_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA0_FLAGS_GRIDUTCGPS_MASK)>>7)  //!< Get gridUtcGps from bitmask flags

//@}

//#define UBXID_CFG_TP5 0x0631  // already defined, see above


//================================================================
//! CFG_TP5_DATA1: Get/Set
/*!
Time Pulse Parameters
This message is used to get/set time pulse parameters. For more information see section <r href=\"CFG-TP5-DESC'>Time pulse</r>.


This message's id is #UBXID_CFG_TP5
*/
//================================================================

typedef struct UBX_CFG_TP5_DATA1_s
{
    U1  tpIdx;                    //!< Time pulse selection (0 = TIMEPULSE, 1 = TIMEPULSE2)
    U1  version;                  //!< Message version (0x01 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I2  antCableDelay;            //!< Antenna cable delay
    I2  rfGroupDelay;             //!< RF group delay
    U4  freqPeriod;               //!< Frequency or period time, depending on setting of bit 'isFreq'
    U4  freqPeriodLock;           //!< Frequency or period time when locked to GNSS time, only used if 'lockedOtherSet' is set
    U4  pulseLenRatio;            //!< Pulse length or duty cycle, depending on 'isLength'
    U4  pulseLenRatioLock;        //!< Pulse length or duty cycle when locked to GNSS time, only used if 'lockedOtherSet' is set
    I4  userConfigDelay;          //!< User configurable time pulse delay
    X4  flags;                    //!< Configuration flags

} UBX_CFG_TP5_DATA1_t, *UBX_CFG_TP5_DATA1_pt;


//! \name Bit Definitions for #UBX_CFG_TP5_DATA1_s::flags
//@{
#define UBX_CFG_TP5_DATA1_FLAGS_ACTIVE_MASK 0x01  //!< Mask for field active in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_ACTIVE_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_ACTIVE_MASK)>>0)  //!< Get active from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_LOCKGNSSFREQ_MASK 0x02  //!< Mask for field lockGnssFreq in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_LOCKGNSSFREQ_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_LOCKGNSSFREQ_MASK)>>1)  //!< Get lockGnssFreq from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_LOCKEDOTHERSET_MASK 0x04  //!< Mask for field lockedOtherSet in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_LOCKEDOTHERSET_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_LOCKEDOTHERSET_MASK)>>2)  //!< Get lockedOtherSet from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_ISFREQ_MASK 0x08  //!< Mask for field isFreq in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_ISFREQ_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_ISFREQ_MASK)>>3)  //!< Get isFreq from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_ISLENGTH_MASK 0x10  //!< Mask for field isLength in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_ISLENGTH_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_ISLENGTH_MASK)>>4)  //!< Get isLength from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_ALIGNTOTOW_MASK 0x20  //!< Mask for field alignToTow in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_ALIGNTOTOW_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_ALIGNTOTOW_MASK)>>5)  //!< Get alignToTow from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_POLARITY_MASK 0x40  //!< Mask for field polarity in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_POLARITY_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_POLARITY_MASK)>>6)  //!< Get polarity from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_GRIDUTCGNSS_MASK 0x780  //!< Mask for field gridUtcGnss in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_GRIDUTCGNSS_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_GRIDUTCGNSS_MASK)>>7)  //!< Get gridUtcGnss from bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_SYNCMODE_MASK 0x3800  //!< Mask for field syncMode in bitmask flags
#define UBX_CFG_TP5_DATA1_FLAGS_SYNCMODE_GET(val)  (U)(((val)&UBX_CFG_TP5_DATA1_FLAGS_SYNCMODE_MASK)>>11)  //!< Get syncMode from bitmask flags

//@}

//#define UBXID_CFG_TP5 0x0631  // already defined, see above


//================================================================
//! CFG_TXSLOT_DATA0: Set
/*!
TX buffer time slots configuration
This message configures how transmit time slots are defined for the receiver interfaces. These time slots are relative to the chosen time pulse. A receiver that supports this message offers 3 time slots: nr. 0, 1 and 2. These time pulses follow each other and their associated priorities decrease in this order. The end of each can be specified in this message, the beginning is when the circularly previous slot ends (i.e. slot 0 starts when slot 2 finishes).


This message's id is #UBXID_CFG_TXSLOT
*/
//================================================================

//!  Sub-Structure of #UBX_CFG_TXSLOT_DATA0_t
typedef struct UBX_CFG_TXSLOT_DATA0_END_s
{
    U4  end;                      //!< End of timeslot in milliseconds after time pulse

} UBX_CFG_TXSLOT_DATA0_END_t, *UBX_CFG_TXSLOT_DATA0_END_pt;



typedef struct UBX_CFG_TXSLOT_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    X1  enable;                   //!< Bitfield of ports for which the slots are enabled.
    U1  refTp;                    //!< Reference timepulse source
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    UBX_CFG_TXSLOT_DATA0_END_t repeat0[3];

} UBX_CFG_TXSLOT_DATA0_t, *UBX_CFG_TXSLOT_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_TXSLOT_DATA0_s::enable
//@{
#define UBX_CFG_TXSLOT_DATA0_ENABLE_DDC_MASK 0x00000001  //!< Mask for field DDC in bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_DDC_GET(val)  (U)(((val)&UBX_CFG_TXSLOT_DATA0_ENABLE_DDC_MASK)>>0)  //!< Get DDC from bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_UART1_MASK 0x00000002  //!< Mask for field UART1 in bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_UART1_GET(val)  (U)(((val)&UBX_CFG_TXSLOT_DATA0_ENABLE_UART1_MASK)>>1)  //!< Get UART1 from bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_UART2_MASK 0x00000004  //!< Mask for field UART2 in bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_UART2_GET(val)  (U)(((val)&UBX_CFG_TXSLOT_DATA0_ENABLE_UART2_MASK)>>2)  //!< Get UART2 from bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_USB_MASK 0x00000008  //!< Mask for field USB in bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_USB_GET(val)  (U)(((val)&UBX_CFG_TXSLOT_DATA0_ENABLE_USB_MASK)>>3)  //!< Get USB from bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_SPI_MASK 0x00000010  //!< Mask for field SPI in bitmask enable
#define UBX_CFG_TXSLOT_DATA0_ENABLE_SPI_GET(val)  (U)(((val)&UBX_CFG_TXSLOT_DATA0_ENABLE_SPI_MASK)>>4)  //!< Get SPI from bitmask enable

//@}

#define UBXID_CFG_TXSLOT 0x0653 //!< message id for CFG-TXSLOT


//================================================================
//! CFG_USB_DATA0: Get/Set
/*!
USB Configuration
-


This message's id is #UBXID_CFG_USB
*/
//================================================================

typedef struct UBX_CFG_USB_DATA0_s
{
    U2  vendorID;                 //!< Vendor ID. This field shall only be set to registered Vendor IDs. Changing this field requires special Host drivers.
    U2  productID;                //!< Product ID. Changing this field requires special Host drivers.
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  powerConsumption;         //!< Power consumed by the device
    X2  flags;                    //!< various configuration flags
    CH  vendorString[32];         //!< String containing the vendor name. 32 ASCII bytes including 0-termination.
    CH  productString[32];        //!< String containing the product name. 32 ASCII bytes including 0-termination.
    CH  serialNumber[32];         //!< String containing the serial number. 32 ASCII bytes including 0-termination.

} UBX_CFG_USB_DATA0_t, *UBX_CFG_USB_DATA0_pt;


//! \name Bit Definitions for #UBX_CFG_USB_DATA0_s::flags
//@{
#define UBX_CFG_USB_DATA0_FLAGS_REENUM_MASK 0x0001  //!< Mask for field reEnum in bitmask flags
#define UBX_CFG_USB_DATA0_FLAGS_REENUM_GET(val)  (U)(((val)&UBX_CFG_USB_DATA0_FLAGS_REENUM_MASK)>>0)  //!< Get reEnum from bitmask flags
#define UBX_CFG_USB_DATA0_FLAGS_POWERMODE_MASK 0x0002  //!< Mask for field powerMode in bitmask flags
#define UBX_CFG_USB_DATA0_FLAGS_POWERMODE_GET(val)  (U)(((val)&UBX_CFG_USB_DATA0_FLAGS_POWERMODE_MASK)>>1)  //!< Get powerMode from bitmask flags

//@}

#define UBXID_CFG_USB 0x061B //!< message id for CFG-USB


//================================================================
//! ESF_STATUS_DATA3: Periodic/Polled
/*!
External Sensor Fusion (ESF) status information
-


This message's id is #UBXID_ESF_STATUS
*/
//================================================================

//! Optional Sub-Structure of #UBX_ESF_STATUS_DATA3_t
typedef struct UBX_ESF_STATUS_DATA3_SENSSTATUS1_s
{
    X1  sensStatus1;              //!< Sensor status, part 1
    X1  sensStatus2;              //!< Sensor status, part 2
    U1  freq;                     //!< Observation frequency
    X1  faults;                   //!< Sensor faults

} UBX_ESF_STATUS_DATA3_SENSSTATUS1_t, *UBX_ESF_STATUS_DATA3_SENSSTATUS1_pt;

//! \name Bit Definitions for #UBX_ESF_STATUS_DATA3_SENSSTATUS1_s::sensStatus1
//@{
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_TYPE_MASK 0x3F  //!< Mask for field type in bitmask sensStatus1
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_TYPE_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_TYPE_MASK)>>0)  //!< Get type from bitmask sensStatus1
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_USED_MASK 0x40  //!< Mask for field used in bitmask sensStatus1
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_USED_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_USED_MASK)>>6)  //!< Get used from bitmask sensStatus1
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_READY_MASK 0x80  //!< Mask for field ready in bitmask sensStatus1
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_READY_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS1_READY_MASK)>>7)  //!< Get ready from bitmask sensStatus1

//@}
//! \name Bit Definitions for #UBX_ESF_STATUS_DATA3_SENSSTATUS1_s::sensStatus2
//@{
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS2_CALIBSTATUS_MASK 0x03  //!< Mask for field calibStatus in bitmask sensStatus2
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS2_CALIBSTATUS_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS2_CALIBSTATUS_MASK)>>0)  //!< Get calibStatus from bitmask sensStatus2
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS2_TIMESTATUS_MASK 0x0C  //!< Mask for field timeStatus in bitmask sensStatus2
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS2_TIMESTATUS_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_SENSSTATUS2_TIMESTATUS_MASK)>>2)  //!< Get timeStatus from bitmask sensStatus2

//@}
//! \name Bit Definitions for #UBX_ESF_STATUS_DATA3_SENSSTATUS1_s::faults
//@{
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_BADMEAS_MASK 0x1  //!< Mask for field badMeas in bitmask faults
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_BADMEAS_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_BADMEAS_MASK)>>0)  //!< Get badMeas from bitmask faults
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_BADTTAG_MASK 0x2  //!< Mask for field badTTag in bitmask faults
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_BADTTAG_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_BADTTAG_MASK)>>1)  //!< Get badTTag from bitmask faults
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_MISSINGMEAS_MASK 0x4  //!< Mask for field missingMeas in bitmask faults
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_MISSINGMEAS_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_MISSINGMEAS_MASK)>>2)  //!< Get missingMeas from bitmask faults
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_NOISYMEAS_MASK 0x8  //!< Mask for field noisyMeas in bitmask faults
#define UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_NOISYMEAS_GET(val)  (U)(((val)&UBX_ESF_STATUS_DATA3_SENSSTATUS1_FAULTS_NOISYMEAS_MASK)>>3)  //!< Get noisyMeas from bitmask faults

//@}


typedef struct UBX_ESF_STATUS_DATA3_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  version;                  //!< Message version (2 for this version)
    U1  reserved1[7];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  fusionMode;               //!< Fusion mode:
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  numSens;                  //!< Number of sensors
    //REPEAT: UBX_ESF_STATUS_DATA3_SENSSTATUS1_t repeat0[numSens];

} UBX_ESF_STATUS_DATA3_t, *UBX_ESF_STATUS_DATA3_pt;


#define UBXID_ESF_STATUS 0x1010 //!< message id for ESF-STATUS


//================================================================
//! INF_DEBUG_DATA0: Output
/*!
ASCII output with debug contents
This message has a variable length payload, representing an ASCII string.


This message's id is #UBXID_INF_DEBUG
*/
//================================================================

#define UBXID_INF_DEBUG 0x0404 //!< message id for INF-DEBUG


//================================================================
//! INF_ERROR_DATA0: Output
/*!
ASCII output with error contents
This message has a variable length payload, representing an ASCII string.


This message's id is #UBXID_INF_ERROR
*/
//================================================================

#define UBXID_INF_ERROR 0x0400 //!< message id for INF-ERROR


//================================================================
//! INF_NOTICE_DATA0: Output
/*!
ASCII output with informational contents
This message has a variable length payload, representing an ASCII string.


This message's id is #UBXID_INF_NOTICE
*/
//================================================================

#define UBXID_INF_NOTICE 0x0402 //!< message id for INF-NOTICE


//================================================================
//! INF_TEST_DATA0: Output
/*!
ASCII output with test contents
This message has a variable length payload, representing an ASCII string.


This message's id is #UBXID_INF_TEST
*/
//================================================================

#define UBXID_INF_TEST 0x0403 //!< message id for INF-TEST


//================================================================
//! INF_WARNING_DATA0: Output
/*!
ASCII output with warning contents
This message has a variable length payload, representing an ASCII string.


This message's id is #UBXID_INF_WARNING
*/
//================================================================

#define UBXID_INF_WARNING 0x0401 //!< message id for INF-WARNING


//================================================================
//! LOG_CREATE_CREATE0: Command
/*!
Create Log File
This message is used to create an initial logging file and activate the logging subsystem.
<rc href=\"UBX-ACK-ACK'>UBX-ACK-ACK</rc> or <rc href=\"UBX-ACK-NAK'>UBX-ACK-NAK</rc> are returned to indicate success or failure.
This message does not handle activation of recording or filtering of log entries (see <rc href=\"UBX-CFG-LOGFILTER'>UBX-CFG-LOGFILTER</rc>).


This message's id is #UBXID_LOG_CREATE
*/
//================================================================

typedef struct UBX_LOG_CREATE_CREATE0_s
{
    U1  version;                  //!< The version of this message. Set to 0
    X1  logCfg;                   //!< Config flags
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  logSize;                  //!< Indicates the size of the log:
    U4  userDefinedSize;          //!< Sets the maximum amount of space in the filestore that can be used by the logging task.

} UBX_LOG_CREATE_CREATE0_t, *UBX_LOG_CREATE_CREATE0_pt;


//! \name Bit Definitions for #UBX_LOG_CREATE_CREATE0_s::logCfg
//@{
#define UBX_LOG_CREATE_CREATE0_LOGCFG_CIRCULAR_MASK 0x01  //!< Mask for field circular in bitmask logCfg
#define UBX_LOG_CREATE_CREATE0_LOGCFG_CIRCULAR_GET(val)  (U)(((val)&UBX_LOG_CREATE_CREATE0_LOGCFG_CIRCULAR_MASK)>>0)  //!< Get circular from bitmask logCfg

//@}

#define UBXID_LOG_CREATE 0x2107 //!< message id for LOG-CREATE


//================================================================
//! LOG_ERASE_DATA0: Command
/*!
Erase Logged Data
This message deactivates the logging system and erases all logged data.
<rc href=\"UBX-ACK-ACK'>UBX-ACK-ACK</rc> or <rc href=\"UBX-ACK-NAK'>UBX-ACK-NAK</rc> are returned to indicate success or failure.


This message's id is #UBXID_LOG_ERASE
*/
//================================================================

typedef struct UBX_LOG_ERASE_DATA0_s
{

} UBX_LOG_ERASE_DATA0_t, *UBX_LOG_ERASE_DATA0_pt;


#define UBXID_LOG_ERASE 0x2103 //!< message id for LOG-ERASE


//================================================================
//! LOG_FINDTIME_REQUEST: Input
/*!
Find index of a log entry based on a given time
This message can be used for a time-based search of a log. It can find the index of the first log entry with time equal to the given time, otherwise the index of the most recent entry with time less than the given time. This index can then be used with the <rc href=\"UBX-LOG-RETRIEVE'>UBX-LOG-RETRIEVE</rc> message to provide time-based retrieval of log entries.
Searching a log is effective for a given time later than the base date (January 1st, 2004). Searching a log for a given time earlier than the base date will result in an 'entry not found' response. (Searching a log for a given time earlier than the base date will result in a UBX-ACK-NAK message in <r href='FIRMWARE-PROTOCOLVERSION'>protocol versions less than 18</r>)
Searching a log for a given time greater than the last recorded entry's time will return the index of the last recorded entry. (If the logging has stopped due to lack of file space, such a search will result in a UBX-ACK-NAK message in <r href='FIRMWARE-PROTOCOLVERSION'>protocol versions less than 18</r>)


This message's id is #UBXID_LOG_FINDTIME
*/
//================================================================

typedef struct UBX_LOG_FINDTIME_REQUEST_s
{
    U1  version;                  //!< Message version (=0 for this version)
    U1  type;                     //!< Message type, 0 for request
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  year;                     //!< Year (1-65635) of UTC time
    U1  month;                    //!< Month (1-12) of UTC time
    U1  day;                      //!< Day (1-31) of UTC time
    U1  hour;                     //!< Hour (0-23) of UTC time
    U1  minute;                   //!< Minute (0-59) of UTC time
    U1  second;                   //!< Second (0-60) of UTC time
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_LOG_FINDTIME_REQUEST_t, *UBX_LOG_FINDTIME_REQUEST_pt;


#define UBXID_LOG_FINDTIME 0x210E //!< message id for LOG-FINDTIME


//================================================================
//! LOG_FINDTIME_RESPONSE: Output
/*!
Response to FINDTIME request.
-


This message's id is #UBXID_LOG_FINDTIME
*/
//================================================================

typedef struct UBX_LOG_FINDTIME_RESPONSE_s
{
    U1  version;                  //!< Message version (=1 for this version)
    U1  type;                     //!< Message type, 1 for response
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  entryNumber;              //!< Index of the first log entry with time = given time, otherwise index of the most recent entry with time < given time. If 0xFFFFFFFF, no log entry found with time <= given time. The indexing of log entries is zero based.

} UBX_LOG_FINDTIME_RESPONSE_t, *UBX_LOG_FINDTIME_RESPONSE_pt;


//#define UBXID_LOG_FINDTIME 0x210E  // already defined, see above


//================================================================
//! LOG_INFO_POLL0: Poll Request
/*!
Poll for log information
Upon sending of this message, the receiver returns UBX-LOG-INFO as defined below.


This message's id is #UBXID_LOG_INFO
*/
//================================================================

typedef struct UBX_LOG_INFO_POLL0_s
{

} UBX_LOG_INFO_POLL0_t, *UBX_LOG_INFO_POLL0_pt;


#define UBXID_LOG_INFO 0x2108 //!< message id for LOG-INFO


//================================================================
//! LOG_INFO_DATA0: Output
/*!
Log information
This message is used to report information about the logging subsystem.
Note:
* The reported maximum log size will be smaller than that originally specified in LOG-CREATE due to logging and filestore implementation overheads.
* Log entries are compressed in a variable length fashion, so it may be difficult to predict log space usage with any precision.
* There may be times when the receiver does not have an accurate time (e.g. if the week number is not yet known), in which case some entries will not have a timestamp. This may result in the oldest/newest entry time values not taking account of these entries.


This message's id is #UBXID_LOG_INFO
*/
//================================================================

typedef struct UBX_LOG_INFO_DATA0_s
{
    U1  version;                  //!< The version of this message. Set to 1
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  filestoreCapacity;        //!< The capacity of the filestore
    U1  reserved2[8];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  currentMaxLogSize;        //!< The maximum size the current log is allowed to grow to
    U4  currentLogSize;           //!< Approximate amount of space in log currently occupied
    U4  entryCount;               //!< Number of entries in the log.
    U2  oldestYear;               //!< Oldest entry UTC year year (1-65635) or zero if there are no entries with known time
    U1  oldestMonth;              //!< Oldest month (1-12)
    U1  oldestDay;                //!< Oldest day (1-31)
    U1  oldestHour;               //!< Oldest hour (0-23)
    U1  oldestMinute;             //!< Oldest minute (0-59)
    U1  oldestSecond;             //!< Oldest second (0-60)
    U1  reserved3;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  newestYear;               //!< Newest year (1-65635) or zero if there are no entries with known time
    U1  newestMonth;              //!< Newest month (1-12)
    U1  newestDay;                //!< Newest day (1-31)
    U1  newestHour;               //!< Newest hour (0-23)
    U1  newestMinute;             //!< Newest minute (0-59)
    U1  newestSecond;             //!< Newest second (0-60)
    U1  reserved4;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X1  status;                   //!< Log status flags
    U1  reserved5[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_LOG_INFO_DATA0_t, *UBX_LOG_INFO_DATA0_pt;


//! \name Bit Definitions for #UBX_LOG_INFO_DATA0_s::status
//@{
#define UBX_LOG_INFO_DATA0_STATUS_RECORDING_MASK 0x08  //!< Mask for field recording in bitmask status
#define UBX_LOG_INFO_DATA0_STATUS_RECORDING_GET(val)  (U)(((val)&UBX_LOG_INFO_DATA0_STATUS_RECORDING_MASK)>>3)  //!< Get recording from bitmask status
#define UBX_LOG_INFO_DATA0_STATUS_INACTIVE_MASK 0x10  //!< Mask for field inactive in bitmask status
#define UBX_LOG_INFO_DATA0_STATUS_INACTIVE_GET(val)  (U)(((val)&UBX_LOG_INFO_DATA0_STATUS_INACTIVE_MASK)>>4)  //!< Get inactive from bitmask status
#define UBX_LOG_INFO_DATA0_STATUS_CIRCULAR_MASK 0x20  //!< Mask for field circular in bitmask status
#define UBX_LOG_INFO_DATA0_STATUS_CIRCULAR_GET(val)  (U)(((val)&UBX_LOG_INFO_DATA0_STATUS_CIRCULAR_MASK)>>5)  //!< Get circular from bitmask status

//@}

//#define UBXID_LOG_INFO 0x2108  // already defined, see above


//================================================================
//! LOG_RETRIEVEPOSEXTRA_ODOMETER0: Output
/*!
Odometer log entry
This message is used to report an odometer log entry


This message's id is #UBXID_LOG_RETRIEVEPOSEXTRA
*/
//================================================================

typedef struct UBX_LOG_RETRIEVEPOSEXTRA_ODOMETER0_s
{
    U4  entryIndex;               //!< The index of this log entry
    U1  version;                  //!< The version of this message. Set to 0
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  year;                     //!< Year (1-65635) of UTC time. Will be zero if time not known
    U1  month;                    //!< Month (1-12) of UTC time
    U1  day;                      //!< Day (1-31) of UTC time
    U1  hour;                     //!< Hour (0-23) of UTC time
    U1  minute;                   //!< Minute (0-59) of UTC time
    U1  second;                   //!< Second (0-60) of UTC time
    U1  reserved2[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  distance;                 //!< Odometer distance traveled since the last time the odometer was reset by a <rc href=\"UBX-NAV-RESETODO'>UBX-NAV-RESETODO</rc>
    U1  reserved3[12];            //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_LOG_RETRIEVEPOSEXTRA_ODOMETER0_t, *UBX_LOG_RETRIEVEPOSEXTRA_ODOMETER0_pt;


#define UBXID_LOG_RETRIEVEPOSEXTRA 0x210F //!< message id for LOG-RETRIEVEPOSEXTRA


//================================================================
//! LOG_RETRIEVEPOS_POS0: Output
/*!
Position fix log entry
This message is used to report a position fix log entry


This message's id is #UBXID_LOG_RETRIEVEPOS
*/
//================================================================

typedef struct UBX_LOG_RETRIEVEPOS_POS0_s
{
    U4  entryIndex;               //!< The index of this log entry
    I4  lon;                      //!< Longitude
    I4  lat;                      //!< Latitude
    I4  hMSL;                     //!< Height above mean sea level
    U4  hAcc;                     //!< Horizontal accuracy estimate
    U4  gSpeed;                   //!< Ground speed (2-D)
    U4  heading;                  //!< Heading
    U1  version;                  //!< The version of this message. Set to 0
    U1  fixType;                  //!< Fix type:
    U2  year;                     //!< Year (1-65635) of UTC time
    U1  month;                    //!< Month (1-12) of UTC time
    U1  day;                      //!< Day (1-31) of UTC time
    U1  hour;                     //!< Hour (0-23) of UTC time
    U1  minute;                   //!< Minute (0-59) of UTC time
    U1  second;                   //!< Second (0-60) of UTC time
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  numSV;                    //!< Number of satellites used in the position fix
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_LOG_RETRIEVEPOS_POS0_t, *UBX_LOG_RETRIEVEPOS_POS0_pt;


#define UBXID_LOG_RETRIEVEPOS 0x210B //!< message id for LOG-RETRIEVEPOS


//================================================================
//! LOG_RETRIEVESTRING_STRING0: Output
/*!
Byte string log entry
This message is used to report a byte string log entry


This message's id is #UBXID_LOG_RETRIEVESTRING
*/
//================================================================

//! Optional Sub-Structure of #UBX_LOG_RETRIEVESTRING_STRING0_t
typedef struct UBX_LOG_RETRIEVESTRING_STRING0_BYTES_s
{
    U1  bytes;                    //!< The bytes of the string

} UBX_LOG_RETRIEVESTRING_STRING0_BYTES_t, *UBX_LOG_RETRIEVESTRING_STRING0_BYTES_pt;



typedef struct UBX_LOG_RETRIEVESTRING_STRING0_s
{
    U4  entryIndex;               //!< The index of this log entry
    U1  version;                  //!< The version of this message. Set to 0
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  year;                     //!< Year (1-65635) of UTC time. Will be zero if time not known
    U1  month;                    //!< Month (1-12) of UTC time
    U1  day;                      //!< Day (1-31) of UTC time
    U1  hour;                     //!< Hour (0-23) of UTC time
    U1  minute;                   //!< Minute (0-59) of UTC time
    U1  second;                   //!< Second (0-60) of UTC time
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  byteCount;                //!< Size of string in bytes
    //REPEAT: UBX_LOG_RETRIEVESTRING_STRING0_BYTES_t repeat0[byteCount];

} UBX_LOG_RETRIEVESTRING_STRING0_t, *UBX_LOG_RETRIEVESTRING_STRING0_pt;


#define UBXID_LOG_RETRIEVESTRING 0x210D //!< message id for LOG-RETRIEVESTRING


//================================================================
//! LOG_RETRIEVE_REQ0: Command
/*!
Request log data
This message is used to request logged data (log recording must first be disabled, see <rc href=\"UBX-CFG-LOGFILTER'>UBX-CFG-LOGFILTER</rc>).
Log entries are returned in chronological order, using the messages <rc href=\"UBX-LOG-RETRIEVEPOS'>UBX-LOG-RETRIEVEPOS</rc> and <rc href=\"UBX-LOG-RETRIEVESTRING'>UBX-LOG-RETRIEVESTRING</rc>. If the odometer was enabled at the time a position was logged, then message <rc href=\"UBX-LOG-RETRIEVEPOSEXTRA'>UBX-LOG-RETRIEVEPOSEXTRA</rc> will also be used. The maximum number of entries that can be returned in response to a single UBX-LOG-RETRIEVE message is 256. If more entries than this are required the message will need to be sent multiple times with different startNumbers. The retrieve will be stopped if any UBX-LOG message is received. The speed of transfer can be maximized by using a high data rate and temporarily stopping the GPS processing (see <rc href=\"UBX-CFG-RST'>UBX-CFG-RST</rc>).


This message's id is #UBXID_LOG_RETRIEVE
*/
//================================================================

typedef struct UBX_LOG_RETRIEVE_REQ0_s
{
    U4  startNumber;              //!< Index of first log entry to be transferred. If it is larger than the index of the last available log entry, then the first log entry to be transferred is the last available log entry. The indexing of log entries is zero based.
    U4  entryCount;               //!< Number of log entries to transfer in total including the first entry to be transferred. If it is larger than the log entries available starting from the first entry to be transferred, then only the available log entries are transferred followed by a <rc href=\"UBX-ACK-NAK'>UBX-ACK-NAK</rc>. The maximum is 256.
    U1  version;                  //!< The version of this message. Set to 0.
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_LOG_RETRIEVE_REQ0_t, *UBX_LOG_RETRIEVE_REQ0_pt;


#define UBXID_LOG_RETRIEVE 0x2109 //!< message id for LOG-RETRIEVE


//================================================================
//! LOG_STRING_DATA0: Command
/*!
Store arbitrary string in on-board flash
This message can be used to store an arbitrary byte string in the on-board flash memory. The maximum length that can be stored is 256 bytes.


This message's id is #UBXID_LOG_STRING
*/
//================================================================

//! Optional Sub-Structure of #UBX_LOG_STRING_DATA0_t
typedef struct UBX_LOG_STRING_DATA0_BYTES_s
{
    U1  bytes;                    //!< The string of bytes to be logged (maximum 256)

} UBX_LOG_STRING_DATA0_BYTES_t, *UBX_LOG_STRING_DATA0_BYTES_pt;



typedef struct UBX_LOG_STRING_DATA0_s
{
    //REPEAT: UBX_LOG_STRING_DATA0_BYTES_t repeat0[N];

} UBX_LOG_STRING_DATA0_t, *UBX_LOG_STRING_DATA0_pt;


#define UBXID_LOG_STRING 0x2104 //!< message id for LOG-STRING


//================================================================
//! MGA_ACK_DATA0: Output
/*!
Multiple GNSS Acknowledge message
This message is sent by a u-blox receiver to acknowledge the receipt of an assistance message. Acknowledgments are enabled by setting the ackAiding parameter in the <rc href=\"UBX-CFG-NAVX5'>UBX-CFG-NAVX5</rc> message. See the description of <r href=\"MGA-FlowControl'>flow control</r> for details.


This message's id is #UBXID_MGA_ACK
*/
//================================================================

typedef struct UBX_MGA_ACK_DATA0_s
{
    U1  type;                     //!< Type of acknowledgment:
    U1  version;                  //!< Message version (0x00 for this version)
    U1  infoCode;                 //!< Provides greater information on what the receiver chose to do with the message contents:
    U1  msgId;                    //!< UBX message ID of the ack'ed message
    U1  msgPayloadStart[4];       //!< The first 4 bytes of the ack'ed message's payload

} UBX_MGA_ACK_DATA0_t, *UBX_MGA_ACK_DATA0_pt;


#define UBXID_MGA_ACK 0x1360 //!< message id for MGA-ACK


//================================================================
//! MGA_ANO_DATA0: Input
/*!
Multiple GNSS AssistNow Offline Assistance
This message is created by the AssistNow Offline service to deliver AssistNow Offline assistance to the receiver. See the description of <r href=\"MGA-Offline'>AssistNow Offline</r> for details.


This message's id is #UBXID_MGA_ANO
*/
//================================================================

typedef struct UBX_MGA_ANO_DATA0_s
{
    U1  type;                     //!< Message type (0x00 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  gnssId;                   //!< GNSS identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  year;                     //!< years since the year 2000
    U1  month;                    //!< month (1..12)
    U1  day;                      //!< day (1..31)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  data[64];                 //!< assistance data
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_ANO_DATA0_t, *UBX_MGA_ANO_DATA0_pt;


#define UBXID_MGA_ANO 0x1320 //!< message id for MGA-ANO


//================================================================
//! MGA_BDS_EPH: Input
/*!
BDS Ephemeris Assistance
This message allows the delivery of BeiDou ephemeris assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_BDS
*/
//================================================================

typedef struct UBX_MGA_BDS_EPH_s
{
    U1  type;                     //!< Message type (0x01 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< BDS satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  SatH1;                    //!< Autonomous satellite Health flag
    U1  IODC;                     //!< Issue of Data, Clock
    I2  a2;                       //!< Time polynomial coefficient 2
    I4  a1;                       //!< Time polynomial coefficient 1
    I4  a0;                       //!< Time polynomial coefficient 0
    U4  toc;                      //!< Clock data reference time
    I2  TGD1;                     //!< Equipment Group Delay Differential
    U1  URAI;                     //!< User Range Accuracy Index
    U1  IODE;                     //!< Issue of Data, Ephemeris
    U4  toe;                      //!< Ephemeris reference time
    U4  sqrtA;                    //!< Square root of semi-major axis
    U4  e;                        //!< Eccentricity
    I4  omega;                    //!< Argument of perigee
    I2  Deltan;                   //!< Mean motion difference from computed value
    I2  IDOT;                     //!< Rate of inclination angle
    I4  M0;                       //!< Mean anomaly at reference time
    I4  Omega0;                   //!< Longitude of ascending node of orbital of plane computed according to reference time
    I4  OmegaDot;                 //!< Rate of right ascension
    I4  i0;                       //!< Inclination angle at reference time
    I4  Cuc;                      //!< Amplitude of cosine harmonic correction term to the argument of latitude
    I4  Cus;                      //!< Amplitude of sine harmonic correction term to the argument of latitude
    I4  Crc;                      //!< Amplitude of cosine harmonic correction term to the orbit radius
    I4  Crs;                      //!< Amplitude of sine harmonic correction term to the orbit radius
    I4  Cic;                      //!< Amplitude of cosine harmonic correction term to the angle of inclination
    I4  Cis;                      //!< Amplitude of sine harmonic correction term to the angle of inclination
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_BDS_EPH_t, *UBX_MGA_BDS_EPH_pt;


#define UBXID_MGA_BDS 0x1303 //!< message id for MGA-BDS


//================================================================
//! MGA_BDS_ALM: Input
/*!
BDS Almanac Assistance
This message allows the delivery of BeiDou almanac assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_BDS
*/
//================================================================

typedef struct UBX_MGA_BDS_ALM_s
{
    U1  type;                     //!< Message type (0x02 for this version)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< BeiDou satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  Wna;                      //!< Almanac Week Number
    U1  toa;                      //!< Almanac reference time
    I2  deltaI;                   //!< Almanac correction of orbit reference inclination at reference time
    U4  sqrtA;                    //!< Almanac square root of semi-major axis
    U4  e;                        //!< Almanac eccentricity
    I4  omega;                    //!< Almanac argument of perigee
    I4  M0;                       //!< Almanac mean anomaly at reference time
    I4  Omega0;                   //!< Almanac longitude of ascending node of orbit plane at computed according to reference time
    I4  omegaDot;                 //!< Almanac rate of right ascension
    I2  a0;                       //!< Almanac satellite clock bias
    I2  a1;                       //!< Almanac satellite clock rate
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_BDS_ALM_t, *UBX_MGA_BDS_ALM_pt;


//#define UBXID_MGA_BDS 0x1303  // already defined, see above


//================================================================
//! MGA_BDS_HEALTH: Input
/*!
BDS Health Assistance
This message allows the delivery of BeiDou health assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_BDS
*/
//================================================================

typedef struct UBX_MGA_BDS_HEALTH_s
{
    U1  type;                     //!< Message type (0x04 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  healthCode[30];           //!< Each two-byte value represents a BDS SV (1-30). The 9 LSBs of each byte contain the 9 bit health code from subframe 5 pages 7,8 of the D1 message, and from subframe 5 pages 35,36 of the D1 message.
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_BDS_HEALTH_t, *UBX_MGA_BDS_HEALTH_pt;


//#define UBXID_MGA_BDS 0x1303  // already defined, see above


//================================================================
//! MGA_BDS_UTC: Input
/*!
BDS UTC Assistance
This message allows the delivery of BeiDou UTC assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_BDS
*/
//================================================================

typedef struct UBX_MGA_BDS_UTC_s
{
    U1  type;                     //!< Message type (0x05 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  a0UTC;                    //!< BDT clock bias relative to UTC
    I4  a1UTC;                    //!< BDT clock rate relative to UTC
    I1  dtLS;                     //!< Delta time due to leap seconds before the new leap second effective
    U1  reserved2[1];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  wnRec;                    //!< BeiDou week number of reception of this UTC parameter set (8 bit truncated)
    U1  wnLSF;                    //!< Week number of the new leap second
    U1  dN;                       //!< Day number of the new leap second
    I1  dtLSF;                    //!< Delta time due to leap seconds after the new leap second effective
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_BDS_UTC_t, *UBX_MGA_BDS_UTC_pt;


//#define UBXID_MGA_BDS 0x1303  // already defined, see above


//================================================================
//! MGA_BDS_IONO: Input
/*!
BDS Ionospheric Assistance
This message allows the delivery of BeiDou ionospheric assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_BDS
*/
//================================================================

typedef struct UBX_MGA_BDS_IONO_s
{
    U1  type;                     //!< Message type (0x06 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I1  alpha0;                   //!< Ionospheric parameter alpha0
    I1  alpha1;                   //!< Ionospheric parameter alpha1
    I1  alpha2;                   //!< Ionospheric parameter alpha2
    I1  alpha3;                   //!< Ionospheric parameter alpha3
    I1  beta0;                    //!< Ionospheric parameter beta0
    I1  beta1;                    //!< Ionospheric parameter beta1
    I1  beta2;                    //!< Ionospheric parameter beta2
    I1  beta3;                    //!< Ionospheric parameter beta3
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_BDS_IONO_t, *UBX_MGA_BDS_IONO_pt;


//#define UBXID_MGA_BDS 0x1303  // already defined, see above


//================================================================
//! MGA_DBD_POLL: Poll Request
/*!
Poll the Navigation Database
Poll the whole navigation data base. The receiver will send all available data from its internal database. The receiver will indicate the finish of the transmission with a <rc href=\"UBX-MGA-ACK'>UBX-MGA-ACK</rc>. The msgPayloadStart field of the UBX-MGA-ACK message will contain a U4 representing the number of UBX-MGA-DBD-DATA* messages sent.


This message's id is #UBXID_MGA_DBD
*/
//================================================================

typedef struct UBX_MGA_DBD_POLL_s
{

} UBX_MGA_DBD_POLL_t, *UBX_MGA_DBD_POLL_pt;


#define UBXID_MGA_DBD 0x1380 //!< message id for MGA-DBD


//================================================================
//! MGA_DBD_DATA0: Input/Output
/*!
Navigation Database Dump Entry
Navigation database entry. The data fields are firmware specific. Transmission of this type of message will be acknowledged by <rc href=\"UBX-MGA-ACK'>MGA-ACK</rc> messages, if acknowledgment has been enabled (see the description of <r href=\"MGA-FlowControl'>flow control</r> for details).
The maximum payload size for firmware 2.01 onwards is 164 bytes (which makes the maximum message size 172 bytes).

   \note: UBX-MGA-DBD messages are only intended to be sent back to the same receiver that generated them.

This message's id is #UBXID_MGA_DBD
*/
//================================================================

//! Optional Sub-Structure of #UBX_MGA_DBD_DATA0_t
typedef struct UBX_MGA_DBD_DATA0_DATA_s
{
    U1  data;                     //!< fw specific data

} UBX_MGA_DBD_DATA0_DATA_t, *UBX_MGA_DBD_DATA0_DATA_pt;



typedef struct UBX_MGA_DBD_DATA0_s
{
    U1  reserved1[12];            //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_MGA_DBD_DATA0_DATA_t repeat0[N];

} UBX_MGA_DBD_DATA0_t, *UBX_MGA_DBD_DATA0_pt;


//#define UBXID_MGA_DBD 0x1380  // already defined, see above


//================================================================
//! MGA_FLASH_DATA: Input
/*!
Transfer MGA-ANO data block to flash
This message is used to transfer a block of MGA-ANO data from host to the receiver. Upon reception of this message, the receiver will write the payload data to its internal non-volatile memory (flash). Also, on reception of the first MGA-FLASH-DATA message, the receiver will erase the flash allocated to storing any existing MGA-ANO data. The payload can be up to 512 bytes. Payloads larger than this would exceed the receiver's internal buffering capabilities. The receiver will ACK/NACK this message using the message alternatives given below. The host shall wait for an acknowledge message before sending the next data block. See <r href=\"MGA-OfflineFlash'>Flash-based AssistNow Offline</r> for details.


This message's id is #UBXID_MGA_FLASH
*/
//================================================================

//! Optional Sub-Structure of #UBX_MGA_FLASH_DATA_t
typedef struct UBX_MGA_FLASH_DATA_DATA_s
{
    U1  data;                     //!< Payload data.

} UBX_MGA_FLASH_DATA_DATA_t, *UBX_MGA_FLASH_DATA_DATA_pt;



typedef struct UBX_MGA_FLASH_DATA_s
{
    U1  type;                     //!< Message type (0x01 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U2  sequence;                 //!< Message sequence number, starting at 0 and increamenting by 1 for each MGA-FLASH-DATA message sent.
    U2  size;                     //!< Payload size in bytes.
    //REPEAT: UBX_MGA_FLASH_DATA_DATA_t repeat0[size];

} UBX_MGA_FLASH_DATA_t, *UBX_MGA_FLASH_DATA_pt;


#define UBXID_MGA_FLASH 0x1321 //!< message id for MGA-FLASH


//================================================================
//! MGA_FLASH_STOP: Input
/*!
Finish flashing MGA-ANO data
This message is used to tell the receiver that there are no more MGA-FLASH type 1 messages coming, and that it can do any final internal operations needed to commit the data to flash as a background activity. A UBX-MGA-ACK message will be sent at the end of this process. Note that there may be a delay of several seconds before the UBX-MGA-ACK for this message is sent because of the time taken for this processing. See <r href=\"MGA-OfflineFlash'>Flash-based AssistNow Offline</r> for details.


This message's id is #UBXID_MGA_FLASH
*/
//================================================================

typedef struct UBX_MGA_FLASH_STOP_s
{
    U1  type;                     //!< Message type (0x02 for this type)
    U1  version;                  //!< Message version (0x00 for this version)

} UBX_MGA_FLASH_STOP_t, *UBX_MGA_FLASH_STOP_pt;


//#define UBXID_MGA_FLASH 0x1321  // already defined, see above


//================================================================
//! MGA_FLASH_ACK: Output
/*!
Acknowledge last FLASH-DATA or -STOP
This message reports an ACK/NACK to the host for the last MGA-FLASH type 1 or type 2 message message received. See <r href=\"MGA-OfflineFlash'>Flash-based AssistNow Offline</r> for details.


This message's id is #UBXID_MGA_FLASH
*/
//================================================================

typedef struct UBX_MGA_FLASH_ACK_s
{
    U1  type;                     //!< Message type (0x03 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  ack;                      //!< Acknowledgment type. 0 - ACK: Message received and written to flash. 1 - NACK: Problem with last message, re-transmission required (this only happens while acknowledging a UBX-MGA_FLASH_DATA message). 2 - NACK: problem with last message, give up.
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  sequence;                 //!< If acknowledging a UBX-MGA-FLASH-DATA message this is the Message sequence number being ack'ed. If acknowledging a UBX-MGA-FLASH-STOP message it will be set to 0xffff.

} UBX_MGA_FLASH_ACK_t, *UBX_MGA_FLASH_ACK_pt;


//#define UBXID_MGA_FLASH 0x1321  // already defined, see above


//================================================================
//! MGA_GAL_EPH: Input
/*!
Galileo Ephemeris Assistance
This message allows the delivery of Galileo ephemeris assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GAL
*/
//================================================================

typedef struct UBX_MGA_GAL_EPH_s
{
    U1  type;                     //!< Message type (0x01 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< Galileo Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  iodNav;                   //!< Ephemeris and clock correction Issue of Data
    I2  deltaN;                   //!< Mean motion difference from computed value
    I4  m0;                       //!< Mean anomaly at reference time
    U4  e;                        //!< Eccentricity
    U4  sqrtA;                    //!< Square root of the semi-major axis
    I4  omega0;                   //!< Longitude of ascending node of orbital plane at weekly epoch
    I4  i0;                       //!< Inclination angle at reference time
    I4  omega;                    //!< Argument of perigee
    I4  omegaDot;                 //!< Rate of change of right ascension
    I2  iDot;                     //!< Rate of change of inclination angle
    I2  cuc;                      //!< Amplitude of the cosine harmonic correction term to the argument of latitude
    I2  cus;                      //!< Amplitude of the sine harmonic correction term to the argument of latitude
    I2  crc;                      //!< Amplitude of the cosine harmonic correction term to the orbit radius
    I2  crs;                      //!< Amplitude of the sine harmonic correction term to the orbit radius
    I2  cic;                      //!< Amplitude of the cosine harmonic correction term to the angle of inclination
    I2  cis;                      //!< Amplitude of the sine harmonic correction term to the angle of inclination
    U2  toe;                      //!< Ephemeris reference time
    I4  af0;                      //!< SV clock bias correction coefficient
    I4  af1;                      //!< SV clock drift correction coefficient
    I1  af2;                      //!< SV clock drift rate correction coefficient
    U1  sisaIndexE1E5b;           //!< Signal  In  Space Accuracy index for dual frequency E1-E5b
    U2  toc;                      //!< Clock correction data reference Time of Week
    I2  bgdE1E5b;                 //!< E1-E5b Broadcast Group Delay
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  healthE1B;                //!< E1-B Signal Health Status
    U1  dataValidityE1B;          //!< E1-B Data Validity Status
    U1  healthE5b;                //!< E5b Signal Health Status
    U1  dataValidityE5b;          //!< E5b Data Validity Status
    U1  reserved3[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GAL_EPH_t, *UBX_MGA_GAL_EPH_pt;


#define UBXID_MGA_GAL 0x1302 //!< message id for MGA-GAL


//================================================================
//! MGA_GAL_ALM: Input
/*!
Galileo Almanac Assistance
This message allows the delivery of Galileo almanac assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GAL
*/
//================================================================

typedef struct UBX_MGA_GAL_ALM_s
{
    U1  type;                     //!< Message type (0x02 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< Galileo Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  ioda;                     //!< Almanac Issue of Data
    U1  almWNa;                   //!< Almanac reference week number
    U2  toa;                      //!< Almanac reference time
    I2  deltaSqrtA;               //!< Difference with respect to the square root of the nominal semi-major axis (29 600 km)
    U2  e;                        //!< Eccentricity
    I2  deltaI;                   //!< Inclination at reference time relative to i0 = 56 degree
    I2  omega0;                   //!< Longitude of ascending node of orbital plane at weekly epoch
    I2  omegaDot;                 //!< Rate of change of right ascension
    I2  omega;                    //!< Argument of perigee
    I2  m0;                       //!< Satellite mean anomaly at reference time
    I2  af0;                      //!< Satellite clock correction bias 'truncated'
    I2  af1;                      //!< Satellite clock correction linear 'truncated'
    U1  healthE1B;                //!< Satellite E1-B signal health status
    U1  healthE5b;                //!< Satellite E5b signal health status
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GAL_ALM_t, *UBX_MGA_GAL_ALM_pt;


//#define UBXID_MGA_GAL 0x1302  // already defined, see above


//================================================================
//! MGA_GAL_TIMEOFFSET: Input
/*!
Galileo GPS time offset assistance
This message allows the delivery of Galileo time to GPS time offset. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GAL
*/
//================================================================

typedef struct UBX_MGA_GAL_TIMEOFFSET_s
{
    U1  type;                     //!< Message type (0x03 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I2  a0G;                      //!< Constant term of the polynomial describing the offset
    I2  a1G;                      //!< Rate of change of the offset
    U1  t0G;                      //!< DReference time for GGTO data
    U1  wn0G;                     //!< Week Number of GGTO reference
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GAL_TIMEOFFSET_t, *UBX_MGA_GAL_TIMEOFFSET_pt;


//#define UBXID_MGA_GAL 0x1302  // already defined, see above


//================================================================
//! MGA_GAL_UTC: Input
/*!
Galileo UTC Assistance
This message allows the delivery of Galileo UTC assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GAL
*/
//================================================================

typedef struct UBX_MGA_GAL_UTC_s
{
    U1  type;                     //!< Message type (0x05 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  a0;                       //!< First parameter of UTC polynomial
    I4  a1;                       //!< Second parameter of UTC polynomial
    I1  dtLS;                     //!< Delta time due to current leap seconds
    U1  tot;                      //!< UTC parameters reference time of week (Galileo time)
    U1  wnt;                      //!< UTC parameters reference week number (the 8 bit WNt field)
    U1  wnLSF;                    //!< Week number at the end of which the future leap second becomes effective (the 8 bit WNLSF field)
    U1  dN;                       //!< Day number at the end of which the future leap second becomes effective
    I1  dTLSF;                    //!< Delta time due to future leap seconds
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GAL_UTC_t, *UBX_MGA_GAL_UTC_pt;


//#define UBXID_MGA_GAL 0x1302  // already defined, see above


//================================================================
//! MGA_GLO_EPH: Input
/*!
GLONASS Ephemeris Assistance
This message allows the delivery of GLONASS ephemeris assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GLO
*/
//================================================================

typedef struct UBX_MGA_GLO_EPH_s
{
    U1  type;                     //!< Message type (0x01 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< GLONASS Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  FT;                       //!< User range accuracy
    U1  B;                        //!< Health flag from string 2
    U1  M;                        //!< Type of GLONASS satellite (1 indicates GLONASS-M)
    I1  H;                        //!< Carrier frequency number of navigation RF signal, Range=(-7 .. 6), -128 for unknown
    I4  x;                        //!< X component of the SV position in PZ-90.02 coordinate System
    I4  y;                        //!< Y component of the SV position in PZ-90.02 coordinate System
    I4  z;                        //!< Z component of the SV position in PZ-90.02 coordinate System
    I4  dx;                       //!< X component of the SV velocity in PZ-90.02 coordinate System
    I4  dy;                       //!< Y component of the SV velocity in PZ-90.02 coordinate System
    I4  dz;                       //!< Z component of the SV velocity in PZ-90.02 coordinate System
    I1  ddx;                      //!< X component of the SV acceleration in PZ-90.02 coordinate System
    I1  ddy;                      //!< Y component of the SV acceleration in PZ-90.02 coordinate System
    I1  ddz;                      //!< Z component of the SV acceleration in PZ-90.02 coordinate System
    U1  tb;                       //!< Index of a time interval within current day according to UTC(SU)
    I2  gamma;                    //!< Relative carrier frequency deviation
    U1  E;                        //!< Ephemeris data age indicator
    I1  deltaTau;                 //!< Time difference between L2 and L1 band
    I4  tau;                      //!< SV clock bias
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GLO_EPH_t, *UBX_MGA_GLO_EPH_pt;


#define UBXID_MGA_GLO 0x1306 //!< message id for MGA-GLO


//================================================================
//! MGA_GLO_ALM: Input
/*!
GLONASS Almanac Assistance
This message allows the delivery of GLONASS almanac assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GLO
*/
//================================================================

typedef struct UBX_MGA_GLO_ALM_s
{
    U1  type;                     //!< Message type (0x02 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< GLONASS Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  N;                        //!< Reference calender day number of almanac within the four-year period (from string 5)
    U1  M;                        //!< Type of GLONASS satellite (1 indicates GLONASS-M)
    U1  C;                        //!< Unhealthy flag at instant of almanac upload (1 indicates operability of satellite)
    I2  tau;                      //!< Coarse time correction to GLONASS time
    U2  epsilon;                  //!< Eccentricity
    I4  lambda;                   //!< Longitude of the first (within the N-day) ascending node of satellite orbit in PC-90.02 coordinate system
    I4  deltaI;                   //!< Correction to the mean value of inclination
    U4  tLambda;                  //!< Time of the first ascending node passage
    I4  deltaT;                   //!< Correction to the mean value of Draconian period
    I1  deltaDT;                  //!< Rate of change of Draconian perion
    I1  H;                        //!< Carrier frequency number of navigation RF signal, Range=(-7 .. 6)
    I2  omega;                    //!< Argument of perigee
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GLO_ALM_t, *UBX_MGA_GLO_ALM_pt;


//#define UBXID_MGA_GLO 0x1306  // already defined, see above


//================================================================
//! MGA_GLO_TIMEOFFSET: Input
/*!
GLONASS Auxiliary Time Offset Assistance
This message allows the delivery of auxiliary GLONASS assistance (including the GLONASS time offsets to other GNSS systems) to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GLO
*/
//================================================================

typedef struct UBX_MGA_GLO_TIMEOFFSET_s
{
    U1  type;                     //!< Message type (0x03 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U2  N;                        //!< Reference calender day number within the four-year period of almanac (from string 5)
    I4  tauC;                     //!< Time scale correction to UTC(SU) time
    I4  tauGps;                   //!< Correction to GPS time relative to GLONASS time
    I2  B1;                       //!< Coefficient to determine delta UT1
    I2  B2;                       //!< Rate of change of delta UT1
    U1  reserved1[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GLO_TIMEOFFSET_t, *UBX_MGA_GLO_TIMEOFFSET_pt;


//#define UBXID_MGA_GLO 0x1306  // already defined, see above


//================================================================
//! MGA_GPS_EPH: Input
/*!
GPS Ephemeris Assistance
This message allows the delivery of GPS ephemeris assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GPS
*/
//================================================================

typedef struct UBX_MGA_GPS_EPH_s
{
    U1  type;                     //!< Message type (0x01 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< GPS Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  fitInterval;              //!< Fit interval flag
    U1  uraIndex;                 //!< URA index
    U1  svHealth;                 //!< SV health
    I1  tgd;                      //!< Group delay differential
    U2  iodc;                     //!< IODC
    U2  toc;                      //!< Clock data reference time
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I1  af2;                      //!< Time polynomial coefficient 2
    I2  af1;                      //!< Time polynomial coefficient 1
    I4  af0;                      //!< Time polynomial coefficient 0
    I2  crs;                      //!< Crs
    I2  deltaN;                   //!< Mean motion difference from computed value
    I4  m0;                       //!< Mean anomaly at reference time
    I2  cuc;                      //!< Amplitude of cosine harmonic correction term to argument of latitude
    I2  cus;                      //!< Amplitude of sine harmonic correction term to argument of latitude
    U4  e;                        //!< Eccentricity
    U4  sqrtA;                    //!< Square root of the semi-major axis
    U2  toe;                      //!< Reference time of ephemeris
    I2  cic;                      //!< Amplitude of cos harmonic correction term to angle of inclination
    I4  omega0;                   //!< Longitude of ascending node of orbit plane at weekly epoch
    I2  cis;                      //!< Amplitude of sine harmonic correction term to angle of inclination
    I2  crc;                      //!< Amplitude of cosine harmonic correction term to orbit radius
    I4  i0;                       //!< Inclination angle at reference time
    I4  omega;                    //!< Argument of perigee
    I4  omegaDot;                 //!< Rate of right ascension
    I2  idot;                     //!< Rate of inclination angle
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GPS_EPH_t, *UBX_MGA_GPS_EPH_pt;


#define UBXID_MGA_GPS 0x1300 //!< message id for MGA-GPS


//================================================================
//! MGA_GPS_ALM: Input
/*!
GPS Almanac Assistance
This message allows the delivery of GPS almanac assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GPS
*/
//================================================================

typedef struct UBX_MGA_GPS_ALM_s
{
    U1  type;                     //!< Message type (0x02 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< GPS Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  svHealth;                 //!< SV health information
    U2  e;                        //!< Eccentricity
    U1  almWNa;                   //!< Reference week number of almanac (the 8 bit WNa field)
    U1  toa;                      //!< Reference time of almanac
    I2  deltaI;                   //!< Delta inclination angle at reference time
    I2  omegaDot;                 //!< Rate of right ascension
    U4  sqrtA;                    //!< Square root of the semi-major axis
    I4  omega0;                   //!< Longitude of ascending node of orbit plane
    I4  omega;                    //!< Argument of perigee
    I4  m0;                       //!< Mean anomaly at reference time
    I2  af0;                      //!< Time polynomial coefficient 0 (8 MSBs)
    I2  af1;                      //!< Time polynomial coefficient 1
    U1  reserved1[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GPS_ALM_t, *UBX_MGA_GPS_ALM_pt;


//#define UBXID_MGA_GPS 0x1300  // already defined, see above


//================================================================
//! MGA_GPS_HEALTH: Input
/*!
GPS Health Assistance
This message allows the delivery of GPS health assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GPS
*/
//================================================================

typedef struct UBX_MGA_GPS_HEALTH_s
{
    U1  type;                     //!< Message type (0x04 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  healthCode[32];           //!< Each byte represents a GPS SV (1-32). The 6 LSBs of each byte contains the 6 bit health code from subframes 4/5 page 25.
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GPS_HEALTH_t, *UBX_MGA_GPS_HEALTH_pt;


//#define UBXID_MGA_GPS 0x1300  // already defined, see above


//================================================================
//! MGA_GPS_UTC: Input
/*!
GPS UTC Assistance
This message allows the delivery of GPS UTC assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GPS
*/
//================================================================

typedef struct UBX_MGA_GPS_UTC_s
{
    U1  type;                     //!< Message type (0x05 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  utcA0;                    //!< First parameter of UTC polynomial
    I4  utcA1;                    //!< Second parameter of UTC polynomial
    I1  utcDtLS;                  //!< Delta time due to current leap seconds
    U1  utcTot;                   //!< UTC parameters reference time of week (GPS time)
    U1  utcWNt;                   //!< UTC parameters reference week number (the 8 bit WNt field)
    U1  utcWNlsf;                 //!< Week number at the end of which the future leap second becomes effective (the 8 bit WNLSF field)
    U1  utcDn;                    //!< Day number at the end of which the future leap second becomes effective
    I1  utcDtLSF;                 //!< Delta time due to future leap seconds
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GPS_UTC_t, *UBX_MGA_GPS_UTC_pt;


//#define UBXID_MGA_GPS 0x1300  // already defined, see above


//================================================================
//! MGA_GPS_IONO: Input
/*!
GPS Ionosphere Assistance
This message allows the delivery of GPS ionospheric assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_GPS
*/
//================================================================

typedef struct UBX_MGA_GPS_IONO_s
{
    U1  type;                     //!< Message type (0x06 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I1  ionoAlpha0;               //!< Ionospheric parameter alpha0 [s]
    I1  ionoAlpha1;               //!< Ionospheric parameter alpha1 [s/semi-circle]
    I1  ionoAlpha2;               //!< Ionospheric parameter alpha2 [s/semi-circle^2]
    I1  ionoAlpha3;               //!< Ionospheric parameter alpha3 [s/semi-circle^3]
    I1  ionoBeta0;                //!< Ionospheric parameter beta0 [s]
    I1  ionoBeta1;                //!< Ionospheric parameter beta1 [s/semi-circle]
    I1  ionoBeta2;                //!< Ionospheric parameter beta2 [s/semi-circle^2]
    I1  ionoBeta3;                //!< Ionospheric parameter beta3 [s/semi-circle^3]
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_GPS_IONO_t, *UBX_MGA_GPS_IONO_pt;


//#define UBXID_MGA_GPS 0x1300  // already defined, see above


//================================================================
//! MGA_INI_POS_XYZ: Input
/*!
Initial Position Assistance
This message allows the delivery of initial position assistance to a receiver in cartesian ECEF coordinates. This message is equivalent to the <rc href=\"UBX-MGA-INI-POS_LLH'>UBX-MGA-INI-POS_LLH</rc> message, except for the coordinate system. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.

   \note: Supplying position assistance that is inaccurate by more than the specified position accuracy, may lead to substantially degraded receiver performance.

This message's id is #UBXID_MGA_INI
*/
//================================================================

typedef struct UBX_MGA_INI_POS_XYZ_s
{
    U1  type;                     //!< Message type (0x00 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  ecefX;                    //!< WGS84 ECEF X coordinate
    I4  ecefY;                    //!< WGS84 ECEF Y coordinate
    I4  ecefZ;                    //!< WGS84 ECEF Z coordinate
    U4  posAcc;                   //!< Position accuracy (stddev)

} UBX_MGA_INI_POS_XYZ_t, *UBX_MGA_INI_POS_XYZ_pt;


#define UBXID_MGA_INI 0x1340 //!< message id for MGA-INI


//================================================================
//! MGA_INI_POS_LLH: Input
/*!
Initial Position Assistance
This message allows the delivery of initial position assistance to a receiver in WGS84 lat/long/alt coordinates. This message is equivalent to the <rc href=\"UBX-MGA-INI-POS_XYZ'>UBX-MGA-INI-POS_XYZ</rc> message, except for the coordinate system. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.

   \note: Supplying position assistance that is inaccurate by more than the specified position accuracy, may lead to substantially degraded receiver performance.

This message's id is #UBXID_MGA_INI
*/
//================================================================

typedef struct UBX_MGA_INI_POS_LLH_s
{
    U1  type;                     //!< Message type (0x01 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  lat;                      //!< WGS84 Latitude
    I4  lon;                      //!< WGS84 Longitude
    I4  alt;                      //!< WGS84 Altitude
    U4  posAcc;                   //!< Position accuracy (stddev)

} UBX_MGA_INI_POS_LLH_t, *UBX_MGA_INI_POS_LLH_pt;


//#define UBXID_MGA_INI 0x1340  // already defined, see above


//================================================================
//! MGA_INI_TIME_UTC: Input
/*!
Initial Time Assistance
This message allows the delivery of UTC time assistance to a receiver. This message is equivalent to the <rc href=\"UBX-MGA-INI-TIME_GNSS'>UBX-MGA-INI-TIME_GNSS</rc> message, except for the time base. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.

   \note: Supplying time assistance that is inaccurate by more than the specified time accuracy, may lead to substantially degraded receiver performance.

This message's id is #UBXID_MGA_INI
*/
//================================================================

typedef struct UBX_MGA_INI_TIME_UTC_s
{
    U1  type;                     //!< Message type (0x10 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    X1  ref;                      //!< Reference to be used to set time
    I1  leapSecs;                 //!< Number of leap seconds since 1980 (or 0x80 = -128 if unknown)
    U2  year;                     //!< Year
    U1  month;                    //!< Month, starting at 1
    U1  day;                      //!< Day, starting at 1
    U1  hour;                     //!< Hour, from 0 to 23
    U1  minute;                   //!< Minute, from 0 to 59
    U1  second;                   //!< Seconds, from 0 to 59
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  ns;                       //!< Nanoseconds, from 0 to 999,999,999
    U2  tAccS;                    //!< Seconds part of time accuracy
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  tAccNs;                   //!< Nanoseconds part of time accuracy, from 0 to 999,999,999

} UBX_MGA_INI_TIME_UTC_t, *UBX_MGA_INI_TIME_UTC_pt;


//! \name Bit Definitions for #UBX_MGA_INI_TIME_UTC_s::ref
//@{
#define UBX_MGA_INI_TIME_UTC_REF_SOURCE_MASK 0x0f  //!< Mask for field source in bitmask ref
#define UBX_MGA_INI_TIME_UTC_REF_SOURCE_GET(val)  (U)(((val)&UBX_MGA_INI_TIME_UTC_REF_SOURCE_MASK)>>0)  //!< Get source from bitmask ref
#define UBX_MGA_INI_TIME_UTC_REF_FALL_MASK 0x10  //!< Mask for field fall in bitmask ref
#define UBX_MGA_INI_TIME_UTC_REF_FALL_GET(val)  (U)(((val)&UBX_MGA_INI_TIME_UTC_REF_FALL_MASK)>>4)  //!< Get fall from bitmask ref
#define UBX_MGA_INI_TIME_UTC_REF_LAST_MASK 0x20  //!< Mask for field last in bitmask ref
#define UBX_MGA_INI_TIME_UTC_REF_LAST_GET(val)  (U)(((val)&UBX_MGA_INI_TIME_UTC_REF_LAST_MASK)>>5)  //!< Get last from bitmask ref

//@}

//#define UBXID_MGA_INI 0x1340  // already defined, see above


//================================================================
//! MGA_INI_TIME_GNSS: Input
/*!
Initial Time Assistance
This message allows the delivery of time assistance to a receiver in a chosen GNSS timebase. This message is equivalent to the <rc href=\"UBX-MGA-INI-TIME_UTC'>UBX-MGA-INI-TIME_UTC</rc> message, except for the time base. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.

   \note: Supplying time assistance that is inaccurate by more than the specified time accuracy, may lead to substantially degraded receiver performance.

This message's id is #UBXID_MGA_INI
*/
//================================================================

typedef struct UBX_MGA_INI_TIME_GNSS_s
{
    U1  type;                     //!< Message type (0x11 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    X1  ref;                      //!< Reference to be used to set time
    U1  gnssId;                   //!< Source of time information. Currently supported:
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  week;                     //!< GNSS week number
    U4  tow;                      //!< GNSS time of week
    U4  ns;                       //!< GNSS time of week, nanosecond part from 0 to 999,999,999
    U2  tAccS;                    //!< Seconds part of time accuracy
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  tAccNs;                   //!< Nanoseconds part of time accuracy, from 0 to 999,999,999

} UBX_MGA_INI_TIME_GNSS_t, *UBX_MGA_INI_TIME_GNSS_pt;


//! \name Bit Definitions for #UBX_MGA_INI_TIME_GNSS_s::ref
//@{
#define UBX_MGA_INI_TIME_GNSS_REF_SOURCE_MASK 0x0f  //!< Mask for field source in bitmask ref
#define UBX_MGA_INI_TIME_GNSS_REF_SOURCE_GET(val)  (U)(((val)&UBX_MGA_INI_TIME_GNSS_REF_SOURCE_MASK)>>0)  //!< Get source from bitmask ref
#define UBX_MGA_INI_TIME_GNSS_REF_FALL_MASK 0x10  //!< Mask for field fall in bitmask ref
#define UBX_MGA_INI_TIME_GNSS_REF_FALL_GET(val)  (U)(((val)&UBX_MGA_INI_TIME_GNSS_REF_FALL_MASK)>>4)  //!< Get fall from bitmask ref
#define UBX_MGA_INI_TIME_GNSS_REF_LAST_MASK 0x20  //!< Mask for field last in bitmask ref
#define UBX_MGA_INI_TIME_GNSS_REF_LAST_GET(val)  (U)(((val)&UBX_MGA_INI_TIME_GNSS_REF_LAST_MASK)>>5)  //!< Get last from bitmask ref

//@}

//#define UBXID_MGA_INI 0x1340  // already defined, see above


//================================================================
//! MGA_INI_CLKD: Input
/*!
Initial Clock Drift Assistance
This message allows the delivery of clock drift assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.

   \note: Supplying clock drift assistance that is inaccurate by more than the specified accuracy, may lead to substantially degraded receiver performance.

This message's id is #UBXID_MGA_INI
*/
//================================================================

typedef struct UBX_MGA_INI_CLKD_s
{
    U1  type;                     //!< Message type (0x20 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  clkD;                     //!< Clock drift
    U4  clkDAcc;                  //!< Clock drift accuracy

} UBX_MGA_INI_CLKD_t, *UBX_MGA_INI_CLKD_pt;


//#define UBXID_MGA_INI 0x1340  // already defined, see above


//================================================================
//! MGA_INI_FREQ: Input
/*!
Initial Frequency Assistance
This message allows the delivery of external frequency assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.

   \note: Supplying external frequency assistance that is inaccurate by more than the specified accuracy, may lead to substantially degraded receiver performance.

This message's id is #UBXID_MGA_INI
*/
//================================================================

typedef struct UBX_MGA_INI_FREQ_s
{
    U1  type;                     //!< Message type (0x21 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X1  flags;                    //!< Frequency reference
    I4  freq;                     //!< Frequency
    U4  freqAcc;                  //!< Frequency accuracy

} UBX_MGA_INI_FREQ_t, *UBX_MGA_INI_FREQ_pt;


//! \name Bit Definitions for #UBX_MGA_INI_FREQ_s::flags
//@{
#define UBX_MGA_INI_FREQ_FLAGS_SOURCE_MASK 0x0f  //!< Mask for field source in bitmask flags
#define UBX_MGA_INI_FREQ_FLAGS_SOURCE_GET(val)  (U)(((val)&UBX_MGA_INI_FREQ_FLAGS_SOURCE_MASK)>>0)  //!< Get source from bitmask flags
#define UBX_MGA_INI_FREQ_FLAGS_FALL_MASK 0x10  //!< Mask for field fall in bitmask flags
#define UBX_MGA_INI_FREQ_FLAGS_FALL_GET(val)  (U)(((val)&UBX_MGA_INI_FREQ_FLAGS_FALL_MASK)>>4)  //!< Get fall from bitmask flags

//@}

//#define UBXID_MGA_INI 0x1340  // already defined, see above


//================================================================
//! MGA_INI_EOP: Input
/*!
Earth Orientation Parameters Assistance
This message allows the delivery of new Earth Orientation Parameters (EOP) to a receiver to improve AssistNow Autonomous operation.


This message's id is #UBXID_MGA_INI
*/
//================================================================

typedef struct UBX_MGA_INI_EOP_s
{
    U1  type;                     //!< Message type (0x30 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  d2kRef;                   //!< reference time (days since 1.1.2000 12.00h UTC)
    U2  d2kMax;                   //!< expiration time (days since 1.1.2000 12.00h UTC)
    I4  xpP0;                     //!< x_p t^0 polynomial term (offset)
    I4  xpP1;                     //!< x_p t^1 polynomial term (drift)
    I4  ypP0;                     //!< y_p t^0 polynomial term (offset)
    I4  ypP1;                     //!< y_p t^1 polynomial term (drift)
    I4  dUT1;                     //!< dUT1 t^0 polynomial term (offset)
    I4  ddUT1;                    //!< dUT1 t^1 polynomial term (drift)
    U1  reserved2[40];            //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_INI_EOP_t, *UBX_MGA_INI_EOP_pt;


//#define UBXID_MGA_INI 0x1340  // already defined, see above


//================================================================
//! MGA_QZSS_EPH: Input
/*!
QZSS Ephemeris Assistance
This message allows the delivery of QZSS ephemeris assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_QZSS
*/
//================================================================

typedef struct UBX_MGA_QZSS_EPH_s
{
    U1  type;                     //!< Message type (0x01 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< QZSS Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>), Range 1-5
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  fitInterval;              //!< Fit interval flag
    U1  uraIndex;                 //!< URA index
    U1  svHealth;                 //!< SV health
    I1  tgd;                      //!< Group delay differential
    U2  iodc;                     //!< IODC
    U2  toc;                      //!< Clock data reference time
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I1  af2;                      //!< Time polynomial coefficient 2
    I2  af1;                      //!< Time polynomial coefficient 1
    I4  af0;                      //!< Time polynomial coefficient 0
    I2  crs;                      //!< Crs
    I2  deltaN;                   //!< Mean motion difference from computed value
    I4  m0;                       //!< Mean anomaly at reference time
    I2  cuc;                      //!< Amp of cosine harmonic corr term to arg of lat
    I2  cus;                      //!< Amp of sine harmonic corr term to arg of lat
    U4  e;                        //!< eccentricity
    U4  sqrtA;                    //!< Square root of the semi-major axis A
    U2  toe;                      //!< Reference time of ephemeris
    I2  cic;                      //!< Amp of cos harmonic corr term to angle of inclination
    I4  omega0;                   //!< Long of asc node of orbit plane at weekly epoch
    I2  cis;                      //!< Amp of sine harmonic corr term to angle of inclination
    I2  crc;                      //!< Amp of cosine harmonic corr term to orbit radius
    I4  i0;                       //!< Inclination angle at reference time
    I4  omega;                    //!< Argument of perigee
    I4  omegaDot;                 //!< Rate of right ascension
    I2  idot;                     //!< Rate of inclination angle
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_QZSS_EPH_t, *UBX_MGA_QZSS_EPH_pt;


#define UBXID_MGA_QZSS 0x1305 //!< message id for MGA-QZSS


//================================================================
//! MGA_QZSS_ALM: Input
/*!
QZSS Almanac Assistance
This message allows the delivery of QZSS almanac assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_QZSS
*/
//================================================================

typedef struct UBX_MGA_QZSS_ALM_s
{
    U1  type;                     //!< Message type (0x02 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  svId;                     //!< QZSS Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>), Range 1-5
    U1  svHealth;                 //!< Almanac SV health information
    U2  e;                        //!< Almanac eccentricity
    U1  almWNa;                   //!< Reference week number of almanac (the 8 bit WNa field)
    U1  toa;                      //!< Reference time of almanac
    I2  deltaI;                   //!< Delta inclination angle at reference time
    I2  omegaDot;                 //!< Almanac rate of right ascension
    U4  sqrtA;                    //!< Almanac square root of the semi-major axis A
    I4  omega0;                   //!< Almanac long of asc node of orbit plane at weekly
    I4  omega;                    //!< Almanac argument of perigee
    I4  m0;                       //!< Almanac mean anomaly at reference time
    I2  af0;                      //!< Almanac time polynomial coefficient 0 (8 MSBs)
    I2  af1;                      //!< Almanac time polynomial coefficient 1
    U1  reserved1[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_QZSS_ALM_t, *UBX_MGA_QZSS_ALM_pt;


//#define UBXID_MGA_QZSS 0x1305  // already defined, see above


//================================================================
//! MGA_QZSS_HEALTH: Input
/*!
QZSS Health Assistance
This message allows the delivery of QZSS health assistance to a receiver. See the description of <r href=\"MGA-Online'>AssistNow Online</r> for details.


This message's id is #UBXID_MGA_QZSS
*/
//================================================================

typedef struct UBX_MGA_QZSS_HEALTH_s
{
    U1  type;                     //!< Message type (0x04 for this type)
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  healthCode[5];            //!< Each byte represents a QZSS SV (1-5). The 6 LSBs of each byte contains the 6 bit health code from subframes 4/5, data ID = 3, SV ID = 51
    U1  reserved2[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MGA_QZSS_HEALTH_t, *UBX_MGA_QZSS_HEALTH_pt;


//#define UBXID_MGA_QZSS 0x1305  // already defined, see above


//================================================================
//! MON_GNSS_DATA0: Polled
/*!
Information message major GNSS selection
This message reports major GNSS selection. It does this by means of bit masks in U1 fields. Each bit in a bit mask corresponds to one major GNSS. Augmentation systems are not reported.


This message's id is #UBXID_MON_GNSS
*/
//================================================================

typedef struct UBX_MON_GNSS_DATA0_s
{
    U1  version;                  //!< Message version (0x01for this version)
    X1  supported;                //!< A bit mask showing the major GNSS that can be supported by this receiver
    X1  defaultGnss;              //!< A bit mask showing the default major GNSS selection. If the default major GNSS selection is currently configured in the efuse for this receiver, it takes precedence over the default major GNSS selection configured in the executing firmware of this receiver.
    X1  enabled;                  //!< A bit mask showing the current major GNSS selection enabled for this receiver
    U1  simultaneous;             //!< Maximum number of concurrent major GNSS that can be supported by this receiver
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MON_GNSS_DATA0_t, *UBX_MON_GNSS_DATA0_pt;


//! \name Bit Definitions for #UBX_MON_GNSS_DATA0_s::supported
//@{
#define UBX_MON_GNSS_DATA0_SUPPORTED_GPSSUP_MASK 0x01  //!< Mask for field GPSSup in bitmask supported
#define UBX_MON_GNSS_DATA0_SUPPORTED_GPSSUP_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_SUPPORTED_GPSSUP_MASK)>>0)  //!< Get GPSSup from bitmask supported
#define UBX_MON_GNSS_DATA0_SUPPORTED_GLONASSSUP_MASK 0x02  //!< Mask for field GlonassSup in bitmask supported
#define UBX_MON_GNSS_DATA0_SUPPORTED_GLONASSSUP_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_SUPPORTED_GLONASSSUP_MASK)>>1)  //!< Get GlonassSup from bitmask supported
#define UBX_MON_GNSS_DATA0_SUPPORTED_BEIDOUSUP_MASK 0x04  //!< Mask for field BeidouSup in bitmask supported
#define UBX_MON_GNSS_DATA0_SUPPORTED_BEIDOUSUP_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_SUPPORTED_BEIDOUSUP_MASK)>>2)  //!< Get BeidouSup from bitmask supported
#define UBX_MON_GNSS_DATA0_SUPPORTED_GALILEOSUP_MASK 0x08  //!< Mask for field GalileoSup in bitmask supported
#define UBX_MON_GNSS_DATA0_SUPPORTED_GALILEOSUP_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_SUPPORTED_GALILEOSUP_MASK)>>3)  //!< Get GalileoSup from bitmask supported

//@}
//! \name Bit Definitions for #UBX_MON_GNSS_DATA0_s::defaultGnss
//@{
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_GPSDEF_MASK 0x01  //!< Mask for field GPSDef in bitmask defaultGnss
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_GPSDEF_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_DEFAULTGNSS_GPSDEF_MASK)>>0)  //!< Get GPSDef from bitmask defaultGnss
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_GLONASSDEF_MASK 0x02  //!< Mask for field GlonassDef in bitmask defaultGnss
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_GLONASSDEF_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_DEFAULTGNSS_GLONASSDEF_MASK)>>1)  //!< Get GlonassDef from bitmask defaultGnss
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_BEIDOUDEF_MASK 0x04  //!< Mask for field BeidouDef in bitmask defaultGnss
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_BEIDOUDEF_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_DEFAULTGNSS_BEIDOUDEF_MASK)>>2)  //!< Get BeidouDef from bitmask defaultGnss
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_GALILEODEF_MASK 0x08  //!< Mask for field GalileoDef in bitmask defaultGnss
#define UBX_MON_GNSS_DATA0_DEFAULTGNSS_GALILEODEF_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_DEFAULTGNSS_GALILEODEF_MASK)>>3)  //!< Get GalileoDef from bitmask defaultGnss

//@}
//! \name Bit Definitions for #UBX_MON_GNSS_DATA0_s::enabled
//@{
#define UBX_MON_GNSS_DATA0_ENABLED_GPSENA_MASK 0x01  //!< Mask for field GPSEna in bitmask enabled
#define UBX_MON_GNSS_DATA0_ENABLED_GPSENA_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_ENABLED_GPSENA_MASK)>>0)  //!< Get GPSEna from bitmask enabled
#define UBX_MON_GNSS_DATA0_ENABLED_GLONASSENA_MASK 0x02  //!< Mask for field GlonassEna in bitmask enabled
#define UBX_MON_GNSS_DATA0_ENABLED_GLONASSENA_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_ENABLED_GLONASSENA_MASK)>>1)  //!< Get GlonassEna from bitmask enabled
#define UBX_MON_GNSS_DATA0_ENABLED_BEIDOUENA_MASK 0x04  //!< Mask for field BeidouEna in bitmask enabled
#define UBX_MON_GNSS_DATA0_ENABLED_BEIDOUENA_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_ENABLED_BEIDOUENA_MASK)>>2)  //!< Get BeidouEna from bitmask enabled
#define UBX_MON_GNSS_DATA0_ENABLED_GALILEOENA_MASK 0x08  //!< Mask for field GalileoEna in bitmask enabled
#define UBX_MON_GNSS_DATA0_ENABLED_GALILEOENA_GET(val)  (U)(((val)&UBX_MON_GNSS_DATA0_ENABLED_GALILEOENA_MASK)>>3)  //!< Get GalileoEna from bitmask enabled

//@}

#define UBXID_MON_GNSS 0x0A28 //!< message id for MON-GNSS


//================================================================
//! MON_HW2_DATA0: Periodic/Polled
/*!
Extended Hardware Status
Status of different aspects of the hardware such as Imbalance, Low-Level Configuration and POST Results.
The first four parameters of this message represent the complex signal from the RF front end. The following rules of thumb apply:
* The smaller the absolute value of the variable <c>ofsI</c> and <c>ofsQ</c>, the better.
* Ideally, the magnitude of the I-part (<c>magI</c>) and the Q-part (<c>magQ</c>) of the complex signal should be the same.


This message's id is #UBXID_MON_HW2
*/
//================================================================

typedef struct UBX_MON_HW2_DATA0_s
{
    I1  ofsI;                     //!< Imbalance of I-part of complex signal, scaled (-128 = max. negative imbalance, 127 = max. positive imbalance)
    U1  magI;                     //!< Magnitude of I-part of complex signal, scaled (0 = no signal, 255 = max. magnitude)
    I1  ofsQ;                     //!< Imbalance of Q-part of complex signal, scaled (-128 = max. negative imbalance, 127 = max. positive imbalance)
    U1  magQ;                     //!< Magnitude of Q-part of complex signal, scaled (0 = no signal, 255 = max. magnitude)
    U1  cfgSource;                //!< Source of low-level configuration
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  lowLevCfg;                //!< Low-level configuration (obsolete in <r href='FIRMWARE-PROTOCOLVERSION'>protocol versions greater than 15</r>)
    U1  reserved2[8];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  postStatus;               //!< POST status word
    U1  reserved3[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MON_HW2_DATA0_t, *UBX_MON_HW2_DATA0_pt;


#define UBXID_MON_HW2 0x0A0B //!< message id for MON-HW2


//================================================================
//! MON_HW_TITLIS: Periodic/Polled
/*!
Hardware Status
Status of different aspect of the hardware, such as Antenna, PIO/Peripheral Pins, Noise Level, Automatic Gain Control (AGC)


This message's id is #UBXID_MON_HW
*/
//================================================================

typedef struct UBX_MON_HW_TITLIS_s
{
    X4  pinSel;                   //!< Mask of Pins Set as Peripheral/PIO
    X4  pinBank;                  //!< Mask of Pins Set as Bank A/B
    X4  pinDir;                   //!< Mask of Pins Set as Input/Output
    X4  pinVal;                   //!< Mask of Pins Value Low/High
    U2  noisePerMS;               //!< Noise Level as measured by the GPS Core
    U2  agcCnt;                   //!< AGC Monitor (counts SIGHI xor SIGLO, range 0 to 8191)
    U1  aStatus;                  //!< Status of the Antenna Supervisor State Machine (0=INIT, 1=DONTKNOW, 2=OK, 3=SHORT, 4=OPEN)
    U1  aPower;                   //!< Current PowerStatus of Antenna (0=OFF, 1=ON, 2=DONTKNOW)
    X1  flags;                    //!< Flags
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X4  usedMask;                 //!< Mask of Pins that are used by the Virtual Pin Manager
    U1  VP[17];                   //!< Array of Pin Mappings for each of the 17 Physical Pins
    U1  jamInd;                   //!< CW Jamming indicator, scaled (0 = no CW jamming, 255 = strong CW jamming)
    U1  reserved2[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X4  pinIrq;                   //!< Mask of Pins Value using the PIO Irq
    X4  pullH;                    //!< Mask of Pins Value using the PIO Pull High Resistor
    X4  pullL;                    //!< Mask of Pins Value using the PIO Pull Low Resistor

} UBX_MON_HW_TITLIS_t, *UBX_MON_HW_TITLIS_pt;


//! \name Bit Definitions for #UBX_MON_HW_TITLIS_s::flags
//@{
#define UBX_MON_HW_TITLIS_FLAGS_RTCCALIB_MASK 0x1  //!< Mask for field rtcCalib in bitmask flags
#define UBX_MON_HW_TITLIS_FLAGS_RTCCALIB_GET(val)  (U)(((val)&UBX_MON_HW_TITLIS_FLAGS_RTCCALIB_MASK)>>0)  //!< Get rtcCalib from bitmask flags
#define UBX_MON_HW_TITLIS_FLAGS_SAFEBOOT_MASK 0x2  //!< Mask for field safeBoot in bitmask flags
#define UBX_MON_HW_TITLIS_FLAGS_SAFEBOOT_GET(val)  (U)(((val)&UBX_MON_HW_TITLIS_FLAGS_SAFEBOOT_MASK)>>1)  //!< Get safeBoot from bitmask flags
#define UBX_MON_HW_TITLIS_FLAGS_JAMMINGSTATE_MASK 0xC  //!< Mask for field jammingState in bitmask flags
#define UBX_MON_HW_TITLIS_FLAGS_JAMMINGSTATE_GET(val)  (U)(((val)&UBX_MON_HW_TITLIS_FLAGS_JAMMINGSTATE_MASK)>>2)  //!< Get jammingState from bitmask flags
#define UBX_MON_HW_TITLIS_FLAGS_XTALABSENT_MASK 0x10  //!< Mask for field xtalAbsent in bitmask flags
#define UBX_MON_HW_TITLIS_FLAGS_XTALABSENT_GET(val)  (U)(((val)&UBX_MON_HW_TITLIS_FLAGS_XTALABSENT_MASK)>>4)  //!< Get xtalAbsent from bitmask flags

//@}

#define UBXID_MON_HW 0x0A09 //!< message id for MON-HW


//================================================================
//! MON_IO_DATA0: Periodic/Polled
/*!
I/O Subsystem Status
The size of the message is determined by the number of ports 'N' the receiver supports, i.e. on u-blox 5 the number of ports is 6.


This message's id is #UBXID_MON_IO
*/
//================================================================

//! Optional Sub-Structure of #UBX_MON_IO_DATA0_t
typedef struct UBX_MON_IO_DATA0_RXBYTES_s
{
    U4  rxBytes;                  //!< Number of bytes ever received
    U4  txBytes;                  //!< Number of bytes ever sent
    U2  parityErrs;               //!< Number of 100ms timeslots with parity errors
    U2  framingErrs;              //!< Number of 100ms timeslots with framing errors
    U2  overrunErrs;              //!< Number of 100ms timeslots with overrun errors
    U2  breakCond;                //!< Number of 100ms timeslots with break conditions
    U1  rxBusy;                   //!< Flag is receiver is busy
    U1  txBusy;                   //!< Flag is transmitter is busy
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MON_IO_DATA0_RXBYTES_t, *UBX_MON_IO_DATA0_RXBYTES_pt;



typedef struct UBX_MON_IO_DATA0_s
{
    //REPEAT: UBX_MON_IO_DATA0_RXBYTES_t repeat0[N];

} UBX_MON_IO_DATA0_t, *UBX_MON_IO_DATA0_pt;


#define UBXID_MON_IO 0x0A02 //!< message id for MON-IO


//================================================================
//! MON_MSGPP_U5: Periodic/Polled
/*!
Message Parse and Process Status
-


This message's id is #UBXID_MON_MSGPP
*/
//================================================================

typedef struct UBX_MON_MSGPP_U5_s
{
    U2  msg1[8];                  //!< Number of successfully parsed messages for each protocol on port0
    U2  msg2[8];                  //!< Number of successfully parsed messages for each protocol on port1
    U2  msg3[8];                  //!< Number of successfully parsed messages for each protocol on port2
    U2  msg4[8];                  //!< Number of successfully parsed messages for each protocol on port3
    U2  msg5[8];                  //!< Number of successfully parsed messages for each protocol on port4
    U2  msg6[8];                  //!< Number of successfully parsed messages for each protocol on port5
    U4  skipped[6];               //!< Number skipped bytes for each port

} UBX_MON_MSGPP_U5_t, *UBX_MON_MSGPP_U5_pt;


#define UBXID_MON_MSGPP 0x0A06 //!< message id for MON-MSGPP


//================================================================
//! MON_PATCH_POLL0: Poll Request
/*!
Poll Request for installed patches
-


This message's id is #UBXID_MON_PATCH
*/
//================================================================

typedef struct UBX_MON_PATCH_POLL0_s
{

} UBX_MON_PATCH_POLL0_t, *UBX_MON_PATCH_POLL0_pt;


#define UBXID_MON_PATCH 0x0A27 //!< message id for MON-PATCH


//================================================================
//! MON_PATCH_DATA0: Polled
/*!
Output information about installed patches.
-


This message's id is #UBXID_MON_PATCH
*/
//================================================================

//! Optional Sub-Structure of #UBX_MON_PATCH_DATA0_t
typedef struct UBX_MON_PATCH_DATA0_PATCHINFO_s
{
    X4  patchInfo;                //!< Additional information about the patch not stated in the patch header.
    U4  comparatorNumber;         //!< The number of the comparator.
    U4  patchAddress;             //!< The address that the targeted by the patch.
    U4  patchData;                //!< The data that will be inserted at the patchAddress.

} UBX_MON_PATCH_DATA0_PATCHINFO_t, *UBX_MON_PATCH_DATA0_PATCHINFO_pt;

//! \name Bit Definitions for #UBX_MON_PATCH_DATA0_PATCHINFO_s::patchInfo
//@{
#define UBX_MON_PATCH_DATA0_PATCHINFO_PATCHINFO_ACTIVATED_MASK 0x00000001  //!< Mask for field activated in bitmask patchInfo
#define UBX_MON_PATCH_DATA0_PATCHINFO_PATCHINFO_ACTIVATED_GET(val)  (U)(((val)&UBX_MON_PATCH_DATA0_PATCHINFO_PATCHINFO_ACTIVATED_MASK)>>0)  //!< Get activated from bitmask patchInfo
#define UBX_MON_PATCH_DATA0_PATCHINFO_PATCHINFO_LOCATION_MASK 0x00000006  //!< Mask for field location in bitmask patchInfo
#define UBX_MON_PATCH_DATA0_PATCHINFO_PATCHINFO_LOCATION_GET(val)  (U)(((val)&UBX_MON_PATCH_DATA0_PATCHINFO_PATCHINFO_LOCATION_MASK)>>1)  //!< Get location from bitmask patchInfo

//@}


typedef struct UBX_MON_PATCH_DATA0_s
{
    U2  version;                  //!< Type of the message. 0x1 for this one.
    U2  nEntries;                 //!< The number of patches that is output.
    //REPEAT: UBX_MON_PATCH_DATA0_PATCHINFO_t repeat0[nEntries];

} UBX_MON_PATCH_DATA0_t, *UBX_MON_PATCH_DATA0_pt;


//#define UBXID_MON_PATCH 0x0A27  // already defined, see above


//================================================================
//! MON_RXBUF_U5: Periodic/Polled
/*!
Receiver Buffer Status
-


This message's id is #UBXID_MON_RXBUF
*/
//================================================================

typedef struct UBX_MON_RXBUF_U5_s
{
    U2  pending[6];               //!< Number of bytes pending in receiver buffer for each target
    U1  usage[6];                 //!< Maximum usage receiver buffer during the last sysmon period for each target
    U1  peakUsage[6];             //!< Maximum usage receiver buffer for each target

} UBX_MON_RXBUF_U5_t, *UBX_MON_RXBUF_U5_pt;


#define UBXID_MON_RXBUF 0x0A07 //!< message id for MON-RXBUF


//================================================================
//! MON_RXR_VER0: Output
/*!
Receiver Status Information
The receiver ready message is sent when the receiver changes from or to backup mode.


This message's id is #UBXID_MON_RXR
*/
//================================================================

typedef struct UBX_MON_RXR_VER0_s
{
    X1  flags;                    //!< Receiver status flags

} UBX_MON_RXR_VER0_t, *UBX_MON_RXR_VER0_pt;


//! \name Bit Definitions for #UBX_MON_RXR_VER0_s::flags
//@{
#define UBX_MON_RXR_VER0_FLAGS_AWAKE_MASK 0x00000001  //!< Mask for field awake in bitmask flags
#define UBX_MON_RXR_VER0_FLAGS_AWAKE_GET(val)  (U)(((val)&UBX_MON_RXR_VER0_FLAGS_AWAKE_MASK)>>0)  //!< Get awake from bitmask flags

//@}

#define UBXID_MON_RXR 0x0A21 //!< message id for MON-RXR


//================================================================
//! MON_SMGR_DATA0: Periodic/Polled
/*!
Synchronization Manager Status
This message reports the status of internal and external oscillators and sources as well as whether GNSS is used for disciplining.


This message's id is #UBXID_MON_SMGR
*/
//================================================================

typedef struct UBX_MON_SMGR_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  iTOW;                     //!< Time of the week
    X2  intOsc;                   //!< A bit mask, indicating the status of the local oscillator
    X2  extOsc;                   //!< A bit mask, indicating the status of the external oscillator
    U1  discSrc;                  //!< Disciplining source identifier:
    X1  gnss;                     //!< A bit mask, indicating the status of the GNSS
    X1  extInt0;                  //!< A bit mask, indicating the status of the external input 0
    X1  extInt1;                  //!< A bit mask, indicating the status of the external input 1

} UBX_MON_SMGR_DATA0_t, *UBX_MON_SMGR_DATA0_pt;


//! \name Bit Definitions for #UBX_MON_SMGR_DATA0_s::intOsc
//@{
#define UBX_MON_SMGR_DATA0_INTOSC_INTOSCSTATE_MASK 0x0F  //!< Mask for field intOscState in bitmask intOsc
#define UBX_MON_SMGR_DATA0_INTOSC_INTOSCSTATE_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_INTOSC_INTOSCSTATE_MASK)>>0)  //!< Get intOscState from bitmask intOsc
#define UBX_MON_SMGR_DATA0_INTOSC_INTOSCCALIB_MASK 0x10  //!< Mask for field intOscCalib in bitmask intOsc
#define UBX_MON_SMGR_DATA0_INTOSC_INTOSCCALIB_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_INTOSC_INTOSCCALIB_MASK)>>4)  //!< Get intOscCalib from bitmask intOsc
#define UBX_MON_SMGR_DATA0_INTOSC_INTOSCDISC_MASK 0x20  //!< Mask for field intOscDisc in bitmask intOsc
#define UBX_MON_SMGR_DATA0_INTOSC_INTOSCDISC_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_INTOSC_INTOSCDISC_MASK)>>5)  //!< Get intOscDisc from bitmask intOsc

//@}
//! \name Bit Definitions for #UBX_MON_SMGR_DATA0_s::extOsc
//@{
#define UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCSTATE_MASK 0x0F  //!< Mask for field extOscState in bitmask extOsc
#define UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCSTATE_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCSTATE_MASK)>>0)  //!< Get extOscState from bitmask extOsc
#define UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCCALIB_MASK 0x10  //!< Mask for field extOscCalib in bitmask extOsc
#define UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCCALIB_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCCALIB_MASK)>>4)  //!< Get extOscCalib from bitmask extOsc
#define UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCDISC_MASK 0x20  //!< Mask for field extOscDisc in bitmask extOsc
#define UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCDISC_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTOSC_EXTOSCDISC_MASK)>>5)  //!< Get extOscDisc from bitmask extOsc

//@}
//! \name Bit Definitions for #UBX_MON_SMGR_DATA0_s::gnss
//@{
#define UBX_MON_SMGR_DATA0_GNSS_GNSSAVAIL_MASK 0x01  //!< Mask for field gnssAvail in bitmask gnss
#define UBX_MON_SMGR_DATA0_GNSS_GNSSAVAIL_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_GNSS_GNSSAVAIL_MASK)>>0)  //!< Get gnssAvail from bitmask gnss

//@}
//! \name Bit Definitions for #UBX_MON_SMGR_DATA0_s::extInt0
//@{
#define UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0AVAIL_MASK 0x01  //!< Mask for field extInt0Avail in bitmask extInt0
#define UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0AVAIL_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0AVAIL_MASK)>>0)  //!< Get extInt0Avail from bitmask extInt0
#define UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0TYPE_MASK 0x02  //!< Mask for field extInt0Type in bitmask extInt0
#define UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0TYPE_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0TYPE_MASK)>>1)  //!< Get extInt0Type from bitmask extInt0
#define UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0FEEDBACK_MASK 0x04  //!< Mask for field extInt0FeedBack in bitmask extInt0
#define UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0FEEDBACK_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTINT0_EXTINT0FEEDBACK_MASK)>>2)  //!< Get extInt0FeedBack from bitmask extInt0

//@}
//! \name Bit Definitions for #UBX_MON_SMGR_DATA0_s::extInt1
//@{
#define UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1AVAIL_MASK 0x01  //!< Mask for field extInt1Avail in bitmask extInt1
#define UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1AVAIL_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1AVAIL_MASK)>>0)  //!< Get extInt1Avail from bitmask extInt1
#define UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1TYPE_MASK 0x02  //!< Mask for field extInt1Type in bitmask extInt1
#define UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1TYPE_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1TYPE_MASK)>>1)  //!< Get extInt1Type from bitmask extInt1
#define UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1FEEDBACK_MASK 0x04  //!< Mask for field extInt1FeedBack in bitmask extInt1
#define UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1FEEDBACK_GET(val)  (U)(((val)&UBX_MON_SMGR_DATA0_EXTINT1_EXTINT1FEEDBACK_MASK)>>2)  //!< Get extInt1FeedBack from bitmask extInt1

//@}

#define UBXID_MON_SMGR 0x0A2E //!< message id for MON-SMGR


//================================================================
//! MON_TXBUF_U5: Periodic/Polled
/*!
Transmitter Buffer Status
-


This message's id is #UBXID_MON_TXBUF
*/
//================================================================

typedef struct UBX_MON_TXBUF_U5_s
{
    U2  pending[6];               //!< Number of bytes pending in transmitter buffer for each target
    U1  usage[6];                 //!< Maximum usage transmitter buffer during the last sysmon period for each target
    U1  peakUsage[6];             //!< Maximum usage transmitter buffer for each target
    U1  tUsage;                   //!< Maximum usage of transmitter buffer during the last sysmon period for all targets
    U1  tPeakusage;               //!< Maximum usage of transmitter buffer for all targets
    X1  errors;                   //!< Error bitmask
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_MON_TXBUF_U5_t, *UBX_MON_TXBUF_U5_pt;


//! \name Bit Definitions for #UBX_MON_TXBUF_U5_s::errors
//@{
#define UBX_MON_TXBUF_U5_ERRORS_LIMIT_MASK 0x3F  //!< Mask for field limit in bitmask errors
#define UBX_MON_TXBUF_U5_ERRORS_LIMIT_GET(val)  (U)(((val)&UBX_MON_TXBUF_U5_ERRORS_LIMIT_MASK)>>0)  //!< Get limit from bitmask errors
#define UBX_MON_TXBUF_U5_ERRORS_MEM_MASK 0x40  //!< Mask for field mem in bitmask errors
#define UBX_MON_TXBUF_U5_ERRORS_MEM_GET(val)  (U)(((val)&UBX_MON_TXBUF_U5_ERRORS_MEM_MASK)>>6)  //!< Get mem from bitmask errors
#define UBX_MON_TXBUF_U5_ERRORS_ALLOC_MASK 0x80  //!< Mask for field alloc in bitmask errors
#define UBX_MON_TXBUF_U5_ERRORS_ALLOC_GET(val)  (U)(((val)&UBX_MON_TXBUF_U5_ERRORS_ALLOC_MASK)>>7)  //!< Get alloc from bitmask errors

//@}

#define UBXID_MON_TXBUF 0x0A08 //!< message id for MON-TXBUF


//================================================================
//! MON_VER_POLL0: Poll Request
/*!
Poll Receiver/Software Version
-


This message's id is #UBXID_MON_VER
*/
//================================================================

typedef struct UBX_MON_VER_POLL0_s
{

} UBX_MON_VER_POLL0_t, *UBX_MON_VER_POLL0_pt;


#define UBXID_MON_VER 0x0A04 //!< message id for MON-VER


//================================================================
//! MON_VER_DATA0: Polled
/*!
Receiver/Software Version
-


This message's id is #UBXID_MON_VER
*/
//================================================================

//! Optional Sub-Structure of #UBX_MON_VER_DATA0_t
typedef struct UBX_MON_VER_DATA0_EXTENSION_s
{
    CH  extension[30];            //!< Extended software information strings.

} UBX_MON_VER_DATA0_EXTENSION_t, *UBX_MON_VER_DATA0_EXTENSION_pt;



typedef struct UBX_MON_VER_DATA0_s
{
    CH  swVersion[30];            //!< Zero-terminated Software Version String.
    CH  hwVersion[10];            //!< Zero-terminated Hardware Version String
    //REPEAT: UBX_MON_VER_DATA0_EXTENSION_t repeat0[N];

} UBX_MON_VER_DATA0_t, *UBX_MON_VER_DATA0_pt;


//#define UBXID_MON_VER 0x0A04  // already defined, see above


//================================================================
//! NAV_AOPSTATUS_DATA1: Periodic/Polled
/*!
AssistNow Autonomous Status
This message provides information on the status of the <i>AssistNow Autonomous</i> subsystem on the receiver. For example, a host application can determine the optimal time to shut down the receiver by monitoring the <c>status</c> field for a steady 0. See the chapter <r href=\"AOP-DESC'>AssistNow Autonomous</r> in the receiver description for details on this feature.


This message's id is #UBXID_NAV_AOPSTATUS
*/
//================================================================

typedef struct UBX_NAV_AOPSTATUS_DATA1_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  aopCfg;                   //!< <i>AssistNow Autonomous</i> configuration
    U1  status;                   //!< <i>AssistNow Autonomous</i> subsystem is idle (0) or running (not 0)
    U1  reserved1[10];            //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_NAV_AOPSTATUS_DATA1_t, *UBX_NAV_AOPSTATUS_DATA1_pt;


//! \name Bit Definitions for #UBX_NAV_AOPSTATUS_DATA1_s::aopCfg
//@{
#define UBX_NAV_AOPSTATUS_DATA1_AOPCFG_USEAOP_MASK 0x01  //!< Mask for field useAOP in bitmask aopCfg
#define UBX_NAV_AOPSTATUS_DATA1_AOPCFG_USEAOP_GET(val)  (U)(((val)&UBX_NAV_AOPSTATUS_DATA1_AOPCFG_USEAOP_MASK)>>0)  //!< Get useAOP from bitmask aopCfg

//@}

#define UBXID_NAV_AOPSTATUS 0x0160 //!< message id for NAV-AOPSTATUS


//================================================================
//! NAV_CLOCK_DATA0: Periodic/Polled
/*!
Clock Solution
-


This message's id is #UBXID_NAV_CLOCK
*/
//================================================================

typedef struct UBX_NAV_CLOCK_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  clkB;                     //!< <r href=\"NAV-EPOCH-DESC'>Clock bias</r>
    I4  clkD;                     //!< <r href=\"NAV-EPOCH-DESC'>Clock drift</r>
    U4  tAcc;                     //!< Time accuracy estimate
    U4  fAcc;                     //!< Frequency accuracy estimate

} UBX_NAV_CLOCK_DATA0_t, *UBX_NAV_CLOCK_DATA0_pt;


#define UBXID_NAV_CLOCK 0x0122 //!< message id for NAV-CLOCK


//================================================================
//! NAV_DGPS_DATA0: Periodic/Polled
/*!
DGPS Data Used for NAV
This message outputs the DGPS correction data that has been applied to the current NAV Solution. See also the notes on the <r href=\"RTCM-PROT'>RTCM protocol</r>.


This message's id is #UBXID_NAV_DGPS
*/
//================================================================

//! Optional Sub-Structure of #UBX_NAV_DGPS_DATA0_t
typedef struct UBX_NAV_DGPS_DATA0_SVID_s
{
    U1  svid;                     //!< Satellite ID
    X1  flags;                    //!< Channel number and usage
    U2  ageC;                     //!< Age of latest correction data
    R4  prc;                      //!< Pseudorange correction
    R4  prrc;                     //!< Pseudorange rate correction

} UBX_NAV_DGPS_DATA0_SVID_t, *UBX_NAV_DGPS_DATA0_SVID_pt;

//! \name Bit Definitions for #UBX_NAV_DGPS_DATA0_SVID_s::flags
//@{
#define UBX_NAV_DGPS_DATA0_SVID_FLAGS_CHANNEL_MASK 0x0f  //!< Mask for field channel in bitmask flags
#define UBX_NAV_DGPS_DATA0_SVID_FLAGS_CHANNEL_GET(val)  (U)(((val)&UBX_NAV_DGPS_DATA0_SVID_FLAGS_CHANNEL_MASK)>>0)  //!< Get channel from bitmask flags
#define UBX_NAV_DGPS_DATA0_SVID_FLAGS_DGPSUSED_MASK 0x10  //!< Mask for field dgpsUsed in bitmask flags
#define UBX_NAV_DGPS_DATA0_SVID_FLAGS_DGPSUSED_GET(val)  (U)(((val)&UBX_NAV_DGPS_DATA0_SVID_FLAGS_DGPSUSED_MASK)>>4)  //!< Get dgpsUsed from bitmask flags

//@}


typedef struct UBX_NAV_DGPS_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  age;                      //!< Age of newest correction data
    I2  baseId;                   //!< DGPS base station identifier
    I2  baseHealth;               //!< DGPS base station health status
    U1  numCh;                    //!< Number of channels for which correction data is following
    U1  status;                   //!< DGPS correction type status:
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_NAV_DGPS_DATA0_SVID_t repeat0[numCh];

} UBX_NAV_DGPS_DATA0_t, *UBX_NAV_DGPS_DATA0_pt;


#define UBXID_NAV_DGPS 0x0131 //!< message id for NAV-DGPS


//================================================================
//! NAV_DOP_DATA0: Periodic/Polled
/*!
Dilution of precision
* DOP values are dimensionless.
* All DOP values are scaled by a factor of 100. If the unit transmits a value of e.g. 156, the DOP value is 1.56.


This message's id is #UBXID_NAV_DOP
*/
//================================================================

typedef struct UBX_NAV_DOP_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U2  gDOP;                     //!< Geometric DOP
    U2  pDOP;                     //!< Position DOP
    U2  tDOP;                     //!< Time DOP
    U2  vDOP;                     //!< Vertical DOP
    U2  hDOP;                     //!< Horizontal DOP
    U2  nDOP;                     //!< Northing DOP
    U2  eDOP;                     //!< Easting DOP

} UBX_NAV_DOP_DATA0_t, *UBX_NAV_DOP_DATA0_pt;


#define UBXID_NAV_DOP 0x0104 //!< message id for NAV-DOP


//================================================================
//! NAV_EOE_DATA0: Periodic
/*!
End Of Epoch
This message is intended to be used as a marker to collect all navigation messages of an epoch. It is output after all enabled NAV class messages (except NAV-HNR) and after all enabled NMEA messages.


This message's id is #UBXID_NAV_EOE
*/
//================================================================

typedef struct UBX_NAV_EOE_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.

} UBX_NAV_EOE_DATA0_t, *UBX_NAV_EOE_DATA0_pt;


#define UBXID_NAV_EOE 0x0161 //!< message id for NAV-EOE


//================================================================
//! NAV_GEOFENCE_DATA0: Periodic/Polled
/*!
Geofencing status
This message outputs the evaluated states of all configured geofences for the current epoch's position.
See the <r href=\"GEOFENCE-DESC'>Geofencing description</r> for feature details.


This message's id is #UBXID_NAV_GEOFENCE
*/
//================================================================

//! Optional Sub-Structure of #UBX_NAV_GEOFENCE_DATA0_t
typedef struct UBX_NAV_GEOFENCE_DATA0_STATE_s
{
    U1  state;                    //!< Geofence state
    U1  reserved1[1];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_NAV_GEOFENCE_DATA0_STATE_t, *UBX_NAV_GEOFENCE_DATA0_STATE_pt;



typedef struct UBX_NAV_GEOFENCE_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  version;                  //!< Message version (0x00 for this version)
    U1  status;                   //!< Geofencing status
    U1  numFences;                //!< Number of geofences
    U1  combState;                //!< Combined (logical OR) state of all geofences
    //REPEAT: UBX_NAV_GEOFENCE_DATA0_STATE_t repeat0[numFences];

} UBX_NAV_GEOFENCE_DATA0_t, *UBX_NAV_GEOFENCE_DATA0_pt;


#define UBXID_NAV_GEOFENCE 0x0139 //!< message id for NAV-GEOFENCE


//================================================================
//! NAV_ODO_DATA0: Periodic/Polled
/*!
Odometer Solution
This message outputs the traveled distance since last reset (see <rc href=\"UBX-NAV-RESETODO'>NAV-RESETODO</rc>) together with an associated estimated accuracy and the total cumulated ground distance (can only be reset by a cold start of the receiver).


This message's id is #UBXID_NAV_ODO
*/
//================================================================

typedef struct UBX_NAV_ODO_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U4  distance;                 //!< Ground distance since last reset
    U4  totalDistance;            //!< Total cumulative ground distance
    U4  distanceStd;              //!< Ground distance accuracy (1-sigma)

} UBX_NAV_ODO_DATA0_t, *UBX_NAV_ODO_DATA0_pt;


#define UBXID_NAV_ODO 0x0109 //!< message id for NAV-ODO


//================================================================
//! NAV_ORB_DATA0: Periodic/Polled
/*!
GNSS Orbit Database Info
Status of the GNSS orbit database knowledge.


This message's id is #UBXID_NAV_ORB
*/
//================================================================

//! Optional Sub-Structure of #UBX_NAV_ORB_DATA0_t
typedef struct UBX_NAV_ORB_DATA0_GNSSID_s
{
    U1  gnssId;                   //!< GNSS ID
    U1  svId;                     //!< Satellite ID
    X1  svFlag;                   //!< Information Flags
    X1  eph;                      //!< Ephemeris data
    X1  alm;                      //!< Almanac data
    X1  otherOrb;                 //!< Other orbit data available

} UBX_NAV_ORB_DATA0_GNSSID_t, *UBX_NAV_ORB_DATA0_GNSSID_pt;

//! \name Bit Definitions for #UBX_NAV_ORB_DATA0_GNSSID_s::svFlag
//@{
#define UBX_NAV_ORB_DATA0_GNSSID_SVFLAG_HEALTH_MASK 0x03  //!< Mask for field health in bitmask svFlag
#define UBX_NAV_ORB_DATA0_GNSSID_SVFLAG_HEALTH_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_SVFLAG_HEALTH_MASK)>>0)  //!< Get health from bitmask svFlag
#define UBX_NAV_ORB_DATA0_GNSSID_SVFLAG_VISIBILITY_MASK 0x0C  //!< Mask for field visibility in bitmask svFlag
#define UBX_NAV_ORB_DATA0_GNSSID_SVFLAG_VISIBILITY_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_SVFLAG_VISIBILITY_MASK)>>2)  //!< Get visibility from bitmask svFlag

//@}
//! \name Bit Definitions for #UBX_NAV_ORB_DATA0_GNSSID_s::eph
//@{
#define UBX_NAV_ORB_DATA0_GNSSID_EPH_EPHUSABILITY_MASK 0x1F  //!< Mask for field ephUsability in bitmask eph
#define UBX_NAV_ORB_DATA0_GNSSID_EPH_EPHUSABILITY_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_EPH_EPHUSABILITY_MASK)>>0)  //!< Get ephUsability from bitmask eph
#define UBX_NAV_ORB_DATA0_GNSSID_EPH_EPHSOURCE_MASK 0xE0  //!< Mask for field ephSource in bitmask eph
#define UBX_NAV_ORB_DATA0_GNSSID_EPH_EPHSOURCE_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_EPH_EPHSOURCE_MASK)>>5)  //!< Get ephSource from bitmask eph

//@}
//! \name Bit Definitions for #UBX_NAV_ORB_DATA0_GNSSID_s::alm
//@{
#define UBX_NAV_ORB_DATA0_GNSSID_ALM_ALMUSABILITY_MASK 0x1F  //!< Mask for field almUsability in bitmask alm
#define UBX_NAV_ORB_DATA0_GNSSID_ALM_ALMUSABILITY_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_ALM_ALMUSABILITY_MASK)>>0)  //!< Get almUsability from bitmask alm
#define UBX_NAV_ORB_DATA0_GNSSID_ALM_ALMSOURCE_MASK 0xE0  //!< Mask for field almSource in bitmask alm
#define UBX_NAV_ORB_DATA0_GNSSID_ALM_ALMSOURCE_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_ALM_ALMSOURCE_MASK)>>5)  //!< Get almSource from bitmask alm

//@}
//! \name Bit Definitions for #UBX_NAV_ORB_DATA0_GNSSID_s::otherOrb
//@{
#define UBX_NAV_ORB_DATA0_GNSSID_OTHERORB_ANOAOPUSABILITY_MASK 0x1F  //!< Mask for field anoAopUsability in bitmask otherOrb
#define UBX_NAV_ORB_DATA0_GNSSID_OTHERORB_ANOAOPUSABILITY_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_OTHERORB_ANOAOPUSABILITY_MASK)>>0)  //!< Get anoAopUsability from bitmask otherOrb
#define UBX_NAV_ORB_DATA0_GNSSID_OTHERORB_TYPE_MASK 0xE0  //!< Mask for field type in bitmask otherOrb
#define UBX_NAV_ORB_DATA0_GNSSID_OTHERORB_TYPE_GET(val)  (U)(((val)&UBX_NAV_ORB_DATA0_GNSSID_OTHERORB_TYPE_MASK)>>5)  //!< Get type from bitmask otherOrb

//@}


typedef struct UBX_NAV_ORB_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  version;                  //!< Message version (1, for this version)
    U1  numSv;                    //!< Number of SVs in the database
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_NAV_ORB_DATA0_GNSSID_t repeat0[numSv];

} UBX_NAV_ORB_DATA0_t, *UBX_NAV_ORB_DATA0_pt;


#define UBXID_NAV_ORB 0x0134 //!< message id for NAV-ORB


//================================================================
//! NAV_POSECEF_DATA0: Periodic/Polled
/*!
Position Solution in ECEF
-

   \note: See important comments concerning validity of position given in section <rb href=\"CFG-NAV5-DESC-OUTF'>Navigation Output Filters</rb>.

This message's id is #UBXID_NAV_POSECEF
*/
//================================================================

typedef struct UBX_NAV_POSECEF_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  ecefX;                    //!< ECEF X coordinate
    I4  ecefY;                    //!< ECEF Y coordinate
    I4  ecefZ;                    //!< ECEF Z coordinate
    U4  pAcc;                     //!< Position Accuracy Estimate

} UBX_NAV_POSECEF_DATA0_t, *UBX_NAV_POSECEF_DATA0_pt;


#define UBXID_NAV_POSECEF 0x0101 //!< message id for NAV-POSECEF


//================================================================
//! NAV_POSLLH_DATA0: Periodic/Polled
/*!
Geodetic Position Solution
This message outputs the Geodetic position in the currently selected ellipsoid. The default is the WGS84 Ellipsoid, but can be changed with the message <rc href=\"UBX-CFG-DAT'>CFG-DAT</rc>.

   \note: See important comments concerning validity of position given in section <rb href=\"CFG-NAV5-DESC-OUTF'>Navigation Output Filters</rb>.

This message's id is #UBXID_NAV_POSLLH
*/
//================================================================

typedef struct UBX_NAV_POSLLH_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  lon;                      //!< Longitude
    I4  lat;                      //!< Latitude
    I4  height;                   //!< Height above ellipsoid
    I4  hMSL;                     //!< Height above mean sea level
    U4  hAcc;                     //!< Horizontal accuracy estimate
    U4  vAcc;                     //!< Vertical accuracy estimate

} UBX_NAV_POSLLH_DATA0_t, *UBX_NAV_POSLLH_DATA0_pt;


#define UBXID_NAV_POSLLH 0x0102 //!< message id for NAV-POSLLH


//================================================================
//! NAV_PVT_DATA1: Periodic/Polled
/*!
Navigation Position Velocity Time Solution
This message combines position, velocity and time solution, including accuracy figures

   \note: Note that during a leap second there may be more (or less) than 60 seconds in a minute; see the <rb href=\"LEAP-SECS-DESC'>description of leap seconds</rb> for details.

This message's id is #UBXID_NAV_PVT
*/
//================================================================

typedef struct UBX_NAV_PVT_DATA1_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U2  year;                     //!< Year (UTC)
    U1  month;                    //!< Month, range 1..12 (UTC)
    U1  day;                      //!< Day of month, range 1..31 (UTC)
    U1  hour;                     //!< Hour of day, range 0..23 (UTC)
    U1  min;                      //!< Minute of hour, range 0..59 (UTC)
    U1  sec;                      //!< Seconds of minute, range 0..60 (UTC)
    X1  valid;                    //!< Validity flags
    U4  tAcc;                     //!< Time accuracy estimate (UTC)
    I4  nano;                     //!< Fraction of second, range -1e9 .. 1e9 (UTC)
    U1  fixType;                  //!< GNSSfix Type:
    X1  flags;                    //!< Fix status flags
    X1  flags2;                   //!< Additional flags
    U1  numSV;                    //!< Number of satellites used in Nav Solution
    I4  lon;                      //!< Longitude
    I4  lat;                      //!< Latitude
    I4  height;                   //!< Height above ellipsoid
    I4  hMSL;                     //!< Height above mean sea level
    U4  hAcc;                     //!< Horizontal accuracy estimate
    U4  vAcc;                     //!< Vertical accuracy estimate
    I4  velN;                     //!< NED north velocity
    I4  velE;                     //!< NED east velocity
    I4  velD;                     //!< NED down velocity
    I4  gSpeed;                   //!< Ground Speed (2-D)
    I4  headMot;                  //!< Heading of motion (2-D)
    U4  sAcc;                     //!< Speed accuracy estimate
    U4  headAcc;                  //!< Heading accuracy estimate (both motion and vehicle)
    U2  pDOP;                     //!< Position DOP
    U1  reserved1[6];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  headVeh;                  //!< Heading of vehicle (2-D)
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_NAV_PVT_DATA1_t, *UBX_NAV_PVT_DATA1_pt;


//! \name Bit Definitions for #UBX_NAV_PVT_DATA1_s::valid
//@{
#define UBX_NAV_PVT_DATA1_VALID_VALIDDATE_MASK 0x01  //!< Mask for field validDate in bitmask valid
#define UBX_NAV_PVT_DATA1_VALID_VALIDDATE_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_VALID_VALIDDATE_MASK)>>0)  //!< Get validDate from bitmask valid
#define UBX_NAV_PVT_DATA1_VALID_VALIDTIME_MASK 0x02  //!< Mask for field validTime in bitmask valid
#define UBX_NAV_PVT_DATA1_VALID_VALIDTIME_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_VALID_VALIDTIME_MASK)>>1)  //!< Get validTime from bitmask valid
#define UBX_NAV_PVT_DATA1_VALID_FULLYRESOLVED_MASK 0x04  //!< Mask for field fullyResolved in bitmask valid
#define UBX_NAV_PVT_DATA1_VALID_FULLYRESOLVED_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_VALID_FULLYRESOLVED_MASK)>>2)  //!< Get fullyResolved from bitmask valid

//@}
//! \name Bit Definitions for #UBX_NAV_PVT_DATA1_s::flags
//@{
#define UBX_NAV_PVT_DATA1_FLAGS_GNSSFIXOK_MASK 0x01  //!< Mask for field gnssFixOK in bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_GNSSFIXOK_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS_GNSSFIXOK_MASK)>>0)  //!< Get gnssFixOK from bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_DIFFSOLN_MASK 0x02  //!< Mask for field diffSoln in bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_DIFFSOLN_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS_DIFFSOLN_MASK)>>1)  //!< Get diffSoln from bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_PSMSTATE_MASK 0x1C  //!< Mask for field psmState in bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_PSMSTATE_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS_PSMSTATE_MASK)>>2)  //!< Get psmState from bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_HEADVEHVALID_MASK 0x20  //!< Mask for field headVehValid in bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_HEADVEHVALID_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS_HEADVEHVALID_MASK)>>5)  //!< Get headVehValid from bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_CARRSOLN_MASK 0xC0  //!< Mask for field carrSoln in bitmask flags
#define UBX_NAV_PVT_DATA1_FLAGS_CARRSOLN_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS_CARRSOLN_MASK)>>6)  //!< Get carrSoln from bitmask flags

//@}
//! \name Bit Definitions for #UBX_NAV_PVT_DATA1_s::flags2
//@{
#define UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDAVAI_MASK 0x20  //!< Mask for field confirmedAvai in bitmask flags2
#define UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDAVAI_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDAVAI_MASK)>>5)  //!< Get confirmedAvai from bitmask flags2
#define UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDDATE_MASK 0x40  //!< Mask for field confirmedDate in bitmask flags2
#define UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDDATE_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDDATE_MASK)>>6)  //!< Get confirmedDate from bitmask flags2
#define UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDTIME_MASK 0x80  //!< Mask for field confirmedTime in bitmask flags2
#define UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDTIME_GET(val)  (U)(((val)&UBX_NAV_PVT_DATA1_FLAGS2_CONFIRMEDTIME_MASK)>>7)  //!< Get confirmedTime from bitmask flags2

//@}

#define UBXID_NAV_PVT 0x0107 //!< message id for NAV-PVT


//================================================================
//! NAV_RESETODO_DATA0: Command
/*!
Reset odometer
This message resets the traveled distance computed by the odometer (see <rc href=\"UBX-NAV-ODO'>UBX-NAV-ODO</rc>).
<rc href=\"UBX-ACK-ACK'>UBX-ACK-ACK</rc> or <rc href=\"UBX-ACK-NAK'>UBX-ACK-NAK</rc> are returned to indicate success or failure.


This message's id is #UBXID_NAV_RESETODO
*/
//================================================================

typedef struct UBX_NAV_RESETODO_DATA0_s
{

} UBX_NAV_RESETODO_DATA0_t, *UBX_NAV_RESETODO_DATA0_pt;


#define UBXID_NAV_RESETODO 0x0110 //!< message id for NAV-RESETODO


//================================================================
//! NAV_SAT_DATA0: Periodic/Polled
/*!
Satellite Information
This message displays information about SVs which are either known to be visible or currently tracked by the receiver.


This message's id is #UBXID_NAV_SAT
*/
//================================================================

//! Optional Sub-Structure of #UBX_NAV_SAT_DATA0_t
typedef struct UBX_NAV_SAT_DATA0_GNSSID_s
{
    U1  gnssId;                   //!< GNSS identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite numbering)</r> for assignment
    U1  svId;                     //!< Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite numbering)</r> for assignment
    U1  cno;                      //!< Carrier to noise ratio (signal strength)
    I1  elev;                     //!< Elevation (range: +/-90), unknown if out of range
    I2  azim;                     //!< Azimuth (range 0-360), unknown if elevation is out of range
    I2  prRes;                    //!< Pseudo range residual
    X4  flags;                    //!< Bitmask

} UBX_NAV_SAT_DATA0_GNSSID_t, *UBX_NAV_SAT_DATA0_GNSSID_pt;

//! \name Bit Definitions for #UBX_NAV_SAT_DATA0_GNSSID_s::flags
//@{
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_QUALITYIND_MASK 0x00000007  //!< Mask for field qualityInd in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_QUALITYIND_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_QUALITYIND_MASK)>>0)  //!< Get qualityInd from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SVUSED_MASK 0x00000008  //!< Mask for field svUsed in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SVUSED_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SVUSED_MASK)>>3)  //!< Get svUsed from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_HEALTH_MASK 0x00000030  //!< Mask for field health in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_HEALTH_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_HEALTH_MASK)>>4)  //!< Get health from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_DIFFCORR_MASK 0x00000040  //!< Mask for field diffCorr in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_DIFFCORR_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_DIFFCORR_MASK)>>6)  //!< Get diffCorr from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SMOOTHED_MASK 0x00000080  //!< Mask for field smoothed in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SMOOTHED_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SMOOTHED_MASK)>>7)  //!< Get smoothed from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ORBITSOURCE_MASK 0x00000700  //!< Mask for field orbitSource in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ORBITSOURCE_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ORBITSOURCE_MASK)>>8)  //!< Get orbitSource from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_EPHAVAIL_MASK 0x00000800  //!< Mask for field ephAvail in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_EPHAVAIL_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_EPHAVAIL_MASK)>>11)  //!< Get ephAvail from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ALMAVAIL_MASK 0x00001000  //!< Mask for field almAvail in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ALMAVAIL_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ALMAVAIL_MASK)>>12)  //!< Get almAvail from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ANOAVAIL_MASK 0x00002000  //!< Mask for field anoAvail in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ANOAVAIL_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_ANOAVAIL_MASK)>>13)  //!< Get anoAvail from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_AOPAVAIL_MASK 0x00004000  //!< Mask for field aopAvail in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_AOPAVAIL_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_AOPAVAIL_MASK)>>14)  //!< Get aopAvail from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SBASCORRUSED_MASK 0x00010000  //!< Mask for field sbasCorrUsed in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SBASCORRUSED_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_SBASCORRUSED_MASK)>>16)  //!< Get sbasCorrUsed from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_RTCMCORRUSED_MASK 0x00020000  //!< Mask for field rtcmCorrUsed in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_RTCMCORRUSED_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_RTCMCORRUSED_MASK)>>17)  //!< Get rtcmCorrUsed from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_PRCORRUSED_MASK 0x00100000  //!< Mask for field prCorrUsed in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_PRCORRUSED_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_PRCORRUSED_MASK)>>20)  //!< Get prCorrUsed from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_CRCORRUSED_MASK 0x00200000  //!< Mask for field crCorrUsed in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_CRCORRUSED_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_CRCORRUSED_MASK)>>21)  //!< Get crCorrUsed from bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_DOCORRUSED_MASK 0x00400000  //!< Mask for field doCorrUsed in bitmask flags
#define UBX_NAV_SAT_DATA0_GNSSID_FLAGS_DOCORRUSED_GET(val)  (U)(((val)&UBX_NAV_SAT_DATA0_GNSSID_FLAGS_DOCORRUSED_MASK)>>22)  //!< Get doCorrUsed from bitmask flags

//@}


typedef struct UBX_NAV_SAT_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  version;                  //!< Message version (1 for this version)
    U1  numSvs;                   //!< Number of satellites
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_NAV_SAT_DATA0_GNSSID_t repeat0[numSvs];

} UBX_NAV_SAT_DATA0_t, *UBX_NAV_SAT_DATA0_pt;


#define UBXID_NAV_SAT 0x0135 //!< message id for NAV-SAT


//================================================================
//! NAV_SBAS_DATA0: Periodic/Polled
/*!
SBAS Status Data
This message outputs the status of the SBAS sub system


This message's id is #UBXID_NAV_SBAS
*/
//================================================================

//! Optional Sub-Structure of #UBX_NAV_SBAS_DATA0_t
typedef struct UBX_NAV_SBAS_DATA0_SVID_s
{
    U1  svid;                     //!< SV ID
    U1  flags;                    //!< Flags for this SV
    U1  udre;                     //!< Monitoring status
    U1  svSys;                    //!< System (WAAS/EGNOS/...)
    U1  svService;                //!< Services available
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I2  prc;                      //!< Pseudo Range correction in [cm]
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I2  ic;                       //!< Ionosphere correction in [cm]

} UBX_NAV_SBAS_DATA0_SVID_t, *UBX_NAV_SBAS_DATA0_SVID_pt;



typedef struct UBX_NAV_SBAS_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  geo;                      //!< PRN Number of the GEO where correction and integrity data is used from
    U1  mode;                     //!< SBAS Mode
    I1  sys;                      //!< SBAS System (WAAS/EGNOS/...)
    X1  service;                  //!< SBAS Services available
    U1  cnt;                      //!< Number of SV data following
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_NAV_SBAS_DATA0_SVID_t repeat0[cnt];

} UBX_NAV_SBAS_DATA0_t, *UBX_NAV_SBAS_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_SBAS_DATA0_s::service
//@{
#define UBX_NAV_SBAS_DATA0_SERVICE_RANGING_MASK 0x01  //!< Mask for field Ranging in bitmask service
#define UBX_NAV_SBAS_DATA0_SERVICE_RANGING_GET(val)  (U)(((val)&UBX_NAV_SBAS_DATA0_SERVICE_RANGING_MASK)>>0)  //!< Get Ranging from bitmask service
#define UBX_NAV_SBAS_DATA0_SERVICE_CORRECTIONS_MASK 0x02  //!< Mask for field Corrections in bitmask service
#define UBX_NAV_SBAS_DATA0_SERVICE_CORRECTIONS_GET(val)  (U)(((val)&UBX_NAV_SBAS_DATA0_SERVICE_CORRECTIONS_MASK)>>1)  //!< Get Corrections from bitmask service
#define UBX_NAV_SBAS_DATA0_SERVICE_INTEGRITY_MASK 0x04  //!< Mask for field Integrity in bitmask service
#define UBX_NAV_SBAS_DATA0_SERVICE_INTEGRITY_GET(val)  (U)(((val)&UBX_NAV_SBAS_DATA0_SERVICE_INTEGRITY_MASK)>>2)  //!< Get Integrity from bitmask service
#define UBX_NAV_SBAS_DATA0_SERVICE_TESTMODE_MASK 0x08  //!< Mask for field Testmode in bitmask service
#define UBX_NAV_SBAS_DATA0_SERVICE_TESTMODE_GET(val)  (U)(((val)&UBX_NAV_SBAS_DATA0_SERVICE_TESTMODE_MASK)>>3)  //!< Get Testmode from bitmask service

//@}

#define UBXID_NAV_SBAS 0x0132 //!< message id for NAV-SBAS


//================================================================
//! NAV_SOL_DATA0: Periodic/Polled
/*!
Navigation Solution Information
This message combines position, velocity and time solution in ECEF, including accuracy figures.
This message has only been retained for backwards compatibility; users are recommended to use the <rc href=\"UBX-NAV-PVT'>UBX-NAV-PVT</rc> message in preference.


This message's id is #UBXID_NAV_SOL
*/
//================================================================

typedef struct UBX_NAV_SOL_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  fTOW;                     //!< Fractional part of iTOW (range: +/-500000).
    I2  week;                     //!< GPS week number of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>
    U1  gpsFix;                   //!< GPSfix Type, range 0..5
    X1  flags;                    //!< Fix Status Flags
    I4  ecefX;                    //!< ECEF X coordinate
    I4  ecefY;                    //!< ECEF Y coordinate
    I4  ecefZ;                    //!< ECEF Z coordinate
    U4  pAcc;                     //!< 3D Position Accuracy Estimate
    I4  ecefVX;                   //!< ECEF X velocity
    I4  ecefVY;                   //!< ECEF Y velocity
    I4  ecefVZ;                   //!< ECEF Z velocity
    U4  sAcc;                     //!< Speed Accuracy Estimate
    U2  pDOP;                     //!< Position DOP
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  numSV;                    //!< Number of SVs used in Nav Solution
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_NAV_SOL_DATA0_t, *UBX_NAV_SOL_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_SOL_DATA0_s::flags
//@{
#define UBX_NAV_SOL_DATA0_FLAGS_GPSFIXOK_MASK 0x01  //!< Mask for field GPSfixOK in bitmask flags
#define UBX_NAV_SOL_DATA0_FLAGS_GPSFIXOK_GET(val)  (U)(((val)&UBX_NAV_SOL_DATA0_FLAGS_GPSFIXOK_MASK)>>0)  //!< Get GPSfixOK from bitmask flags
#define UBX_NAV_SOL_DATA0_FLAGS_DIFFSOLN_MASK 0x02  //!< Mask for field DiffSoln in bitmask flags
#define UBX_NAV_SOL_DATA0_FLAGS_DIFFSOLN_GET(val)  (U)(((val)&UBX_NAV_SOL_DATA0_FLAGS_DIFFSOLN_MASK)>>1)  //!< Get DiffSoln from bitmask flags
#define UBX_NAV_SOL_DATA0_FLAGS_WKNSET_MASK 0x04  //!< Mask for field WKNSET in bitmask flags
#define UBX_NAV_SOL_DATA0_FLAGS_WKNSET_GET(val)  (U)(((val)&UBX_NAV_SOL_DATA0_FLAGS_WKNSET_MASK)>>2)  //!< Get WKNSET from bitmask flags
#define UBX_NAV_SOL_DATA0_FLAGS_TOWSET_MASK 0x08  //!< Mask for field TOWSET in bitmask flags
#define UBX_NAV_SOL_DATA0_FLAGS_TOWSET_GET(val)  (U)(((val)&UBX_NAV_SOL_DATA0_FLAGS_TOWSET_MASK)>>3)  //!< Get TOWSET from bitmask flags

//@}

#define UBXID_NAV_SOL 0x0106 //!< message id for NAV-SOL


//================================================================
//! NAV_STATUS_DATA1: Periodic/Polled
/*!
Receiver Navigation Status
-

   \note: See important comments concerning validity of position and velocity given in section <rb href=\"CFG-NAV5-DESC-OUTF'>Navigation Output Filters</rb>.

This message's id is #UBXID_NAV_STATUS
*/
//================================================================

typedef struct UBX_NAV_STATUS_DATA1_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  gpsFix;                   //!< GPSfix Type, this value does <b>not</b> qualify a fix as valid and within the limits. See note on flag gpsFixOk below.
    X1  flags;                    //!< Navigation Status Flags
    X1  fixStat;                  //!< Fix Status Information
    X1  flags2;                   //!< further information about navigation output
    U4  ttff;                     //!< Time to first fix (millisecond time tag)
    U4  msss;                     //!< Milliseconds since Startup / Reset

} UBX_NAV_STATUS_DATA1_t, *UBX_NAV_STATUS_DATA1_pt;


//! \name Bit Definitions for #UBX_NAV_STATUS_DATA1_s::flags
//@{
#define UBX_NAV_STATUS_DATA1_FLAGS_GPSFIXOK_MASK 0x01  //!< Mask for field gpsFixOk in bitmask flags
#define UBX_NAV_STATUS_DATA1_FLAGS_GPSFIXOK_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FLAGS_GPSFIXOK_MASK)>>0)  //!< Get gpsFixOk from bitmask flags
#define UBX_NAV_STATUS_DATA1_FLAGS_DIFFSOLN_MASK 0x02  //!< Mask for field diffSoln in bitmask flags
#define UBX_NAV_STATUS_DATA1_FLAGS_DIFFSOLN_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FLAGS_DIFFSOLN_MASK)>>1)  //!< Get diffSoln from bitmask flags
#define UBX_NAV_STATUS_DATA1_FLAGS_WKNSET_MASK 0x04  //!< Mask for field wknSet in bitmask flags
#define UBX_NAV_STATUS_DATA1_FLAGS_WKNSET_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FLAGS_WKNSET_MASK)>>2)  //!< Get wknSet from bitmask flags
#define UBX_NAV_STATUS_DATA1_FLAGS_TOWSET_MASK 0x08  //!< Mask for field towSet in bitmask flags
#define UBX_NAV_STATUS_DATA1_FLAGS_TOWSET_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FLAGS_TOWSET_MASK)>>3)  //!< Get towSet from bitmask flags

//@}
//! \name Bit Definitions for #UBX_NAV_STATUS_DATA1_s::fixStat
//@{
#define UBX_NAV_STATUS_DATA1_FIXSTAT_DGPSISTAT_MASK 0x01  //!< Mask for field dgpsIStat in bitmask fixStat
#define UBX_NAV_STATUS_DATA1_FIXSTAT_DGPSISTAT_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FIXSTAT_DGPSISTAT_MASK)>>0)  //!< Get dgpsIStat from bitmask fixStat
#define UBX_NAV_STATUS_DATA1_FIXSTAT_MAPMATCHING_MASK 0xC0  //!< Mask for field mapMatching in bitmask fixStat
#define UBX_NAV_STATUS_DATA1_FIXSTAT_MAPMATCHING_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FIXSTAT_MAPMATCHING_MASK)>>6)  //!< Get mapMatching from bitmask fixStat

//@}
//! \name Bit Definitions for #UBX_NAV_STATUS_DATA1_s::flags2
//@{
#define UBX_NAV_STATUS_DATA1_FLAGS2_PSMSTATE_MASK 0x03  //!< Mask for field psmState in bitmask flags2
#define UBX_NAV_STATUS_DATA1_FLAGS2_PSMSTATE_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FLAGS2_PSMSTATE_MASK)>>0)  //!< Get psmState from bitmask flags2
#define UBX_NAV_STATUS_DATA1_FLAGS2_SPOOFDETSTATE_MASK 0x18  //!< Mask for field spoofDetState in bitmask flags2
#define UBX_NAV_STATUS_DATA1_FLAGS2_SPOOFDETSTATE_GET(val)  (U)(((val)&UBX_NAV_STATUS_DATA1_FLAGS2_SPOOFDETSTATE_MASK)>>3)  //!< Get spoofDetState from bitmask flags2

//@}

#define UBXID_NAV_STATUS 0x0103 //!< message id for NAV-STATUS


//================================================================
//! NAV_SVINFO_DATA0: Periodic/Polled
/*!
Space Vehicle Information
Information about satellites used or visible
This message has only been retained for backwards compatibility; users are recommended to use the <rc href=\"UBX-NAV-SAT'>UBX-NAV-SAT</rc> message in preference.


This message's id is #UBXID_NAV_SVINFO
*/
//================================================================

//! Optional Sub-Structure of #UBX_NAV_SVINFO_DATA0_t
typedef struct UBX_NAV_SVINFO_DATA0_CHN_s
{
    U1  chn;                      //!< Channel number, 255 for SVs not assigned to a channel
    U1  svid;                     //!< Satellite ID, see <r href=\"DESC-SVNumbering-UBX'>Satellite numbering</r> for assignment
    X1  flags;                    //!< Bitmask
    X1  quality;                  //!< Bitfield
    U1  cno;                      //!< Carrier to Noise Ratio (Signal Strength)
    I1  elev;                     //!< Elevation in integer degrees
    I2  azim;                     //!< Azimuth in integer degrees
    I4  prRes;                    //!< Pseudo range residual in centimeters

} UBX_NAV_SVINFO_DATA0_CHN_t, *UBX_NAV_SVINFO_DATA0_CHN_pt;

//! \name Bit Definitions for #UBX_NAV_SVINFO_DATA0_CHN_s::flags
//@{
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_SVUSED_MASK 0x01  //!< Mask for field svUsed in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_SVUSED_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_SVUSED_MASK)>>0)  //!< Get svUsed from bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_DIFFCORR_MASK 0x02  //!< Mask for field diffCorr in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_DIFFCORR_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_DIFFCORR_MASK)>>1)  //!< Get diffCorr from bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITAVAIL_MASK 0x04  //!< Mask for field orbitAvail in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITAVAIL_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITAVAIL_MASK)>>2)  //!< Get orbitAvail from bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITEPH_MASK 0x08  //!< Mask for field orbitEph in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITEPH_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITEPH_MASK)>>3)  //!< Get orbitEph from bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_UNHEALTHY_MASK 0x10  //!< Mask for field unhealthy in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_UNHEALTHY_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_UNHEALTHY_MASK)>>4)  //!< Get unhealthy from bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITALM_MASK 0x20  //!< Mask for field orbitAlm in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITALM_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITALM_MASK)>>5)  //!< Get orbitAlm from bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITAOP_MASK 0x40  //!< Mask for field orbitAop in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITAOP_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_ORBITAOP_MASK)>>6)  //!< Get orbitAop from bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_SMOOTHED_MASK 0x80  //!< Mask for field smoothed in bitmask flags
#define UBX_NAV_SVINFO_DATA0_CHN_FLAGS_SMOOTHED_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_FLAGS_SMOOTHED_MASK)>>7)  //!< Get smoothed from bitmask flags

//@}
//! \name Bit Definitions for #UBX_NAV_SVINFO_DATA0_CHN_s::quality
//@{
#define UBX_NAV_SVINFO_DATA0_CHN_QUALITY_QUALITYIND_MASK 0x0F  //!< Mask for field qualityInd in bitmask quality
#define UBX_NAV_SVINFO_DATA0_CHN_QUALITY_QUALITYIND_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_CHN_QUALITY_QUALITYIND_MASK)>>0)  //!< Get qualityInd from bitmask quality

//@}


typedef struct UBX_NAV_SVINFO_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  numCh;                    //!< Number of channels
    X1  globalFlags;              //!< Bitmask
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_NAV_SVINFO_DATA0_CHN_t repeat0[numCh];

} UBX_NAV_SVINFO_DATA0_t, *UBX_NAV_SVINFO_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_SVINFO_DATA0_s::globalFlags
//@{
#define UBX_NAV_SVINFO_DATA0_GLOBALFLAGS_CHIPGEN_MASK 0x07  //!< Mask for field chipGen in bitmask globalFlags
#define UBX_NAV_SVINFO_DATA0_GLOBALFLAGS_CHIPGEN_GET(val)  (U)(((val)&UBX_NAV_SVINFO_DATA0_GLOBALFLAGS_CHIPGEN_MASK)>>0)  //!< Get chipGen from bitmask globalFlags

//@}

#define UBXID_NAV_SVINFO 0x0130 //!< message id for NAV-SVINFO


//================================================================
//! NAV_TIMEBDS_DATA0: Periodic/Polled
/*!
BDS Time Solution
This message reports the precise BDS time of the most recent navigation solution including validity flags and an accuracy estimate.


This message's id is #UBXID_NAV_TIMEBDS
*/
//================================================================

typedef struct UBX_NAV_TIMEBDS_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U4  SOW;                      //!< BDS time of week (rounded to seconds)
    I4  fSOW;                     //!< Fractional part of SOW (range: +/-500000000).
    I2  week;                     //!< BDS week number of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>
    I1  leapS;                    //!< BDS leap seconds (BDS-UTC)
    X1  valid;                    //!< Validity Flags
    U4  tAcc;                     //!< Time Accuracy Estimate

} UBX_NAV_TIMEBDS_DATA0_t, *UBX_NAV_TIMEBDS_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_TIMEBDS_DATA0_s::valid
//@{
#define UBX_NAV_TIMEBDS_DATA0_VALID_SOWVALID_MASK 0x01  //!< Mask for field sowValid in bitmask valid
#define UBX_NAV_TIMEBDS_DATA0_VALID_SOWVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEBDS_DATA0_VALID_SOWVALID_MASK)>>0)  //!< Get sowValid from bitmask valid
#define UBX_NAV_TIMEBDS_DATA0_VALID_WEEKVALID_MASK 0x02  //!< Mask for field weekValid in bitmask valid
#define UBX_NAV_TIMEBDS_DATA0_VALID_WEEKVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEBDS_DATA0_VALID_WEEKVALID_MASK)>>1)  //!< Get weekValid from bitmask valid
#define UBX_NAV_TIMEBDS_DATA0_VALID_LEAPSVALID_MASK 0x04  //!< Mask for field leapSValid in bitmask valid
#define UBX_NAV_TIMEBDS_DATA0_VALID_LEAPSVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEBDS_DATA0_VALID_LEAPSVALID_MASK)>>2)  //!< Get leapSValid from bitmask valid

//@}

#define UBXID_NAV_TIMEBDS 0x0124 //!< message id for NAV-TIMEBDS


//================================================================
//! NAV_TIMEGAL_DATA0: Periodic/Polled
/*!
Galileo Time Solution
This message reports the precise Galileo time of the most recent navigation solution including validity flags and an accuracy estimate.


This message's id is #UBXID_NAV_TIMEGAL
*/
//================================================================

typedef struct UBX_NAV_TIMEGAL_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U4  galTow;                   //!< Galileo time of week (rounded to seconds)
    I4  fGalTow;                  //!< Fractional part of SOW (range: +/-500000000).
    I2  galWno;                   //!< Galileo week number
    I1  leapS;                    //!< Galileo leap seconds (Galileo-UTC)
    X1  valid;                    //!< Validity Flags
    U4  tAcc;                     //!< Time Accuracy Estimate

} UBX_NAV_TIMEGAL_DATA0_t, *UBX_NAV_TIMEGAL_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_TIMEGAL_DATA0_s::valid
//@{
#define UBX_NAV_TIMEGAL_DATA0_VALID_GALTOWVALID_MASK 0x01  //!< Mask for field galTowValid in bitmask valid
#define UBX_NAV_TIMEGAL_DATA0_VALID_GALTOWVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGAL_DATA0_VALID_GALTOWVALID_MASK)>>0)  //!< Get galTowValid from bitmask valid
#define UBX_NAV_TIMEGAL_DATA0_VALID_GALWNOVALID_MASK 0x02  //!< Mask for field galWnoValid in bitmask valid
#define UBX_NAV_TIMEGAL_DATA0_VALID_GALWNOVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGAL_DATA0_VALID_GALWNOVALID_MASK)>>1)  //!< Get galWnoValid from bitmask valid
#define UBX_NAV_TIMEGAL_DATA0_VALID_LEAPSVALID_MASK 0x04  //!< Mask for field leapSValid in bitmask valid
#define UBX_NAV_TIMEGAL_DATA0_VALID_LEAPSVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGAL_DATA0_VALID_LEAPSVALID_MASK)>>2)  //!< Get leapSValid from bitmask valid

//@}

#define UBXID_NAV_TIMEGAL 0x0125 //!< message id for NAV-TIMEGAL


//================================================================
//! NAV_TIMEGLO_DATA0: Periodic/Polled
/*!
GLO Time Solution
This message reports the precise GLO time of the most recent navigation solution including validity flags and an accuracy estimate.


This message's id is #UBXID_NAV_TIMEGLO
*/
//================================================================

typedef struct UBX_NAV_TIMEGLO_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U4  TOD;                      //!< GLONASS time of day (rounded to integer seconds)
    I4  fTOD;                     //!< Fractional part of TOD (range: +/-500000000).
    U2  Nt;                       //!< Current date (range: 1-1461), starting at 1 from the 1st Jan of the year indicated by N4 and ending at 1461 at the 31st Dec of the third year after that indicated by N4
    U1  N4;                       //!< Four-year interval number starting from 1996 (1=1996, 2=2000, 3=2004...)
    X1  valid;                    //!< Validity flags
    U4  tAcc;                     //!< Time Accuracy Estimate

} UBX_NAV_TIMEGLO_DATA0_t, *UBX_NAV_TIMEGLO_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_TIMEGLO_DATA0_s::valid
//@{
#define UBX_NAV_TIMEGLO_DATA0_VALID_TODVALID_MASK 0x01  //!< Mask for field todValid in bitmask valid
#define UBX_NAV_TIMEGLO_DATA0_VALID_TODVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGLO_DATA0_VALID_TODVALID_MASK)>>0)  //!< Get todValid from bitmask valid
#define UBX_NAV_TIMEGLO_DATA0_VALID_DATEVALID_MASK 0x02  //!< Mask for field dateValid in bitmask valid
#define UBX_NAV_TIMEGLO_DATA0_VALID_DATEVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGLO_DATA0_VALID_DATEVALID_MASK)>>1)  //!< Get dateValid from bitmask valid

//@}

#define UBXID_NAV_TIMEGLO 0x0123 //!< message id for NAV-TIMEGLO


//================================================================
//! NAV_TIMEGPS_DATA0: Periodic/Polled
/*!
GPS Time Solution
This message reports the precise GPS time of the most recent navigation solution including validity flags and an accuracy estimate.


This message's id is #UBXID_NAV_TIMEGPS
*/
//================================================================

typedef struct UBX_NAV_TIMEGPS_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  fTOW;                     //!< Fractional part of iTOW (range: +/-500000).
    I2  week;                     //!< GPS week number of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>
    I1  leapS;                    //!< GPS leap seconds (GPS-UTC)
    X1  valid;                    //!< Validity Flags
    U4  tAcc;                     //!< Time Accuracy Estimate

} UBX_NAV_TIMEGPS_DATA0_t, *UBX_NAV_TIMEGPS_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_TIMEGPS_DATA0_s::valid
//@{
#define UBX_NAV_TIMEGPS_DATA0_VALID_TOWVALID_MASK 0x01  //!< Mask for field towValid in bitmask valid
#define UBX_NAV_TIMEGPS_DATA0_VALID_TOWVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGPS_DATA0_VALID_TOWVALID_MASK)>>0)  //!< Get towValid from bitmask valid
#define UBX_NAV_TIMEGPS_DATA0_VALID_WEEKVALID_MASK 0x02  //!< Mask for field weekValid in bitmask valid
#define UBX_NAV_TIMEGPS_DATA0_VALID_WEEKVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGPS_DATA0_VALID_WEEKVALID_MASK)>>1)  //!< Get weekValid from bitmask valid
#define UBX_NAV_TIMEGPS_DATA0_VALID_LEAPSVALID_MASK 0x04  //!< Mask for field leapSValid in bitmask valid
#define UBX_NAV_TIMEGPS_DATA0_VALID_LEAPSVALID_GET(val)  (U)(((val)&UBX_NAV_TIMEGPS_DATA0_VALID_LEAPSVALID_MASK)>>2)  //!< Get leapSValid from bitmask valid

//@}

#define UBXID_NAV_TIMEGPS 0x0120 //!< message id for NAV-TIMEGPS


//================================================================
//! NAV_TIMELS_DATA0: Periodic/Polled
/*!
Leap second event information
Information about the upcoming leap second event if one is scheduled.


This message's id is #UBXID_NAV_TIMELS
*/
//================================================================

typedef struct UBX_NAV_TIMELS_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U1  version;                  //!< Message version (0x00 for this version).
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  srcOfCurrLs;              //!< Information source for the current number of leap seconds.
    I1  currLs;                   //!< Current number of leap seconds since start of GPS time (Jan 6, 1980). It reflects how much GPS time is ahead of UTC time. Galileo number of leap seconds is the same as GPS. BeiDou number of leap seconds is 14 less than GPS. GLONASS follows UTC time, so no leap seconds.
    U1  srcOfLsChange;            //!< Information source for the future leap second event.
    I1  lsChange;                 //!< Future leap second change if one is scheduled. +1 = positive leap second, -1 = negative leap second, 0 = no future leap second event scheduled or no information available.
    I4  timeToLsEvent;            //!< Number of seconds until the next leap second event, or from the last leap second event if no future event scheduled. If > 0 event is in the future, = 0 event is now, < 0 event is in the past. Valid only if validTimeToLsEvent = 1.
    U2  dateOfLsGpsWn;            //!< GPS week number (WN) of the next leap second event or the last one if no future event scheduled. Valid only if validTimeToLsEvent = 1.
    U2  dateOfLsGpsDn;            //!< GPS day of week number (DN) for the next leap second event or the last one if no future event scheduled. Valid only if validTimeToLsEvent = 1. (GPS and Galileo DN: from 1 = Sun to 7 = Sat. BeiDou DN: from 0 = Sun to 6 = Sat.)
    U1  reserved2[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X1  valid;                    //!< Validity flags

} UBX_NAV_TIMELS_DATA0_t, *UBX_NAV_TIMELS_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_TIMELS_DATA0_s::valid
//@{
#define UBX_NAV_TIMELS_DATA0_VALID_VALIDCURRLS_MASK 0x01  //!< Mask for field validCurrLs in bitmask valid
#define UBX_NAV_TIMELS_DATA0_VALID_VALIDCURRLS_GET(val)  (U)(((val)&UBX_NAV_TIMELS_DATA0_VALID_VALIDCURRLS_MASK)>>0)  //!< Get validCurrLs from bitmask valid
#define UBX_NAV_TIMELS_DATA0_VALID_VALIDTIMETOLSEVENT_MASK 0x02  //!< Mask for field validTimeToLsEvent in bitmask valid
#define UBX_NAV_TIMELS_DATA0_VALID_VALIDTIMETOLSEVENT_GET(val)  (U)(((val)&UBX_NAV_TIMELS_DATA0_VALID_VALIDTIMETOLSEVENT_MASK)>>1)  //!< Get validTimeToLsEvent from bitmask valid

//@}

#define UBXID_NAV_TIMELS 0x0126 //!< message id for NAV-TIMELS


//================================================================
//! NAV_TIMEUTC_DATA0: Periodic/Polled
/*!
UTC Time Solution
-

   \note: Note that during a leap second there may be more or less than 60 seconds in a minute; see the <rb href=\"LEAP-SECS-DESC'>description of leap seconds</rb> for details.

This message's id is #UBXID_NAV_TIMEUTC
*/
//================================================================

typedef struct UBX_NAV_TIMEUTC_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    U4  tAcc;                     //!< Time accuracy estimate (UTC)
    I4  nano;                     //!< Fraction of second, range -1e9 .. 1e9 (UTC)
    U2  year;                     //!< Year, range 1999..2099 (UTC)
    U1  month;                    //!< Month, range 1..12 (UTC)
    U1  day;                      //!< Day of month, range 1..31 (UTC)
    U1  hour;                     //!< Hour of day, range 0..23 (UTC)
    U1  min;                      //!< Minute of hour, range 0..59 (UTC)
    U1  sec;                      //!< Seconds of minute, range 0..60 (UTC)
    X1  valid;                    //!< Validity Flags

} UBX_NAV_TIMEUTC_DATA0_t, *UBX_NAV_TIMEUTC_DATA0_pt;


//! \name Bit Definitions for #UBX_NAV_TIMEUTC_DATA0_s::valid
//@{
#define UBX_NAV_TIMEUTC_DATA0_VALID_VALIDTOW_MASK 0x01  //!< Mask for field validTOW in bitmask valid
#define UBX_NAV_TIMEUTC_DATA0_VALID_VALIDTOW_GET(val)  (U)(((val)&UBX_NAV_TIMEUTC_DATA0_VALID_VALIDTOW_MASK)>>0)  //!< Get validTOW from bitmask valid
#define UBX_NAV_TIMEUTC_DATA0_VALID_VALIDWKN_MASK 0x02  //!< Mask for field validWKN in bitmask valid
#define UBX_NAV_TIMEUTC_DATA0_VALID_VALIDWKN_GET(val)  (U)(((val)&UBX_NAV_TIMEUTC_DATA0_VALID_VALIDWKN_MASK)>>1)  //!< Get validWKN from bitmask valid
#define UBX_NAV_TIMEUTC_DATA0_VALID_VALIDUTC_MASK 0x04  //!< Mask for field validUTC in bitmask valid
#define UBX_NAV_TIMEUTC_DATA0_VALID_VALIDUTC_GET(val)  (U)(((val)&UBX_NAV_TIMEUTC_DATA0_VALID_VALIDUTC_MASK)>>2)  //!< Get validUTC from bitmask valid
#define UBX_NAV_TIMEUTC_DATA0_VALID_UTCSTANDARD_MASK 0xF0  //!< Mask for field utcStandard in bitmask valid
#define UBX_NAV_TIMEUTC_DATA0_VALID_UTCSTANDARD_GET(val)  (U)(((val)&UBX_NAV_TIMEUTC_DATA0_VALID_UTCSTANDARD_MASK)>>4)  //!< Get utcStandard from bitmask valid

//@}

#define UBXID_NAV_TIMEUTC 0x0121 //!< message id for NAV-TIMEUTC


//================================================================
//! NAV_VELECEF_DATA0: Periodic/Polled
/*!
Velocity Solution in ECEF
-

   \note: See important comments concerning validity of velocity given in section <rb href=\"CFG-NAV5-DESC-OUTF'>Navigation Output Filters</rb>.

This message's id is #UBXID_NAV_VELECEF
*/
//================================================================

typedef struct UBX_NAV_VELECEF_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  ecefVX;                   //!< ECEF X velocity
    I4  ecefVY;                   //!< ECEF Y velocity
    I4  ecefVZ;                   //!< ECEF Z velocity
    U4  sAcc;                     //!< Speed accuracy estimate

} UBX_NAV_VELECEF_DATA0_t, *UBX_NAV_VELECEF_DATA0_pt;


#define UBXID_NAV_VELECEF 0x0111 //!< message id for NAV-VELECEF


//================================================================
//! NAV_VELNED_DATA0: Periodic/Polled
/*!
Velocity Solution in NED
-

   \note: See important comments concerning validity of velocity given in section <rb href=\"CFG-NAV5-DESC-OUTF'>Navigation Output Filters</rb>.

This message's id is #UBXID_NAV_VELNED
*/
//================================================================

typedef struct UBX_NAV_VELNED_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I4  velN;                     //!< North velocity component
    I4  velE;                     //!< East velocity component
    I4  velD;                     //!< Down velocity component
    U4  speed;                    //!< Speed (3-D)
    U4  gSpeed;                   //!< Ground speed (2-D)
    I4  heading;                  //!< Heading of motion 2-D
    U4  sAcc;                     //!< Speed accuracy Estimate
    U4  cAcc;                     //!< Course / Heading accuracy estimate

} UBX_NAV_VELNED_DATA0_t, *UBX_NAV_VELNED_DATA0_pt;


#define UBXID_NAV_VELNED 0x0112 //!< message id for NAV-VELNED


//================================================================
//! RXM_IMES_DATA0: Periodic/Polled
/*!
Indoor Messaging System Information
This message shows the IMES stations the receiver is currently tracking, their data rate, the signal level, the Doppler (with respect to 1575.4282MHz) and what data (without protocol specific overhead) it has received from these stations so far.
This message is sent out at the navigation rate the receiver is currently set to. Therefore it allows users to get an overview on the receiver's current state from the IMES perspective.


This message's id is #UBXID_RXM_IMES
*/
//================================================================

//! Optional Sub-Structure of #UBX_RXM_IMES_DATA0_t
typedef struct UBX_RXM_IMES_DATA0_RESERVED2_s
{
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  txId;                     //!< Transmitter identifier
    U1  reserved3[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  cno;                      //!< Carrier to Noise Ratio (Signal Strength)
    U1  reserved4[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  doppler;                  //!< Doppler frequency with respect to 1575.4282MHz [IIIII.FFF Hz]
    X4  position1_1;              //!< Position 1 Frame (part 1/2)
    X4  position1_2;              //!< Position 1 Frame (part 2/2)
    X4  position2_1;              //!< Position 2 Frame (part 1/3)
    I4  lat;                      //!< Latitude, Position 2 Frame (part 2/3)
    I4  lon;                      //!< Longitude, Position 2 Frame (part 3/3)
    X4  shortIdFrame;             //!< Short ID Frame
    U4  mediumIdLSB;              //!< Medium ID LSB, Medium ID Frame (part 1/2)
    X4  mediumId_2;               //!< Medium ID Frame (part 2/2)

} UBX_RXM_IMES_DATA0_RESERVED2_t, *UBX_RXM_IMES_DATA0_RESERVED2_pt;

//! \name Bit Definitions for #UBX_RXM_IMES_DATA0_RESERVED2_s::position1_1
//@{
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_1_POS1FLOOR_MASK 0x000000FF  //!< Mask for field pos1Floor in bitmask position1_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_1_POS1FLOOR_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_1_POS1FLOOR_MASK)>>0)  //!< Get pos1Floor from bitmask position1_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_1_POS1LAT_MASK 0x7FFFFF00  //!< Mask for field pos1Lat in bitmask position1_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_1_POS1LAT_GET(val)  (I)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_1_POS1LAT_MASK)>>8)  //!< Get pos1Lat from bitmask position1_1

//@}
//! \name Bit Definitions for #UBX_RXM_IMES_DATA0_RESERVED2_s::position1_2
//@{
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_2_POS1LON_MASK 0x00FFFFFF  //!< Mask for field pos1Lon in bitmask position1_2
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_2_POS1LON_GET(val)  (I)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_2_POS1LON_MASK)>>0)  //!< Get pos1Lon from bitmask position1_2
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_2_POS1VALID_MASK 0x01000000  //!< Mask for field pos1Valid in bitmask position1_2
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_2_POS1VALID_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION1_2_POS1VALID_MASK)>>24)  //!< Get pos1Valid from bitmask position1_2

//@}
//! \name Bit Definitions for #UBX_RXM_IMES_DATA0_RESERVED2_s::position2_1
//@{
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2FLOOR_MASK 0x000001FF  //!< Mask for field pos2Floor in bitmask position2_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2FLOOR_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2FLOOR_MASK)>>0)  //!< Get pos2Floor from bitmask position2_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2ALT_MASK 0x001FFE00  //!< Mask for field pos2Alt in bitmask position2_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2ALT_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2ALT_MASK)>>9)  //!< Get pos2Alt from bitmask position2_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2ACC_MASK 0x00600000  //!< Mask for field pos2Acc in bitmask position2_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2ACC_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2ACC_MASK)>>21)  //!< Get pos2Acc from bitmask position2_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2VALID_MASK 0x00800000  //!< Mask for field pos2Valid in bitmask position2_1
#define UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2VALID_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_POSITION2_1_POS2VALID_MASK)>>23)  //!< Get pos2Valid from bitmask position2_1

//@}
//! \name Bit Definitions for #UBX_RXM_IMES_DATA0_RESERVED2_s::shortIdFrame
//@{
#define UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTID_MASK 0x00000FFF  //!< Mask for field shortId in bitmask shortIdFrame
#define UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTID_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTID_MASK)>>0)  //!< Get shortId from bitmask shortIdFrame
#define UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTVALID_MASK 0x00001000  //!< Mask for field shortValid in bitmask shortIdFrame
#define UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTVALID_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTVALID_MASK)>>12)  //!< Get shortValid from bitmask shortIdFrame
#define UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTBOUNDARY_MASK 0x00002000  //!< Mask for field shortBoundary in bitmask shortIdFrame
#define UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTBOUNDARY_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_SHORTIDFRAME_SHORTBOUNDARY_MASK)>>13)  //!< Get shortBoundary from bitmask shortIdFrame

//@}
//! \name Bit Definitions for #UBX_RXM_IMES_DATA0_RESERVED2_s::mediumId_2
//@{
#define UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMIDMSB_MASK 0x00000001  //!< Mask for field mediumIdMSB in bitmask mediumId_2
#define UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMIDMSB_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMIDMSB_MASK)>>0)  //!< Get mediumIdMSB from bitmask mediumId_2
#define UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMVALID_MASK 0x00000002  //!< Mask for field mediumValid in bitmask mediumId_2
#define UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMVALID_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMVALID_MASK)>>1)  //!< Get mediumValid from bitmask mediumId_2
#define UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMBOUNDARY_MASK 0x00000004  //!< Mask for field mediumboundary in bitmask mediumId_2
#define UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMBOUNDARY_GET(val)  (U)(((val)&UBX_RXM_IMES_DATA0_RESERVED2_MEDIUMID_2_MEDIUMBOUNDARY_MASK)>>2)  //!< Get mediumboundary from bitmask mediumId_2

//@}


typedef struct UBX_RXM_IMES_DATA0_s
{
    U1  numTx;                    //!< Number of transmitters contained in the message
    U1  version;                  //!< Message version (0x01 for this version)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_RXM_IMES_DATA0_RESERVED2_t repeat0[numTx];

} UBX_RXM_IMES_DATA0_t, *UBX_RXM_IMES_DATA0_pt;


#define UBXID_RXM_IMES 0x0261 //!< message id for RXM-IMES


//================================================================
//! RXM_MEASX_DATA1: Periodic
/*!
Satellite Measurements for RRLP
The message payload data is, where possible and appropriate, according to the Radio Resource LCS (Location Services) Protocol (RRLP) [1]. One exception is the satellite and GNSS ids, which here are given according to the <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r> scheme. The correct satellites have to be selected and their satellite ID translated accordingly [1, tab. A.10.14] for use in a RRLP Measure Position Response Component. Similarly, the measurement reference time of week has to be forwarded correctly (modulo 14400000 for the 24 LSB GPS measurements variant, modulo 3600000 for the 22 LSB Galileo and Additional Navigation Satelllite Systems (GANSS) measurements variant) of the RRLP measure position response to the SMLC.
Reference: [1] ETSI TS 144 031 V11.0.0 (2012-10), Digital cellular telecommunications system (Phase 2+), Location Services (LCS), Mobile Station (MS) - Serving Mobile Location Centre (SMLC), Radio Resource LCS Protocol (RRLP), (3GPP TS 44.031 version 11.0.0 Release 11).


This message's id is #UBXID_RXM_MEASX
*/
//================================================================

//! Optional Sub-Structure of #UBX_RXM_MEASX_DATA1_t
typedef struct UBX_RXM_MEASX_DATA1_GNSSID_s
{
    U1  gnssId;                   //!< GNSS ID (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  svId;                     //!< Satellite ID (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  cNo;                      //!< carrier noise ratio (0..63)
    U1  mpathIndic;               //!< multipath index (according to [1]) (0 = not measured, 1 = low, 2 = medium, 3 = high)
    I4  dopplerMS;                //!< Doppler measurement
    I4  dopplerHz;                //!< Doppler measurement
    U2  wholeChips;               //!< whole value of the code phase measurement (0..1022 for GPS)
    U2  fracChips;                //!< fractional value of the code phase measurement (0..1023)
    U4  codePhase;                //!< Code phase
    U1  intCodePhase;             //!< Integer (part of the) code phase
    U1  pseuRangeRMSErr;          //!< pseudorange RMS error index (according to [1]) (0..63)
    U1  reserved5[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_RXM_MEASX_DATA1_GNSSID_t, *UBX_RXM_MEASX_DATA1_GNSSID_pt;



typedef struct UBX_RXM_MEASX_DATA1_s
{
    U1  version;                  //!< Message version, currently 0x00
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  gpsTOW;                   //!< GPS measurement reference time
    U4  gloTOW;                   //!< GLONASS measurement reference time
    U4  bdsTOW;                   //!< BeiDou measurement reference time
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  qzssTOW;                  //!< QZSS measurement reference time
    U2  gpsTOWacc;                //!< GPS measurement reference time accuracy (0xffff = > 4s)
    U2  gloTOWacc;                //!< GLONASS measurement reference time accuracy (0xffff = > 4s)
    U2  bdsTOWacc;                //!< BeiDou measurement reference time accuracy (0xffff = > 4s)
    U1  reserved3[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  qzssTOWacc;               //!< QZSS measurement reference time accuracy (0xffff = > 4s)
    U1  numSV;                    //!< Number of satellites in repeated block
    U1  flags;                    //!< Flags
    U1  reserved4[8];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_RXM_MEASX_DATA1_GNSSID_t repeat0[numSV];

} UBX_RXM_MEASX_DATA1_t, *UBX_RXM_MEASX_DATA1_pt;


//! \name Bit Definitions for #UBX_RXM_MEASX_DATA1_s::flags
//@{
#define UBX_RXM_MEASX_DATA1_FLAGS_TOWSET_MASK 0x00000003  //!< Mask for field towSet in bitmask flags
#define UBX_RXM_MEASX_DATA1_FLAGS_TOWSET_GET(val)  (U)(((val)&UBX_RXM_MEASX_DATA1_FLAGS_TOWSET_MASK)>>0)  //!< Get towSet from bitmask flags

//@}

#define UBXID_RXM_MEASX 0x0214 //!< message id for RXM-MEASX


//================================================================
//! RXM_PMREQ_0: Command
/*!
Requests a Power Management task
Request of a Power Management related task of the receiver.


This message's id is #UBXID_RXM_PMREQ
*/
//================================================================

typedef struct UBX_RXM_PMREQ_0_s
{
    U4  duration;                 //!< Duration of the requested task, set to zero for infinite duration. The maximum supported time is 12 days.
    X4  flags;                    //!< task flags

} UBX_RXM_PMREQ_0_t, *UBX_RXM_PMREQ_0_pt;


//! \name Bit Definitions for #UBX_RXM_PMREQ_0_s::flags
//@{
#define UBX_RXM_PMREQ_0_FLAGS_BACKUP_MASK 0x02  //!< Mask for field backup in bitmask flags
#define UBX_RXM_PMREQ_0_FLAGS_BACKUP_GET(val)  (U)(((val)&UBX_RXM_PMREQ_0_FLAGS_BACKUP_MASK)>>1)  //!< Get backup from bitmask flags

//@}

#define UBXID_RXM_PMREQ 0x0241 //!< message id for RXM-PMREQ


//================================================================
//! RXM_PMREQ_1: Command
/*!
Requests a Power Management task
Request of a Power Management related task of the receiver.


This message's id is #UBXID_RXM_PMREQ
*/
//================================================================

typedef struct UBX_RXM_PMREQ_1_s
{
    U1  version;                  //!< Message version (0x00 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  duration;                 //!< Duration of the requested task, set to zero for infinite duration. The maximum supported time is 12 days.
    X4  flags;                    //!< task flags
    X4  wakeupSources;            //!< Configure pins to wakeup the receiver. The receiver wakes up if there is either a falling or a rising edge on one of the configured pins

} UBX_RXM_PMREQ_1_t, *UBX_RXM_PMREQ_1_pt;


//! \name Bit Definitions for #UBX_RXM_PMREQ_1_s::flags
//@{
#define UBX_RXM_PMREQ_1_FLAGS_BACKUP_MASK 0x02  //!< Mask for field backup in bitmask flags
#define UBX_RXM_PMREQ_1_FLAGS_BACKUP_GET(val)  (U)(((val)&UBX_RXM_PMREQ_1_FLAGS_BACKUP_MASK)>>1)  //!< Get backup from bitmask flags
#define UBX_RXM_PMREQ_1_FLAGS_FORCE_MASK 0x04  //!< Mask for field force in bitmask flags
#define UBX_RXM_PMREQ_1_FLAGS_FORCE_GET(val)  (U)(((val)&UBX_RXM_PMREQ_1_FLAGS_FORCE_MASK)>>2)  //!< Get force from bitmask flags

//@}
//! \name Bit Definitions for #UBX_RXM_PMREQ_1_s::wakeupSources
//@{
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_UARTRX_MASK 0x00000008  //!< Mask for field uartrx in bitmask wakeupSources
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_UARTRX_GET(val)  (U)(((val)&UBX_RXM_PMREQ_1_WAKEUPSOURCES_UARTRX_MASK)>>3)  //!< Get uartrx from bitmask wakeupSources
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_EXTINT0_MASK 0x00000020  //!< Mask for field extint0 in bitmask wakeupSources
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_EXTINT0_GET(val)  (U)(((val)&UBX_RXM_PMREQ_1_WAKEUPSOURCES_EXTINT0_MASK)>>5)  //!< Get extint0 from bitmask wakeupSources
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_EXTINT1_MASK 0x00000040  //!< Mask for field extint1 in bitmask wakeupSources
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_EXTINT1_GET(val)  (U)(((val)&UBX_RXM_PMREQ_1_WAKEUPSOURCES_EXTINT1_MASK)>>6)  //!< Get extint1 from bitmask wakeupSources
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_SPICS_MASK 0x00000080  //!< Mask for field spics in bitmask wakeupSources
#define UBX_RXM_PMREQ_1_WAKEUPSOURCES_SPICS_GET(val)  (U)(((val)&UBX_RXM_PMREQ_1_WAKEUPSOURCES_SPICS_MASK)>>7)  //!< Get spics from bitmask wakeupSources

//@}

//#define UBXID_RXM_PMREQ 0x0241  // already defined, see above


//================================================================
//! RXM_RAWX_DATA0: Periodic/Polled
/*!
Multi-GNSS Raw Measurement Data
This message contains the information needed to be able to generate a <r href=\"ftp://ftp.igs.org/pub/data/format/rinex300.pdf'>RINEX 3</r> multi-GNSS observation file.
This message contains pseudorange, Doppler, carrier phase, phase lock and signal quality information for GNSS satellites once signals have been synchronized. This message supports all active GNSS.


This message's id is #UBXID_RXM_RAWX
*/
//================================================================

//! Optional Sub-Structure of #UBX_RXM_RAWX_DATA0_t
typedef struct UBX_RXM_RAWX_DATA0_PRMES_s
{
    R8  prMes;                    //!< Pseudorange measurement [m]. GLONASS inter frequency channel delays are compensated with an internal calibration table.
    R8  cpMes;                    //!< Carrier phase measurement [cycles]. The carrier phase initial ambiguity is initialized using an approximate value to make the magnitude of the phase close to the pseudorange measurement. Clock resets are applied to both phase and code measurements in accordance with the RINEX specification.
    R4  doMes;                    //!< Doppler measurement (positive sign for approaching satellites) [Hz]
    U1  gnssId;                   //!< GNSS identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r> for a list of identifiers)
    U1  svId;                     //!< Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  freqId;                   //!< Only used for GLONASS: This is the frequency slot + 7 (range from 0 to 13)
    U2  locktime;                 //!< Carrier phase locktime counter (maximum 64500ms)
    U1  cno;                      //!< Carrier-to-noise density ratio (signal strength) [dB-Hz]
    X1  prStdev;                  //!< Estimated pseudorange measurement standard deviation
    X1  cpStdev;                  //!< Estimated carrier phase measurement standard deviation (note a raw value of 0x0F indicates the value is invalid)
    X1  doStdev;                  //!< Estimated Doppler measurement standard deviation.
    X1  trkStat;                  //!< Tracking status bitfield
    U1  reserved3;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_RXM_RAWX_DATA0_PRMES_t, *UBX_RXM_RAWX_DATA0_PRMES_pt;

//! \name Bit Definitions for #UBX_RXM_RAWX_DATA0_PRMES_s::prStdev
//@{
#define UBX_RXM_RAWX_DATA0_PRMES_PRSTDEV_PRSTD_MASK 0x0F  //!< Mask for field prStd in bitmask prStdev
#define UBX_RXM_RAWX_DATA0_PRMES_PRSTDEV_PRSTD_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_PRMES_PRSTDEV_PRSTD_MASK)>>0)  //!< Get prStd from bitmask prStdev

//@}
//! \name Bit Definitions for #UBX_RXM_RAWX_DATA0_PRMES_s::cpStdev
//@{
#define UBX_RXM_RAWX_DATA0_PRMES_CPSTDEV_CPSTD_MASK 0x0F  //!< Mask for field cpStd in bitmask cpStdev
#define UBX_RXM_RAWX_DATA0_PRMES_CPSTDEV_CPSTD_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_PRMES_CPSTDEV_CPSTD_MASK)>>0)  //!< Get cpStd from bitmask cpStdev

//@}
//! \name Bit Definitions for #UBX_RXM_RAWX_DATA0_PRMES_s::doStdev
//@{
#define UBX_RXM_RAWX_DATA0_PRMES_DOSTDEV_DOSTD_MASK 0x0F  //!< Mask for field doStd in bitmask doStdev
#define UBX_RXM_RAWX_DATA0_PRMES_DOSTDEV_DOSTD_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_PRMES_DOSTDEV_DOSTD_MASK)>>0)  //!< Get doStd from bitmask doStdev

//@}
//! \name Bit Definitions for #UBX_RXM_RAWX_DATA0_PRMES_s::trkStat
//@{
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_PRVALID_MASK 0x01  //!< Mask for field prValid in bitmask trkStat
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_PRVALID_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_PRVALID_MASK)>>0)  //!< Get prValid from bitmask trkStat
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_CPVALID_MASK 0x02  //!< Mask for field cpValid in bitmask trkStat
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_CPVALID_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_CPVALID_MASK)>>1)  //!< Get cpValid from bitmask trkStat
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_HALFCYC_MASK 0x04  //!< Mask for field halfCyc in bitmask trkStat
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_HALFCYC_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_HALFCYC_MASK)>>2)  //!< Get halfCyc from bitmask trkStat
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_SUBHALFCYC_MASK 0x08  //!< Mask for field subHalfCyc in bitmask trkStat
#define UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_SUBHALFCYC_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_PRMES_TRKSTAT_SUBHALFCYC_MASK)>>3)  //!< Get subHalfCyc from bitmask trkStat

//@}


typedef struct UBX_RXM_RAWX_DATA0_s
{
    R8  rcvTow;                   //!< Measurement time of week in <r href=\"REC-LOCAL-TIME-DESC'>receiver local time</r> approximately aligned to the GPS time system. The receiver local time of week, week number and leap second information can be used to translate the time to other time systems. More information about the difference in time systems can be found in <r href=\"ftp://ftp.igs.org/pub/data/format/rinex300.pdf'>RINEX 3</r> documentation. For a receiver operating in GLONASS only mode, UTC time can be determined by subtracting the leapS field from GPS time regardless of whether the GPS leap seconds are valid.
    U2  week;                     //!< GPS week number in <r href=\"REC-LOCAL-TIME-DESC'>receiver local time.</r>
    I1  leapS;                    //!< GPS leap seconds (GPS-UTC). This field represents the receiver's best knowledge of the leap seconds offset. A flag is given in the recStat bitfield to indicate if the leap seconds are known.
    U1  numMeas;                  //!< Number of measurements to follow
    X1  recStat;                  //!< Receiver tracking status bitfield
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_RXM_RAWX_DATA0_PRMES_t repeat0[numMeas];

} UBX_RXM_RAWX_DATA0_t, *UBX_RXM_RAWX_DATA0_pt;


//! \name Bit Definitions for #UBX_RXM_RAWX_DATA0_s::recStat
//@{
#define UBX_RXM_RAWX_DATA0_RECSTAT_LEAPSEC_MASK 0x01  //!< Mask for field leapSec in bitmask recStat
#define UBX_RXM_RAWX_DATA0_RECSTAT_LEAPSEC_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_RECSTAT_LEAPSEC_MASK)>>0)  //!< Get leapSec from bitmask recStat
#define UBX_RXM_RAWX_DATA0_RECSTAT_CLKRESET_MASK 0x02  //!< Mask for field clkReset in bitmask recStat
#define UBX_RXM_RAWX_DATA0_RECSTAT_CLKRESET_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA0_RECSTAT_CLKRESET_MASK)>>1)  //!< Get clkReset from bitmask recStat

//@}

#define UBXID_RXM_RAWX 0x0215 //!< message id for RXM-RAWX


//================================================================
//! RXM_RAWX_DATA1: Periodic/Polled
/*!
Multi-GNSS Raw Measurement Data
This message contains the information needed to be able to generate a <r href=\"ftp://ftp.igs.org/pub/data/format/rinex300.pdf'>RINEX 3</r> multi-GNSS observation file.
This message contains pseudorange, Doppler, carrier phase, phase lock and signal quality information for GNSS satellites once signals have been synchronized. This message supports all active GNSS.
The only difference between this version of the message and the <rc href=\"UBX-RXM-RAWX-DATA0'>previous version</rc> is the addition of the version field.


This message's id is #UBXID_RXM_RAWX
*/
//================================================================

//! Optional Sub-Structure of #UBX_RXM_RAWX_DATA1_t
typedef struct UBX_RXM_RAWX_DATA1_PRMES_s
{
    R8  prMes;                    //!< Pseudorange measurement [m]. GLONASS inter frequency channel delays are compensated with an internal calibration table.
    R8  cpMes;                    //!< Carrier phase measurement [cycles]. The carrier phase initial ambiguity is initialized using an approximate value to make the magnitude of the phase close to the pseudorange measurement. Clock resets are applied to both phase and code measurements in accordance with the RINEX specification.
    R4  doMes;                    //!< Doppler measurement (positive sign for approaching satellites) [Hz]
    U1  gnssId;                   //!< GNSS identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r> for a list of identifiers)
    U1  svId;                     //!< Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  freqId;                   //!< Only used for GLONASS: This is the frequency slot + 7 (range from 0 to 13)
    U2  locktime;                 //!< Carrier phase locktime counter (maximum 64500ms)
    U1  cno;                      //!< Carrier-to-noise density ratio (signal strength) [dB-Hz]
    X1  prStdev;                  //!< Estimated pseudorange measurement standard deviation
    X1  cpStdev;                  //!< Estimated carrier phase measurement standard deviation (note a raw value of 0x0F indicates the value is invalid)
    X1  doStdev;                  //!< Estimated Doppler measurement standard deviation.
    X1  trkStat;                  //!< Tracking status bitfield
    U1  reserved3;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_RXM_RAWX_DATA1_PRMES_t, *UBX_RXM_RAWX_DATA1_PRMES_pt;

//! \name Bit Definitions for #UBX_RXM_RAWX_DATA1_PRMES_s::prStdev
//@{
#define UBX_RXM_RAWX_DATA1_PRMES_PRSTDEV_PRSTD_MASK 0x0F  //!< Mask for field prStd in bitmask prStdev
#define UBX_RXM_RAWX_DATA1_PRMES_PRSTDEV_PRSTD_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_PRMES_PRSTDEV_PRSTD_MASK)>>0)  //!< Get prStd from bitmask prStdev

//@}
//! \name Bit Definitions for #UBX_RXM_RAWX_DATA1_PRMES_s::cpStdev
//@{
#define UBX_RXM_RAWX_DATA1_PRMES_CPSTDEV_CPSTD_MASK 0x0F  //!< Mask for field cpStd in bitmask cpStdev
#define UBX_RXM_RAWX_DATA1_PRMES_CPSTDEV_CPSTD_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_PRMES_CPSTDEV_CPSTD_MASK)>>0)  //!< Get cpStd from bitmask cpStdev

//@}
//! \name Bit Definitions for #UBX_RXM_RAWX_DATA1_PRMES_s::doStdev
//@{
#define UBX_RXM_RAWX_DATA1_PRMES_DOSTDEV_DOSTD_MASK 0x0F  //!< Mask for field doStd in bitmask doStdev
#define UBX_RXM_RAWX_DATA1_PRMES_DOSTDEV_DOSTD_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_PRMES_DOSTDEV_DOSTD_MASK)>>0)  //!< Get doStd from bitmask doStdev

//@}
//! \name Bit Definitions for #UBX_RXM_RAWX_DATA1_PRMES_s::trkStat
//@{
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_PRVALID_MASK 0x01  //!< Mask for field prValid in bitmask trkStat
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_PRVALID_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_PRVALID_MASK)>>0)  //!< Get prValid from bitmask trkStat
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_CPVALID_MASK 0x02  //!< Mask for field cpValid in bitmask trkStat
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_CPVALID_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_CPVALID_MASK)>>1)  //!< Get cpValid from bitmask trkStat
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_HALFCYC_MASK 0x04  //!< Mask for field halfCyc in bitmask trkStat
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_HALFCYC_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_HALFCYC_MASK)>>2)  //!< Get halfCyc from bitmask trkStat
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_SUBHALFCYC_MASK 0x08  //!< Mask for field subHalfCyc in bitmask trkStat
#define UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_SUBHALFCYC_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_PRMES_TRKSTAT_SUBHALFCYC_MASK)>>3)  //!< Get subHalfCyc from bitmask trkStat

//@}


typedef struct UBX_RXM_RAWX_DATA1_s
{
    R8  rcvTow;                   //!< Measurement time of week in <r href=\"REC-LOCAL-TIME-DESC'>receiver local time</r> approximately aligned to the GPS time system. The receiver local time of week, week number and leap second information can be used to translate the time to other time systems. More information about the difference in time systems can be found in <r href=\"ftp://ftp.igs.org/pub/data/format/rinex300.pdf'>RINEX 3</r> documentation. For a receiver operating in GLONASS only mode, UTC time can be determined by subtracting the leapS field from GPS time regardless of whether the GPS leap seconds are valid.
    U2  week;                     //!< GPS week number in <r href=\"REC-LOCAL-TIME-DESC'>receiver local time.</r>
    I1  leapS;                    //!< GPS leap seconds (GPS-UTC). This field represents the receiver's best knowledge of the leap seconds offset. A flag is given in the recStat bitfield to indicate if the leap seconds are known.
    U1  numMeas;                  //!< Number of measurements to follow
    X1  recStat;                  //!< Receiver tracking status bitfield
    U1  version;                  //!< Message version (0x01 for this version).
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_RXM_RAWX_DATA1_PRMES_t repeat0[numMeas];

} UBX_RXM_RAWX_DATA1_t, *UBX_RXM_RAWX_DATA1_pt;


//! \name Bit Definitions for #UBX_RXM_RAWX_DATA1_s::recStat
//@{
#define UBX_RXM_RAWX_DATA1_RECSTAT_LEAPSEC_MASK 0x01  //!< Mask for field leapSec in bitmask recStat
#define UBX_RXM_RAWX_DATA1_RECSTAT_LEAPSEC_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_RECSTAT_LEAPSEC_MASK)>>0)  //!< Get leapSec from bitmask recStat
#define UBX_RXM_RAWX_DATA1_RECSTAT_CLKRESET_MASK 0x02  //!< Mask for field clkReset in bitmask recStat
#define UBX_RXM_RAWX_DATA1_RECSTAT_CLKRESET_GET(val)  (U)(((val)&UBX_RXM_RAWX_DATA1_RECSTAT_CLKRESET_MASK)>>1)  //!< Get clkReset from bitmask recStat

//@}

//#define UBXID_RXM_RAWX 0x0215  // already defined, see above


//================================================================
//! RXM_RLM_SHORT: Output
/*!
Galileo SAR Short-RLM report
This message contains the contents of any Galileo Search and Rescue (SAR) Short Return Link Message detected by the receiver.


This message's id is #UBXID_RXM_RLM
*/
//================================================================

typedef struct UBX_RXM_RLM_SHORT_s
{
    U1  version;                  //!< Message version (0x00 for this version)
    U1  type;                     //!< Message type (0x01 for Short-RLM)
    U1  svId;                     //!< Identifier of transmitting satellite (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  beacon[8];                //!< Beacon identifier (60 bits), with bytes ordered by earliest transmitted (most significant) first. Top four bits of first byte are zero.
    U1  message;                  //!< Message code (4 bits)
    U1  params[2];                //!< Parameters (16 bits), with bytes ordered by earliest transmitted (most significant) first.
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_RXM_RLM_SHORT_t, *UBX_RXM_RLM_SHORT_pt;


#define UBXID_RXM_RLM 0x0259 //!< message id for RXM-RLM


//================================================================
//! RXM_RLM_LONG: Output
/*!
Galileo SAR Long-RLM report
This message contains the contents of any Galileo Search and Rescue (SAR) Long Return Link Message detected by the receiver.


This message's id is #UBXID_RXM_RLM
*/
//================================================================

typedef struct UBX_RXM_RLM_LONG_s
{
    U1  version;                  //!< Message version (0x00 for this version)
    U1  type;                     //!< Message type (0x02 for Long-RLM)
    U1  svId;                     //!< Identifier of transmitting satellite (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  beacon[8];                //!< Beacon identifier (60 bits), with bytes ordered by earliest transmitted (most significant) first. Top four bits of first byte are zero.
    U1  message;                  //!< Message code (4 bits)
    U1  params[12];               //!< Parameters (96 bits), with bytes ordered by earliest transmitted (most significant) first.
    U1  reserved2[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_RXM_RLM_LONG_t, *UBX_RXM_RLM_LONG_pt;


//#define UBXID_RXM_RLM 0x0259  // already defined, see above


//================================================================
//! RXM_SFRBX_DATA1: Output
/*!
Broadcast Navigation Data Subframe
This message reports a complete subframe of broadcast navigation data decoded from a single signal. The number of data words reported in each message depends on the nature of the signal. See the section on <r href=\"SFRBX-DESC'>Broadcast Navigation Data</r> for further details.


This message's id is #UBXID_RXM_SFRBX
*/
//================================================================

//! Optional Sub-Structure of #UBX_RXM_SFRBX_DATA1_t
typedef struct UBX_RXM_SFRBX_DATA1_DWRD_s
{
    U4  dwrd;                     //!< The data words

} UBX_RXM_SFRBX_DATA1_DWRD_t, *UBX_RXM_SFRBX_DATA1_DWRD_pt;



typedef struct UBX_RXM_SFRBX_DATA1_s
{
    U1  gnssId;                   //!< GNSS identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  svId;                     //!< Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  freqId;                   //!< Only used for GLONASS: This is the frequency slot + 7 (range from 0 to 13)
    U1  numWords;                 //!< The number of data words contained in this message (0..16)
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  version;                  //!< Message version (0x01 for this version)
    U1  reserved3;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_RXM_SFRBX_DATA1_DWRD_t repeat0[numWords];

} UBX_RXM_SFRBX_DATA1_t, *UBX_RXM_SFRBX_DATA1_pt;


#define UBXID_RXM_SFRBX 0x0213 //!< message id for RXM-SFRBX


//================================================================
//! RXM_SFRBX_DATA2: Output
/*!
Broadcast Navigation Data Subframe
This message reports a complete subframe of broadcast navigation data decoded from a single signal. The number of data words reported in each message depends on the nature of the signal. See the section on <r href=\"SFRBX-DESC'>Broadcast Navigation Data</r> for further details.


This message's id is #UBXID_RXM_SFRBX
*/
//================================================================

//! Optional Sub-Structure of #UBX_RXM_SFRBX_DATA2_t
typedef struct UBX_RXM_SFRBX_DATA2_DWRD_s
{
    U4  dwrd;                     //!< The data words

} UBX_RXM_SFRBX_DATA2_DWRD_t, *UBX_RXM_SFRBX_DATA2_DWRD_pt;



typedef struct UBX_RXM_SFRBX_DATA2_s
{
    U1  gnssId;                   //!< GNSS identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  svId;                     //!< Satellite identifier (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  freqId;                   //!< Only used for GLONASS: This is the frequency slot + 7 (range from 0 to 13)
    U1  numWords;                 //!< The number of data words contained in this message (up to 10, for currently supported signals)
    U1  chn;                      //!< The tracking channel number the message was received on
    U1  version;                  //!< Message version, (0x02 for this version)
    U1  reserved2;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_RXM_SFRBX_DATA2_DWRD_t repeat0[numWords];

} UBX_RXM_SFRBX_DATA2_t, *UBX_RXM_SFRBX_DATA2_pt;


//#define UBXID_RXM_SFRBX 0x0213  // already defined, see above


//================================================================
//! RXM_SVSI_DATA0: Periodic/Polled
/*!
SV Status Info
Status of the receiver manager knowledge about GPS Orbit Validity
This message has only been retained for backwards compatibility; users are recommended to use the <rc href=\"UBX-NAV-ORB'>UBX-NAV-ORB</rc> message in preference.


This message's id is #UBXID_RXM_SVSI
*/
//================================================================

//! Optional Sub-Structure of #UBX_RXM_SVSI_DATA0_t
typedef struct UBX_RXM_SVSI_DATA0_SVID_s
{
    U1  svid;                     //!< Satellite ID
    X1  svFlag;                   //!< Information Flags
    I2  azim;                     //!< Azimuth
    I1  elev;                     //!< Elevation
    X1  age;                      //!< Age of Almanac and Ephemeris:

} UBX_RXM_SVSI_DATA0_SVID_t, *UBX_RXM_SVSI_DATA0_SVID_pt;

//! \name Bit Definitions for #UBX_RXM_SVSI_DATA0_SVID_s::svFlag
//@{
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_URA_MASK 0x0F  //!< Mask for field ura in bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_URA_GET(val)  (U)(((val)&UBX_RXM_SVSI_DATA0_SVID_SVFLAG_URA_MASK)>>0)  //!< Get ura from bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_HEALTHY_MASK 0x10  //!< Mask for field healthy in bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_HEALTHY_GET(val)  (U)(((val)&UBX_RXM_SVSI_DATA0_SVID_SVFLAG_HEALTHY_MASK)>>4)  //!< Get healthy from bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_EPHVAL_MASK 0x20  //!< Mask for field ephVal in bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_EPHVAL_GET(val)  (U)(((val)&UBX_RXM_SVSI_DATA0_SVID_SVFLAG_EPHVAL_MASK)>>5)  //!< Get ephVal from bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_ALMVAL_MASK 0x40  //!< Mask for field almVal in bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_ALMVAL_GET(val)  (U)(((val)&UBX_RXM_SVSI_DATA0_SVID_SVFLAG_ALMVAL_MASK)>>6)  //!< Get almVal from bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_NOTAVAIL_MASK 0x80  //!< Mask for field notAvail in bitmask svFlag
#define UBX_RXM_SVSI_DATA0_SVID_SVFLAG_NOTAVAIL_GET(val)  (U)(((val)&UBX_RXM_SVSI_DATA0_SVID_SVFLAG_NOTAVAIL_MASK)>>7)  //!< Get notAvail from bitmask svFlag

//@}
//! \name Bit Definitions for #UBX_RXM_SVSI_DATA0_SVID_s::age
//@{
#define UBX_RXM_SVSI_DATA0_SVID_AGE_ALMAGE_MASK 0x0F  //!< Mask for field almAge in bitmask age
#define UBX_RXM_SVSI_DATA0_SVID_AGE_ALMAGE_GET(val)  (U)(((val)&UBX_RXM_SVSI_DATA0_SVID_AGE_ALMAGE_MASK)>>0)  //!< Get almAge from bitmask age
#define UBX_RXM_SVSI_DATA0_SVID_AGE_EPHAGE_MASK 0xF0  //!< Mask for field ephAge in bitmask age
#define UBX_RXM_SVSI_DATA0_SVID_AGE_EPHAGE_GET(val)  (U)(((val)&UBX_RXM_SVSI_DATA0_SVID_AGE_EPHAGE_MASK)>>4)  //!< Get ephAge from bitmask age

//@}


typedef struct UBX_RXM_SVSI_DATA0_s
{
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>.
    I2  week;                     //!< GPS week number of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r>
    U1  numVis;                   //!< Number of visible satellites
    U1  numSV;                    //!< Number of per-SV data blocks following
    //REPEAT: UBX_RXM_SVSI_DATA0_SVID_t repeat0[numSV];

} UBX_RXM_SVSI_DATA0_t, *UBX_RXM_SVSI_DATA0_pt;


#define UBXID_RXM_SVSI 0x0220 //!< message id for RXM-SVSI


//================================================================
//! SEC_SIGN_DATA0: Output
/*!
Signature of a previous message
The message is the signature of a previously sent message. The signature is generated with a hash using the SHA-256 algorithm with the programmed seeds.


This message's id is #UBXID_SEC_SIGN
*/
//================================================================

typedef struct UBX_SEC_SIGN_DATA0_s
{
    U1  version;                  //!< Message version (0x01 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  classID;                  //!< Class ID of the referring message
    U1  messageID;                //!< Message ID of the referring message
    U2  checksum;                 //!< UBX Checksum of the referring message
    U1  hash[32];                 //!< SHA-256 hash of the referring message

} UBX_SEC_SIGN_DATA0_t, *UBX_SEC_SIGN_DATA0_pt;


#define UBXID_SEC_SIGN 0x2701 //!< message id for SEC-SIGN


//================================================================
//! SEC_UNIQID_DATA0: Output
/*!
Unique Chip ID
This message is used to retrieve a unique chip identifier (40 bits, 5 bytes).


This message's id is #UBXID_SEC_UNIQID
*/
//================================================================

typedef struct UBX_SEC_UNIQID_DATA0_s
{
    U1  version;                  //!< Message version (0x01 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  uniqueId[5];              //!< Unique chip ID

} UBX_SEC_UNIQID_DATA0_t, *UBX_SEC_UNIQID_DATA0_pt;


#define UBXID_SEC_UNIQID 0x2703 //!< message id for SEC-UNIQID


//================================================================
//! TIM_DOSC_DATA0: Output
/*!
Disciplined oscillator control
The receiver sends this message when it is disciplining an external oscillator and the external oscillator is set up to be controlled via the host.


This message's id is #UBXID_TIM_DOSC
*/
//================================================================

typedef struct UBX_TIM_DOSC_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  value;                    //!< The raw value to be applied to the DAC controlling the external oscillator. The least significant bits should be written to the DAC, with the higher bits being ignored.

} UBX_TIM_DOSC_DATA0_t, *UBX_TIM_DOSC_DATA0_pt;


#define UBXID_TIM_DOSC 0x0D11 //!< message id for TIM-DOSC


//================================================================
//! TIM_FCHG_DATA0: Periodic/Polled
/*!
Oscillator frequency changed notification
This message reports frequency changes commanded by the sync manager for the internal and external oscillator. It is output at the configured rate even if the sync manager decides not to command a frequency change.


This message's id is #UBXID_TIM_FCHG
*/
//================================================================

typedef struct UBX_TIM_FCHG_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  iTOW;                     //!< GPS time of week of the <r href=\"NAV-EPOCH-DESC'>navigation epoch</r> from which the sync manager obtains the GNSS specific data.
    I4  intDeltaFreq;             //!< Frequency increment of the internal oscillator
    U4  intDeltaFreqUnc;          //!< Uncertainty of the internal oscillator frequency increment
    U4  intRaw;                   //!< Current raw DAC setting commanded to the internal oscillator
    I4  extDeltaFreq;             //!< Frequency increment of the external oscillator
    U4  extDeltaFreqUnc;          //!< Uncertainty of the external oscillator frequency increment
    U4  extRaw;                   //!< Current raw DAC setting commanded to the external oscillator

} UBX_TIM_FCHG_DATA0_t, *UBX_TIM_FCHG_DATA0_pt;


#define UBXID_TIM_FCHG 0x0D16 //!< message id for TIM-FCHG


//================================================================
//! TIM_HOC_DATA0: Input
/*!
Host oscillator control
This message can be sent by the host to force the receiver to bypass the disciplining algorithms in the SMGR and carry out the instructed changes to internal or external oscillator frequency. No checks are carried out on the size of the frequency change requested, so normal limits imposed by the SMGR are ignored.
It is recommended that the disciplining of that oscillator is disabled before this message is sent (i.e. by clearing the enableInternal or enableExternal flag in the <rc href=\"UBX-CFG-SMGR-DATA0'>CFG-SMGR</rc> message), otherwise the autonomous disciplining processes may cancel the effect of the direct command.
Note that the GNSS subsystem may temporarily lose track of some/all satellite signals if a large change of the internal oscillator is made.


This message's id is #UBXID_TIM_HOC
*/
//================================================================

typedef struct UBX_TIM_HOC_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  oscId;                    //!< Id of oscillator:
    U1  flags;                    //!< Flags
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  value;                    //!< Required frequency offset or raw output, depending on the flags

} UBX_TIM_HOC_DATA0_t, *UBX_TIM_HOC_DATA0_pt;


//! \name Bit Definitions for #UBX_TIM_HOC_DATA0_s::flags
//@{
#define UBX_TIM_HOC_DATA0_FLAGS_RAW_MASK 0x01  //!< Mask for field raw in bitmask flags
#define UBX_TIM_HOC_DATA0_FLAGS_RAW_GET(val)  (U)(((val)&UBX_TIM_HOC_DATA0_FLAGS_RAW_MASK)>>0)  //!< Get raw from bitmask flags
#define UBX_TIM_HOC_DATA0_FLAGS_DIFFERENCE_MASK 0x02  //!< Mask for field difference in bitmask flags
#define UBX_TIM_HOC_DATA0_FLAGS_DIFFERENCE_GET(val)  (U)(((val)&UBX_TIM_HOC_DATA0_FLAGS_DIFFERENCE_MASK)>>1)  //!< Get difference from bitmask flags

//@}

#define UBXID_TIM_HOC 0x0D17 //!< message id for TIM-HOC


//================================================================
//! TIM_SMEAS_DATA0: Input/Output
/*!
Source measurement
Frequency and/or phase measurement of synchronization sources. The measurements are relative to the nominal frequency and nominal phase.
The receiver reports the measurements on its sync sources using this message. Which measurements are reported can be configured using UBX-CFG-SMGR.
The host may report offset of the receiver's outputs with this message as well. The receiver has to be configured using UBX-CFG-SMGR to enable the use of the external measurement messages. Otherwise the receiver will ignore them.


This message's id is #UBXID_TIM_SMEAS
*/
//================================================================

//! Optional Sub-Structure of #UBX_TIM_SMEAS_DATA0_t
typedef struct UBX_TIM_SMEAS_DATA0_SOURCEID_s
{
    U1  sourceId;                 //!< Index of source. SMEAS can provide six measurement sources. The first four sourceId values represent measurements made by the receiver and sent to the host. The first of these with a sourceId value of 0 is a measurement of the internal oscillator against the current receiver time-and-frequency estimate. The internal oscillator is being disciplined against that estimate and this result represents the current offset between the actual and desired internal oscillator states. The next three sourceId values represent frequency and time measurements made by the receiver against the internal oscillator. sourceId 1 represents the GNSS-derived frequency and time compared with the internal oscillator frequency and time. sourceId2 give measurements of a signal coming in on EXTINT0. sourceId 3 corresponds to a similar measurement on EXTINT1. The remaining two of these measurements (sourceId 4 and 5) are made by the host and sent to the receiver. A measurement with sourceId 4 is a measurement by the host of the internal oscillator and sourceId 5 indicates a host measurement of the external oscillator.
    X1  flags;                    //!< Flags
    I1  phaseOffsetFrac;          //!< Sub-nanosecond phase offset; the total offset is the sum of phaseOffset and phaseOffsetFrac
    U1  phaseUncFrac;             //!< Sub-nanosecond phase uncertainty
    I4  phaseOffset;              //!< Phase offset, positive if the source lags accurate phase and negative if the source is early
    U4  phaseUnc;                 //!< Phase uncertainty (one standard deviation)
    U1  reserved3[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    I4  freqOffset;               //!< Frequency offset, positive if the source frequency is too high, negative if the frequency is too low.
    U4  freqUnc;                  //!< Frequency uncertainty (one standard deviation)

} UBX_TIM_SMEAS_DATA0_SOURCEID_t, *UBX_TIM_SMEAS_DATA0_SOURCEID_pt;

//! \name Bit Definitions for #UBX_TIM_SMEAS_DATA0_SOURCEID_s::flags
//@{
#define UBX_TIM_SMEAS_DATA0_SOURCEID_FLAGS_FREQVALID_MASK 0x01  //!< Mask for field freqValid in bitmask flags
#define UBX_TIM_SMEAS_DATA0_SOURCEID_FLAGS_FREQVALID_GET(val)  (U)(((val)&UBX_TIM_SMEAS_DATA0_SOURCEID_FLAGS_FREQVALID_MASK)>>0)  //!< Get freqValid from bitmask flags
#define UBX_TIM_SMEAS_DATA0_SOURCEID_FLAGS_PHASEVALID_MASK 0x02  //!< Mask for field phaseValid in bitmask flags
#define UBX_TIM_SMEAS_DATA0_SOURCEID_FLAGS_PHASEVALID_GET(val)  (U)(((val)&UBX_TIM_SMEAS_DATA0_SOURCEID_FLAGS_PHASEVALID_MASK)>>1)  //!< Get phaseValid from bitmask flags

//@}


typedef struct UBX_TIM_SMEAS_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  numMeas;                  //!< Number of measurements in repeated block
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U4  iTOW;                     //!< Time of the week
    U1  reserved2[4];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    //REPEAT: UBX_TIM_SMEAS_DATA0_SOURCEID_t repeat0[numMeas];

} UBX_TIM_SMEAS_DATA0_t, *UBX_TIM_SMEAS_DATA0_pt;


#define UBXID_TIM_SMEAS 0x0D13 //!< message id for TIM-SMEAS


//================================================================
//! TIM_SVIN_DATA0: Periodic/Polled
/*!
Survey-in data
This message contains information about survey-in parameters. For details about the Time Mode see section <r href=\"CFG-TMODE-DESC'>Time Mode Configuration</r>.


This message's id is #UBXID_TIM_SVIN
*/
//================================================================

typedef struct UBX_TIM_SVIN_DATA0_s
{
    U4  dur;                      //!< Passed survey-in observation time
    I4  meanX;                    //!< Current survey-in mean position ECEF X coordinate
    I4  meanY;                    //!< Current survey-in mean position ECEF Y coordinate
    I4  meanZ;                    //!< Current survey-in mean position ECEF Z coordinate
    U4  meanV;                    //!< Current survey-in mean position 3D variance
    U4  obs;                      //!< Number of position observations used during survey-in
    U1  valid;                    //!< Survey-in position validity flag, 1 = valid, otherwise 0
    U1  active;                   //!< Survey-in in progress flag, 1 = in-progress, otherwise 0
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_TIM_SVIN_DATA0_t, *UBX_TIM_SVIN_DATA0_pt;


#define UBXID_TIM_SVIN 0x0D04 //!< message id for TIM-SVIN


//================================================================
//! TIM_TM2_DATA1: Periodic/Polled
/*!
Time mark data
This message contains information for high precision time stamping / pulse counting.
The delay figures and timebase given in <rc href=\"UBX-CFG-TP5'>CFG-TP5</rc> are also applied to the time results output in this message.


This message's id is #UBXID_TIM_TM2
*/
//================================================================

typedef struct UBX_TIM_TM2_DATA1_s
{
    U1  ch;                       //!< Channel (i.e. EXTINT) upon which the pulse was measured
    X1  flags;                    //!< Bitmask
    U2  count;                    //!< rising edge counter.
    U2  wnR;                      //!< week number of last rising edge
    U2  wnF;                      //!< week number of last falling edge
    U4  towMsR;                   //!< tow of rising edge
    U4  towSubMsR;                //!< millisecond fraction of tow of rising edge in nanoseconds
    U4  towMsF;                   //!< tow of falling edge
    U4  towSubMsF;                //!< millisecond fraction of tow of falling edge in nanoseconds
    U4  accEst;                   //!< Accuracy estimate

} UBX_TIM_TM2_DATA1_t, *UBX_TIM_TM2_DATA1_pt;


//! \name Bit Definitions for #UBX_TIM_TM2_DATA1_s::flags
//@{
#define UBX_TIM_TM2_DATA1_FLAGS_MODE_MASK 0x01  //!< Mask for field mode in bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_MODE_GET(val)  (U)(((val)&UBX_TIM_TM2_DATA1_FLAGS_MODE_MASK)>>0)  //!< Get mode from bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_RUN_MASK 0x02  //!< Mask for field run in bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_RUN_GET(val)  (U)(((val)&UBX_TIM_TM2_DATA1_FLAGS_RUN_MASK)>>1)  //!< Get run from bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_NEWFALLINGEDGE_MASK 0x04  //!< Mask for field newFallingEdge in bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_NEWFALLINGEDGE_GET(val)  (U)(((val)&UBX_TIM_TM2_DATA1_FLAGS_NEWFALLINGEDGE_MASK)>>2)  //!< Get newFallingEdge from bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_TIMEBASE_MASK 0x18  //!< Mask for field timeBase in bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_TIMEBASE_GET(val)  (U)(((val)&UBX_TIM_TM2_DATA1_FLAGS_TIMEBASE_MASK)>>3)  //!< Get timeBase from bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_UTC_MASK 0x20  //!< Mask for field utc in bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_UTC_GET(val)  (U)(((val)&UBX_TIM_TM2_DATA1_FLAGS_UTC_MASK)>>5)  //!< Get utc from bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_TIME_MASK 0x40  //!< Mask for field time in bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_TIME_GET(val)  (U)(((val)&UBX_TIM_TM2_DATA1_FLAGS_TIME_MASK)>>6)  //!< Get time from bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_NEWRISINGEDGE_MASK 0x80  //!< Mask for field newRisingEdge in bitmask flags
#define UBX_TIM_TM2_DATA1_FLAGS_NEWRISINGEDGE_GET(val)  (U)(((val)&UBX_TIM_TM2_DATA1_FLAGS_NEWRISINGEDGE_MASK)>>7)  //!< Get newRisingEdge from bitmask flags

//@}

#define UBXID_TIM_TM2 0x0D03 //!< message id for TIM-TM2


//================================================================
//! TIM_TOS_DATA0: Periodic
/*!
Time Pulse Time and Frequency Data
This message contains information about the time pulse that has just happened and the state of the disciplined oscillators(s) at the time of the pulse. It gives the UTC and GNSS times and time uncertainty of the pulse together with frequency and frequency uncertainty of the disciplined oscillators. It also supplies leap second information.


This message's id is #UBXID_TIM_TOS
*/
//================================================================

typedef struct UBX_TIM_TOS_DATA0_s
{
    U1  version;                  //!< Message version (0 for this version)
    U1  gnssId;                   //!< GNSS system used for reporting GNSS time (see <r href=\"DESC-SVNumbering-UBX'>Satellite Numbering</r>)
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    X4  flags;                    //!< Flags
    U2  year;                     //!< Year of UTC time
    U1  month;                    //!< Month of UTC time
    U1  day;                      //!< Day of UTC time
    U1  hour;                     //!< Hour of UTC time
    U1  minute;                   //!< Minute of UTC time
    U1  second;                   //!< Second of UTC time
    U1  utcStandard;              //!< UTC standard identifier:
    I4  utcOffset;                //!< Time offset between the preceding pulse and UTC top of second
    U4  utcUncertainty;           //!< Uncertainty of utcOffset
    U4  week;                     //!< GNSS week number
    U4  TOW;                      //!< GNSS time of week
    I4  gnssOffset;               //!< Time offset between the preceding pulse and GNSS top of second
    U4  gnssUncertainty;          //!< Uncertainty of gnssOffset
    I4  intOscOffset;             //!< Internal oscillator frequency offset
    U4  intOscUncertainty;        //!< Internal oscillator frequency uncertainty
    I4  extOscOffset;             //!< External oscillator frequency offset
    U4  extOscUncertainty;        //!< External oscillator frequency uncertainty

} UBX_TIM_TOS_DATA0_t, *UBX_TIM_TOS_DATA0_pt;


//! \name Bit Definitions for #UBX_TIM_TOS_DATA0_s::flags
//@{
#define UBX_TIM_TOS_DATA0_FLAGS_LEAPNOW_MASK 0x01  //!< Mask for field leapNow in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_LEAPNOW_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_LEAPNOW_MASK)>>0)  //!< Get leapNow from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_LEAPSOON_MASK 0x02  //!< Mask for field leapSoon in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_LEAPSOON_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_LEAPSOON_MASK)>>1)  //!< Get leapSoon from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_LEAPPOSITIVE_MASK 0x04  //!< Mask for field leapPositive in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_LEAPPOSITIVE_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_LEAPPOSITIVE_MASK)>>2)  //!< Get leapPositive from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_TIMEINLIMIT_MASK 0x08  //!< Mask for field timeInLimit in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_TIMEINLIMIT_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_TIMEINLIMIT_MASK)>>3)  //!< Get timeInLimit from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_INTOSCINLIMIT_MASK 0x10  //!< Mask for field intOscInLimit in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_INTOSCINLIMIT_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_INTOSCINLIMIT_MASK)>>4)  //!< Get intOscInLimit from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_EXTOSCINLIMIT_MASK 0x20  //!< Mask for field extOscInLimit in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_EXTOSCINLIMIT_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_EXTOSCINLIMIT_MASK)>>5)  //!< Get extOscInLimit from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_GNSSTIMEVALID_MASK 0x40  //!< Mask for field gnssTimeValid in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_GNSSTIMEVALID_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_GNSSTIMEVALID_MASK)>>6)  //!< Get gnssTimeValid from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_UTCTIMEVALID_MASK 0x80  //!< Mask for field UTCTimeValid in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_UTCTIMEVALID_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_UTCTIMEVALID_MASK)>>7)  //!< Get UTCTimeValid from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_DISCSRC_MASK 0x700  //!< Mask for field DiscSrc in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_DISCSRC_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_DISCSRC_MASK)>>8)  //!< Get DiscSrc from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_RAIM_MASK 0x800  //!< Mask for field raim in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_RAIM_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_RAIM_MASK)>>11)  //!< Get raim from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_COHPULSE_MASK 0x1000  //!< Mask for field cohPulse in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_COHPULSE_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_COHPULSE_MASK)>>12)  //!< Get cohPulse from bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_LOCKEDPULSE_MASK 0x2000  //!< Mask for field lockedPulse in bitmask flags
#define UBX_TIM_TOS_DATA0_FLAGS_LOCKEDPULSE_GET(val)  (U)(((val)&UBX_TIM_TOS_DATA0_FLAGS_LOCKEDPULSE_MASK)>>13)  //!< Get lockedPulse from bitmask flags

//@}

#define UBXID_TIM_TOS 0x0D12 //!< message id for TIM-TOS


//================================================================
//! TIM_TP_DATA0: Periodic/Polled
/*!
Time Pulse Timedata
This message contains information for high precision timing. The recommended configuration when using this message is to set both the measurement rate (<rc href=\"UBX-CFG-RATE'>CFG-RATE</rc>) and the timepulse frequency (<rc href=\"UBX-CFG-TP5'>CFG-TP5</rc>) to 1Hz. For more information see section <r href=\"CFG-TP5-DESC'>Time pulse</r>.


This message's id is #UBXID_TIM_TP
*/
//================================================================

typedef struct UBX_TIM_TP_DATA0_s
{
    U4  towMS;                    //!< Time pulse time of week according to time base
    U4  towSubMS;                 //!< Submillisecond part of TOWMS
    I4  qErr;                     //!< Quantization error of time pulse (not supported for the FTS product variant).
    U2  week;                     //!< Time pulse week number according to time base
    X1  flags;                    //!< bitmask
    X1  refInfo;                  //!< Time reference information

} UBX_TIM_TP_DATA0_t, *UBX_TIM_TP_DATA0_pt;


//! \name Bit Definitions for #UBX_TIM_TP_DATA0_s::flags
//@{
#define UBX_TIM_TP_DATA0_FLAGS_TIMEBASE_MASK 0x01  //!< Mask for field timeBase in bitmask flags
#define UBX_TIM_TP_DATA0_FLAGS_TIMEBASE_GET(val)  (U)(((val)&UBX_TIM_TP_DATA0_FLAGS_TIMEBASE_MASK)>>0)  //!< Get timeBase from bitmask flags
#define UBX_TIM_TP_DATA0_FLAGS_UTC_MASK 0x02  //!< Mask for field utc in bitmask flags
#define UBX_TIM_TP_DATA0_FLAGS_UTC_GET(val)  (U)(((val)&UBX_TIM_TP_DATA0_FLAGS_UTC_MASK)>>1)  //!< Get utc from bitmask flags
#define UBX_TIM_TP_DATA0_FLAGS_RAIM_MASK 0x0C  //!< Mask for field raim in bitmask flags
#define UBX_TIM_TP_DATA0_FLAGS_RAIM_GET(val)  (U)(((val)&UBX_TIM_TP_DATA0_FLAGS_RAIM_MASK)>>2)  //!< Get raim from bitmask flags

//@}
//! \name Bit Definitions for #UBX_TIM_TP_DATA0_s::refInfo
//@{
#define UBX_TIM_TP_DATA0_REFINFO_TIMEREFGNSS_MASK 0x0F  //!< Mask for field timeRefGnss in bitmask refInfo
#define UBX_TIM_TP_DATA0_REFINFO_TIMEREFGNSS_GET(val)  (U)(((val)&UBX_TIM_TP_DATA0_REFINFO_TIMEREFGNSS_MASK)>>0)  //!< Get timeRefGnss from bitmask refInfo
#define UBX_TIM_TP_DATA0_REFINFO_UTCSTANDARD_MASK 0xF0  //!< Mask for field utcStandard in bitmask refInfo
#define UBX_TIM_TP_DATA0_REFINFO_UTCSTANDARD_GET(val)  (U)(((val)&UBX_TIM_TP_DATA0_REFINFO_UTCSTANDARD_MASK)>>4)  //!< Get utcStandard from bitmask refInfo

//@}

#define UBXID_TIM_TP 0x0D01 //!< message id for TIM-TP


//================================================================
//! TIM_VCOCAL_STOP: Command
/*!
Stop calibration
Stop all ongoing calibration (both oscillators are affected)


This message's id is #UBXID_TIM_VCOCAL
*/
//================================================================

typedef struct UBX_TIM_VCOCAL_STOP_s
{
    U1  type;                     //!< Message type (0 for this message)

} UBX_TIM_VCOCAL_STOP_t, *UBX_TIM_VCOCAL_STOP_pt;


#define UBXID_TIM_VCOCAL 0x0D15 //!< message id for TIM-VCOCAL


//================================================================
//! TIM_VCOCAL_CMD1: Command
/*!
VCO calibration extended command
Calibrate (measure) gain of the voltage controlled oscillator. The calibration is performed by varying the raw oscillator control values between the limits specified in raw0 and raw1. maxStepSize is the largest step change that can be used during the calibration process. The \"raw values\" are either PWM duty cycle values or DAC values depending on how the VCTCXO is connected to the system. The measured gain is the transfer function dRelativeFrequencyChange/dRaw (not dFrequency/dVoltage). The calibration process works as follows:
Starting from the current raw output the control value is changed in the direction of raw0 in steps of size at most maxStepSize. Then the frequency is measured and the control value is changed towards raw1, again in steps of maxStepSize. When raw1 is reached, the frequency is again measured and the message version DATA0 is output containing the measured result. Normal operation then resumes. If the control value movement is less than maxStepSize then the transition will happen in one step - this will give fast calibration.
Care must be taken when calibrating the internal oscillator against the GNSS source. In that case the changes applied to the oscillator frequency could be severe enough to lose satellite signal tracking, especially when signals are weak. If too many signals are lost, the GNSS system will lose its fix and be unable to measure the oscillator frequency - the calibration will then fail. In this case maxStepSize must be reasonably small.
It is also important that only the chosen frequency source is enabled during the calibration process and that it remains stable throughout the calibration period; otherwise incorrect oscillator measurements will be made and this will lead to miscalibration and poor subsequent operation of the receiver.


This message's id is #UBXID_TIM_VCOCAL
*/
//================================================================

typedef struct UBX_TIM_VCOCAL_CMD1_s
{
    U1  type;                     //!< Message type (2 for this message)
    U1  version;                  //!< Message version (0 for this version)
    U1  oscId;                    //!< Oscillator to be calibrated:
    U1  srcId;                    //!< Reference source:
    U1  reserved1[2];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  raw0;                     //!< First value used for calibration
    U2  raw1;                     //!< Second value used for calibration
    U2  maxStepSize;              //!< Maximum step size to be used

} UBX_TIM_VCOCAL_CMD1_t, *UBX_TIM_VCOCAL_CMD1_pt;


//#define UBXID_TIM_VCOCAL 0x0D15  // already defined, see above


//================================================================
//! TIM_VCOCAL_DATA0: Periodic/Polled
/*!
Results of the calibration
This message is sent when the oscillator gain calibration process is finished (successful or unsuccessful). It notifies the user of the calibrated oscillator gain. If the oscillator gain calibration process was successful, this message will contain the measured gain (field gainVco) and its uncertainty (field gainUncertainty). The calibration process can however fail. In that case the two fields gainVco and gainUncertainty are set to zero.


This message's id is #UBXID_TIM_VCOCAL
*/
//================================================================

typedef struct UBX_TIM_VCOCAL_DATA0_s
{
    U1  type;                     //!< Message type (3 for this message)
    U1  version;                  //!< Message version (0 for this version)
    U1  oscId;                    //!< Id of oscillator:
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U2  gainUncertainty;          //!< Relative gain uncertainty after calibration, 0 if calibration failed
    I4  gainVco;                  //!< Calibrated gain or 0 if calibration failed

} UBX_TIM_VCOCAL_DATA0_t, *UBX_TIM_VCOCAL_DATA0_pt;


//#define UBXID_TIM_VCOCAL 0x0D15  // already defined, see above


//================================================================
//! TIM_VRFY_DATA1: Periodic/Polled
/*!
Sourced Time Verification
This message contains verification information about previous time received via AID-INI or from RTC


This message's id is #UBXID_TIM_VRFY
*/
//================================================================

typedef struct UBX_TIM_VRFY_DATA1_s
{
    I4  itow;                     //!< integer millisecond tow received by source
    I4  frac;                     //!< sub-millisecond part of tow
    I4  deltaMs;                  //!< integer milliseconds of delta time (current time minus sourced time)
    I4  deltaNs;                  //!< sub-millisecond part of delta time
    U2  wno;                      //!< week number
    X1  flags;                    //!< information flags
    U1  reserved1;                //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_TIM_VRFY_DATA1_t, *UBX_TIM_VRFY_DATA1_pt;


//! \name Bit Definitions for #UBX_TIM_VRFY_DATA1_s::flags
//@{
#define UBX_TIM_VRFY_DATA1_FLAGS_SRC_MASK 0x07  //!< Mask for field src in bitmask flags
#define UBX_TIM_VRFY_DATA1_FLAGS_SRC_GET(val)  (U)(((val)&UBX_TIM_VRFY_DATA1_FLAGS_SRC_MASK)>>0)  //!< Get src from bitmask flags

//@}

#define UBXID_TIM_VRFY 0x0D06 //!< message id for TIM-VRFY


//================================================================
//! UPD_SOS_POLL0: Poll Request
/*!
Poll Backup File Restore Status
Sending this (empty / no-payload) message to the receiver results in the receiver returning a <i>System Restored from Backup</i> message as defined below.


This message's id is #UBXID_UPD_SOS
*/
//================================================================

typedef struct UBX_UPD_SOS_POLL0_s
{

} UBX_UPD_SOS_POLL0_t, *UBX_UPD_SOS_POLL0_pt;


#define UBXID_UPD_SOS 0x0914 //!< message id for UPD-SOS


//================================================================
//! UPD_SOS_BACKUP: Command
/*!
Create Backup File in Flash
The host can send this message in order to save part of the BBR memory in a file in flash file system. The feature is designed in order to emulate the presence of the backup battery even if it is not present; the host can issue the save on shutdown command before switching off the device supply. It is recommended to issue a GNSS stop command before, in order to keep the BBR memory content consistent.


This message's id is #UBXID_UPD_SOS
*/
//================================================================

typedef struct UBX_UPD_SOS_BACKUP_s
{
    U1  cmd;                      //!< Command (must be 0)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_UPD_SOS_BACKUP_t, *UBX_UPD_SOS_BACKUP_pt;


//#define UBXID_UPD_SOS 0x0914  // already defined, see above


//================================================================
//! UPD_SOS_CLEAR: Command
/*!
Clear Backup in Flash
The host can send this message in order to erase the backup file present in flash. It is recommended that the clear operation is issued after the host has received the notification that the memory has been restored after a reset. Alternatively the host can parse the startup string 'Restored data saved on shutdown' or poll the UBX-UPD-SOS message for getting the status.


This message's id is #UBXID_UPD_SOS
*/
//================================================================

typedef struct UBX_UPD_SOS_CLEAR_s
{
    U1  cmd;                      //!< Command (must be 1)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_UPD_SOS_CLEAR_t, *UBX_UPD_SOS_CLEAR_pt;


//#define UBXID_UPD_SOS 0x0914  // already defined, see above


//================================================================
//! UPD_SOS_ACK: Output
/*!
Backup File Creation Acknowledge
The message is sent from the device as confirmation of creation of a backup file in flash. The host can safely shut down the device after received this message.


This message's id is #UBXID_UPD_SOS
*/
//================================================================

typedef struct UBX_UPD_SOS_ACK_s
{
    U1  cmd;                      //!< Command (must be 2)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  response;                 //!< 0:  Not acknowledged
    U1  reserved2[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_UPD_SOS_ACK_t, *UBX_UPD_SOS_ACK_pt;


//#define UBXID_UPD_SOS 0x0914  // already defined, see above


//================================================================
//! UPD_SOS_RESTORED: Output
/*!
System Restored from Backup
The message is sent from the device to notify the host the BBR has been restored from a backup file in flash. The host should clear the backup file after receiving this message. If the UBX-UPD-SOS message is polled, this message will be resent.


This message's id is #UBXID_UPD_SOS
*/
//================================================================

typedef struct UBX_UPD_SOS_RESTORED_s
{
    U1  cmd;                      //!< Command (must be 3)
    U1  reserved1[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>
    U1  response;                 //!< 0:  Unknown
    U1  reserved2[3];             //!< <r href='DESC-UBX-Reserved'>Reserved</r>

} UBX_UPD_SOS_RESTORED_t, *UBX_UPD_SOS_RESTORED_pt;


//#define UBXID_UPD_SOS 0x0914  // already defined, see above

#endif //__PROTO_UBX_STRUCT_DEF_H__
